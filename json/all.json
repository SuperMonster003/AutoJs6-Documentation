{
  "source": "..\\api\\all.md",
  "desc": [
    {
      "type": "html",
      "pre": false,
      "text": "<!-- [start-include:overview.md] -->\n"
    }
  ],
  "modules": [
    {
      "textRaw": "综述 (Overview)",
      "name": "综述_(overview)",
      "desc": "<hr>\n<p>AutoJs6: 安卓平台 JavaScript 自动化工具.</p>\n<ul>\n<li>脚本语言: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/\">JavaScript</a>  </li>\n<li>脚本引擎: <a href=\"https://github.com/mozilla/rhino/\">Rhino</a>  </li>\n<li>支持特性: <a href=\"https://262.ecma-international.org/5.1/\">ES5</a> (全部), <a href=\"https://262.ecma-international.org/6.0/\">ES6</a> (部分)</li>\n</ul>\n<hr>\n<p>扩展阅读:</p>\n<ul>\n<li>了解 JavaScript<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/\">MDN - JavaScript 基础</a></li>\n<li><a href=\"https://zh.javascript.info/\">JavaScript.info - JavaScript 教程</a></li>\n</ul>\n</li>\n<li>查看 Rhino 引擎兼容性列表<ul>\n<li><a href=\"https://mozilla.github.io/rhino/compat/engines.html\">Rhino ES2015 Support</a></li>\n</ul>\n</li>\n<li>使用 PC (个人计算机) 开发<ul>\n<li><a href=\"https://github.com/SuperMonster003/AutoJs6-VSCode-Extension/\">AutoJs6 VSCode Extension</a></li>\n</ul>\n</li>\n<li>使用 Node.js 开发<ul>\n<li><a href=\"https://pro.autojs.org/\">Auto.js Pro</a></li>\n</ul>\n</li>\n<li>使用 TypeScript 开发<ul>\n<li><a href=\"https://github.com/pboymt/autojs-dev/\">Auto.js DevTools</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>阅读文档:</p>\n<ul>\n<li>宽屏设备网页阅读<ul>\n<li>点击左侧边栏条目 - 阅读相关章节</li>\n</ul>\n</li>\n<li>移动设备网页阅读<ul>\n<li>点击左下方抽屉按钮 - 展开侧边栏并点击条目 - 阅读相关章节</li>\n</ul>\n</li>\n<li>AutoJs6 阅读<ul>\n<li>点击首页 &quot;文档&quot; 标签 - 点击条目 - 阅读相关章节</li>\n<li>点击首页右上方 &quot;搜索&quot; 图标 - 在当前页面检索内容</li>\n<li>文档页面左上方的导航链接可实现页面跳转:<ul>\n<li>点击 &quot;索引&quot; - 跳转至章节索引页面</li>\n<li>点击 &quot;查看全部&quot; - 所有章节内容在同一页面列出</li>\n</ul>\n</li>\n<li>阅读文档时, &quot;文档&quot; 标签可作为快捷按钮使用:<ul>\n<li>点击 &quot;文档&quot; 标签 - 返回至当前页面顶部</li>\n<li>长按 &quot;文档&quot; 标签 - 跳转至章节索引页面</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注: 初次阅读文档或首次使用 AutoJs6 建议从 <a href=\"documentation\">关于文档</a> 开始.\n<!-- [end-include:overview.md] --></p>\n</blockquote>\n<!-- [start-include:documentation.md] -->\n",
      "type": "module",
      "displayName": "综述 (Overview)"
    },
    {
      "textRaw": "疑难解答 (Q & A)",
      "name": "疑难解答_(q_&_a)",
      "desc": "<hr>\n",
      "modules": [
        {
          "textRaw": "图像",
          "name": "图像",
          "modules": [
            {
              "textRaw": "区域截图",
              "name": "区域截图",
              "desc": "<p>AutoJs6 不支持区域截图.<br>只能通过 <code>images.captureScreen</code> 截取屏幕后使用 <code>images.clip</code> 等方式做进一步处理.</p>\n",
              "type": "module",
              "displayName": "区域截图"
            }
          ],
          "type": "module",
          "displayName": "图像"
        },
        {
          "textRaw": "定时任务",
          "name": "定时任务",
          "modules": [
            {
              "textRaw": "定时运行脚本",
              "name": "定时运行脚本",
              "desc": "<p>脚本右侧菜单 -&gt; 定时任务, 即可定时运行脚本.<br>需保持 AutoJs6 后台运行, 包括 [ 自启动白名单 / 忽略电池优化 / 忽略后台活动限制 / 系统多任务保留 ] 等.<br>在设备关屏情况下, 可使用 <code>device.wakeUp()</code> 唤醒屏幕.<br>但 AutoJs6 暂未提供解锁功能, 因此可能需要根据设备自行设计解锁代码.</p>\n",
              "type": "module",
              "displayName": "定时运行脚本"
            },
            {
              "textRaw": "定时任务获取外部参数",
              "name": "定时任务获取外部参数",
              "desc": "<p>若脚本由 intent (如网络状态变化等特定事件) 触发启动, 可通过 <code>engines.myEngine().execArgv.intent</code> 获取 intent, 进而获取外部参数.</p>\n",
              "type": "module",
              "displayName": "定时任务获取外部参数"
            }
          ],
          "type": "module",
          "displayName": "定时任务"
        },
        {
          "textRaw": "打包应用",
          "name": "打包应用",
          "modules": [
            {
              "textRaw": "图片等资源共同打包及多脚本打包",
              "name": "图片等资源共同打包及多脚本打包",
              "desc": "<p>上述需求需使用 &quot;项目&quot; 功能.</p>\n<p>点击 AutoJs6 主页面 &quot;+&quot; 图标, 选择项目, 填写信息后可新建一个项目.<br>项目支持存放多个 [ 脚本 / 模块 / 资源文件 ].<br>项目工具栏的 APK 打包图标, 点击可打包一个项目.</p>\n<p>例如:<br>脚本读取同目录 <code>1.png</code>: <code>images.read(&quot;./1.png&quot;)</code>.<br>UI 脚本图片控件引用同目录 <code>2.png</code>: <code>&lt;img src=&quot;file://2.png&quot;/&gt;</code>.<br>AutoJs6 内置模块支持相对路径引用, 其他情况可能需借助 <code>files.path()</code> 转换为绝对路径.</p>\n",
              "type": "module",
              "displayName": "图片等资源共同打包及多脚本打包"
            },
            {
              "textRaw": "打包应用不显示主界面",
              "name": "打包应用不显示主界面",
              "desc": "<p>需使用 &quot;项目&quot; 功能.<br>新建项目后, 在项目目录 <code>project.json</code> 文件中增加以下条目:</p>\n<pre><code class=\"lang-json\">{\n  &quot;launchConfig&quot;: {\n    &quot;hideLogs&quot;: true\n  }\n}\n</code></pre>\n<p>例如:</p>\n<pre><code class=\"lang-json\">{\n  &quot;name&quot;: &quot;First-Project&quot;,\n  &quot;versionName&quot;: &quot;1.0.0&quot;,\n  &quot;versionCode&quot;: 1,\n  &quot;packageName&quot;: &quot;org.autojs.example.first&quot;,\n  &quot;main&quot;: &quot;main.js&quot;,\n  &quot;launchConfig&quot;: {\n    &quot;hideLogs&quot;: true\n  }\n}\n</code></pre>\n",
              "type": "module",
              "displayName": "打包应用不显示主界面"
            }
          ],
          "type": "module",
          "displayName": "打包应用"
        },
        {
          "textRaw": "功能扩展",
          "name": "功能扩展",
          "desc": "<p>AutoJs6 支持直接调用 [ Java / Android / 扩展库 ] 等 API.<br>对于 AutoJs6 没有内置的功能, 可进行 Java 脚本化, 即直接参照 Java (或 Kotlin 等) 源码, 转换为 JavaScript 代码.<br>例如:</p>\n<pre><code class=\"lang-java\">import android.graphics.Bitmap;\nimport android.graphics.Matrix;\n\npublic static Bitmap rotate(Bitmap src, int degrees, float px, float py) {\n    if (degrees == 0) return src;\n    Matrix matrix = new Matrix();\n    matrix.setRotate(degrees, px, py);\n    Bitmap ret = Bitmap.createBitmap(src, 0, 0, src.getWidth(), src.getHeight(), matrix, true);\n    return ret;\n}\n</code></pre>\n<p>转换为 JavaScript 代码:</p>\n<pre><code class=\"lang-js\">importClass(android.graphics.Bitmap);\nimportClass(android.graphics.Matrix);\n\nfunction rotate(src, degrees, px, py) {\n    if (degrees == 0) return src;\n    let matrix = new Matrix();\n    matrix.setRotate(degrees, px, py);\n    let ret = Bitmap.createBitmap(src, 0, 0, src.getWidth(), src.getHeight(), matrix, true);\n    return ret;\n}\n</code></pre>\n<p>关于脚本化 Java 的更多信息, 参阅 <a href=\"scriptingJava\">Scripting Java - 脚本化 Java</a> 章节.\n<!-- [end-include:qa.md] --></p>\n<!-- [start-include:global.md] -->\n",
          "type": "module",
          "displayName": "功能扩展"
        }
      ],
      "type": "module",
      "displayName": "疑难解答 (Q & A)"
    },
    {
      "textRaw": "全局对象 (Global)",
      "name": "全局对象_(global)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Nov 20, 2022.</p>\n\n<hr>\n<p>在 JavaScript 中, <a href=\"https://stackoverflow.com/questions/9108925/how-is-almost-everything-in-javascript-an-object/\">几乎一切都是对象</a>.<br>此处的全局 &quot;对象&quot; 包括 [ 变量 / 方法 / 构造器 ] 等.<br>全局对象随处可用, 包括 ECMA 标准内置对象 (如 [ Number / RegExp / String ] 等).</p>\n<p>AutoJs6 的内置模块均支持全局使用, 如 <code>app</code>, <code>images</code>, <code>device</code> 等.</p>\n<p>为便于使用, 一些 AutoJs6 模块中的方法也被全局化,<br>如 <code>images.captureScreen()</code>, <code>dialogs.alert()</code>, <code>app.launch()</code> 等.<br>全局化方法均以 <code>Global</code> 标签标注.</p>\n<p>脚本文件可直接运行使用, 也可作为模块被导入使用 (<code>require</code> 方法).<br>当作为模块使用时, <code>exports</code> 和 <code>module</code> 可作为全局对象使用.<br>另在 UI 模式下也有一些专属全局对象, 如 <code>activity</code>.</p>\n",
      "modules": [
        {
          "textRaw": "覆写保护",
          "name": "覆写保护",
          "desc": "<p>AutoJs6 对部分全局对象及内置模块增加了覆写保护.<br>以下全局声明或赋值将导致异常或非预期结果:</p>\n<pre><code class=\"lang-js\">/* 以全局对象 selector 为例. */\n\n/* 声明无效. */\nlet selector = 1; /* 异常: 变量 selector 重复声明. */\nconst selector = 1; /* 同上. */\nvar selector = 1; /* 同上. */\n\n/* 覆写无效 (非严格模式). */\nselector = 1;\ntypeof selector; // &quot;function&quot; - 静默失败, 覆写未生效.\n\n/* 覆写无效 (严格模式). */\n&quot;use strict&quot;;\nselector = 1; /* 异常: 无法修改只读属性: selector. */\n</code></pre>\n<p>局部作用域不受上述情况影响:</p>\n<pre><code class=\"lang-js\">(function () {\n    let selector = 1;\n    return typeof selector;\n})(); // &quot;number&quot;\n</code></pre>\n<p>截至目前 (2022/10) 受覆写保护的对象有:</p>\n<pre><code class=\"lang-text\">selector\ncontinuation\n</code></pre>\n<hr>\n<p style=\"font: bold 2em sans-serif; color: #FF7043\">global</p>\n\n<hr>\n",
          "type": "module",
          "displayName": "覆写保护"
        },
        {
          "textRaw": "[@] global",
          "name": "[@]_global",
          "desc": "<p>global 为 AutoJs6 的默认顶级作用域对象, 可作为全局对象使用:</p>\n<pre><code class=\"lang-js\">typeof global; // &quot;object&quot;\ntypeof global.sleep; // &quot;function&quot;\n</code></pre>\n<p>另, 访问顶级作用域对象也可通过以下代码:</p>\n<pre><code class=\"lang-js\">runtime.topLevelScope;\n</code></pre>\n<p><code>runtime.topLevelScope</code> 本身有 <code>&quot;global&quot;</code> 属性, 因此全局对象 <code>global</code> 也一样拥有:</p>\n<pre><code class=\"lang-js\">typeof runtime.topLevelScope.global; // &quot;object&quot;\n\nglobal.global === global; // true\nglobal.global.global.global === global; // true\n</code></pre>\n<p>global 对象可以增加属性, 也可以覆写甚至删除属性 (部分被保护):</p>\n<pre><code class=\"lang-js\">global.hello = &quot;hello&quot;;\ndelete global.hello;\n</code></pre>\n<p>global 对象本身是可被覆写的:</p>\n<pre><code class=\"lang-js\">typeof global; // &quot;object&quot;\nglobal = 3;\ntypeof global; // &quot;number&quot;\n</code></pre>\n<p>如果 global 对象被意外重写 (虽然概率很低),<br>可通过 <code>runtime.topLevelScope</code> 访问或还原:</p>\n<pre><code class=\"lang-js\">global = 3; /* 覆写 global 对象. */\ntypeof global; // &quot;number&quot;\ntypeof global.sleep; // &quot;undefined&quot;\ntypeof runtime.topLevelScope.sleep; // &quot;function&quot;\n\nglobal = runtime.topLevelScope; /* 还原 global 对象. */\ntypeof global; // &quot;object&quot;\ntypeof global.sleep; // &quot;function&quot;\n</code></pre>\n",
          "type": "module",
          "displayName": "[@] global"
        },
        {
          "textRaw": "[m] sleep",
          "name": "[m]_sleep",
          "methods": [
            {
              "textRaw": "sleep(millis)",
              "type": "method",
              "name": "sleep",
              "desc": "<p><strong><code>Overload 1/3</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>millis</strong> { <a href=\"dataTypes#number\">number</a> } - 休眠时间 (毫秒)</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>使当前线程休眠一段时间.</p>\n<pre><code class=\"lang-js\">/* 休眠 9 秒钟. */\nsleep(9000);\n/* 休眠 9 秒钟 (使用科学计数法). */\nsleep(9e3);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "millis"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "sleep(millisMin, millisMax)",
              "type": "method",
              "name": "sleep",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 2/3</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>millisMin</strong> { <a href=\"dataTypes#number\">number</a> } - 休眠时间下限 (毫秒)</li>\n<li><strong>millisMax</strong> { <a href=\"dataTypes#number\">number</a> } - 休眠时间上限 (毫秒)</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>使当前线程休眠一段时间, 该时间随机落在 millisMin 和 millisMax 之间.</p>\n<pre><code class=\"lang-js\">/* 随机休眠 3 - 5 秒钟. */\nsleep(3e3, 5e3);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "millisMin"
                    },
                    {
                      "name": "millisMax"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "sleep(millis, bounds)",
              "type": "method",
              "name": "sleep",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 3/3</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>millis</strong> { <a href=\"dataTypes#number\">number</a> } - 休眠时间 (毫秒)</li>\n<li><strong>bounds</strong> { <a href=\"dataTypes#NumberString\">NumberString</a> | <a href=\"dataTypes#string\">string</a> } - 浮动值</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>使当前线程休眠一段时间, 该时间随机落在 millis ± bounds 之间.<br>bounds 参数为 <a href=\"dataTypes#NumberString\">数字字符串</a> 类型 (如 &quot;12&quot;), 或在字符串开头附加 &quot;±&quot; 明确参数含义 (如 &quot;±12&quot;).</p>\n<pre><code class=\"lang-js\">/* 随机休眠 3 - 5 秒钟 (即 4 ± 1 秒钟). */\nsleep(4e3, &quot;1e3&quot;);\nsleep(4e3, &quot;±1e3&quot;); /* 同上. */\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "millis"
                    },
                    {
                      "name": "bounds"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] sleep"
        },
        {
          "textRaw": "[m+] toast",
          "name": "[m+]_toast",
          "methods": [
            {
              "textRaw": "toast(text)",
              "type": "method",
              "name": "toast",
              "desc": "<p><strong><code>Overload 1/4</code></strong> <strong><code>Async</code></strong></p>\n<ul>\n<li><strong>text</strong> { <a href=\"dataTypes#string\">string</a> } - 消息内容</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>显示一个 <a href=\"https://developer.android.com/guide/topics/ui/notifiers/toasts?hl=zh-cn\">消息浮动框</a>.</p>\n<p>消息框的显示默认是依次进行的:</p>\n<pre><code class=\"lang-js\">/* 显示消息框 2 秒钟. */\ntoast(&quot;hello&quot;);\n/* 显示消息框 2 秒钟, 且在前一个消息框消失后才显示. */\ntoast(&quot;world&quot;);\n/* 显示消息框 2 秒钟, 且在前一个消息框消失后才显示. */\ntoast(&quot;hello world&quot;);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "text"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "toast(text, isLong)",
              "type": "method",
              "name": "toast",
              "desc": "<p><strong><code>Overload 2/4</code></strong> <strong><code>Async</code></strong></p>\n<ul>\n<li><strong>text</strong> { <a href=\"dataTypes#string\">string</a> } - 消息内容</li>\n<li><strong>isLong = false</strong> { &quot;long&quot; | &quot;l&quot; | &quot;short&quot; | &quot;s&quot; | <a href=\"dataTypes#boolean\">boolean</a> } - 是否以较长时间显示</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>控制单个消息框显示时长:</p>\n<pre><code class=\"lang-js\">toast(&quot;hello&quot;, &#39;long&#39;); /* 显示消息框 3.5 秒钟. */\ntoast(&quot;hello&quot;, true); /* 同上. */\n</code></pre>\n<blockquote>\n<p>注: 仅有 [ 长 / 短 ] 两种时长, 此时长由安卓系统决定.<br>通常, 短时为 2 秒, 长时为 3.5 秒.</p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "text"
                    },
                    {
                      "name": "isLong"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "toast(text, isLong, isForcible)",
              "type": "method",
              "name": "toast",
              "desc": "<p><strong><code>Overload 3/4</code></strong> <strong><code>Async</code></strong></p>\n<ul>\n<li><strong>text</strong> { <a href=\"dataTypes#string\">string</a> } - 消息内容</li>\n<li><strong>isLong = false</strong> { &quot;long&quot; | &quot;l&quot; | &quot;short&quot; | &quot;s&quot; | <a href=\"dataTypes#boolean\">boolean</a> } - 是否以较长时间显示</li>\n<li><strong>isForcible = false</strong> { &quot;forcible&quot; | &quot;f&quot; | <a href=\"dataTypes#boolean\">boolean</a> } - 是否强制覆盖显示</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>使用 &quot;强制覆盖显示&quot; 参数可立即显示消息框:</p>\n<pre><code class=\"lang-js\">toast(&quot;hello&quot;);\n/* 显示消息框 2 秒钟, 且立即显示, 前一个消息框 &quot;hello&quot; 被 &quot;覆盖&quot;. */\ntoast(&quot;world&quot;, &quot;short&quot;, &quot;forcible&quot;);\n</code></pre>\n<blockquote>\n<p>注: 强制覆盖仅对当前脚本有效, 对其他脚本及应用程序无效.</p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "text"
                    },
                    {
                      "name": "isLong"
                    },
                    {
                      "name": "isForcible"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "toast(text, isForcible)",
              "type": "method",
              "name": "toast",
              "desc": "<p><strong><code>Overload 4/4</code></strong> <strong><code>Async</code></strong></p>\n<ul>\n<li><strong>text</strong> { <a href=\"dataTypes#string\">string</a> } - 消息内容</li>\n<li><strong>isForcible</strong> { &quot;forcible&quot; | &quot;f&quot; } - 强制覆盖显示 (字符标识)</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>此方法相当于忽略 isLong 参数:</p>\n<pre><code class=\"lang-js\">toast(&quot;hello&quot;);\n/* 显示消息框 2 秒钟, 且立即显示, 前一个消息框 &quot;hello&quot; 被 &quot;覆盖&quot;. */\ntoast(&quot;world&quot;, &quot;forcible&quot;);\n</code></pre>\n<blockquote>\n<p>注: 此方法的 isForcible 参数只能为具有明确意义的字符标识, 不能为 boolean 类型或其他类型, 否则 isForcible 将被视为 isLong.</p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "text"
                    },
                    {
                      "name": "isForcible"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "toast.dismissAll()",
              "type": "method",
              "name": "dismissAll",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "<ins>**returns**</ins> { [void](dataTypes#void) } ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [void](dataTypes#void) "
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>强制取消显示所有消息框.</p>\n<pre><code class=\"lang-js\">toast(&quot;hello&quot;);\ntoast(&quot;world&quot;);\ntoast(&quot;of&quot;);\ntoast(&quot;JavaScript&quot;);\n\nsleep(1e3);\n\n/* &quot;hello&quot; 显示 1 秒后消失, &quot;world&quot; 及其他消息框均不再显示. */\n/* 若无 sleep 语句, 由于 toast 是异步的, 上述消息框均不会显示. */\ntoast.dismissAll();\n\n/* dismissAll 仅对已在队列中的消息框有效, 因此下述消息框正常显示. */\ntoast(&quot;forcibly dismissed&quot;);\n</code></pre>\n<blockquote>\n<p>注: 强制取消显示仅对当前脚本有效, 对其他脚本及应用程序无效.</p>\n</blockquote>\n"
            }
          ],
          "type": "module",
          "displayName": "[m+] toast"
        },
        {
          "textRaw": "[m] toastLog",
          "name": "[m]_toastlog",
          "desc": "<p>显示消息浮动框并在控制台打印消息.<br>相当于以下代码组合:</p>\n<pre><code class=\"lang-js\">toast(text, ...args);\nconsole.log(text);\n</code></pre>\n<p>因此, 方法重载与 <a href=\"#m-toast\">toast</a> 完全一致.</p>\n<blockquote>\n<p>注: 虽然 toast 方法异步, 但 console.log 方法同步, 因此 toastLog 方法也为同步.</p>\n</blockquote>\n",
          "methods": [
            {
              "textRaw": "toastLog(text)",
              "type": "method",
              "name": "toastLog",
              "desc": "<p><strong><code>Overload 1/4</code></strong></p>\n<ul>\n<li><strong>text</strong> { <a href=\"dataTypes#string\">string</a> } - 消息内容</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#toasttext\">toast(text)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "text"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "toastLog(text, isLong)",
              "type": "method",
              "name": "toastLog",
              "desc": "<p><strong><code>Overload 2/4</code></strong></p>\n<ul>\n<li><strong>text</strong> { <a href=\"dataTypes#string\">string</a> } - 消息内容</li>\n<li><strong>isLong = false</strong> { &quot;long&quot; | &quot;l&quot; | &quot;short&quot; | &quot;s&quot; | <a href=\"dataTypes#boolean\">boolean</a> } - 是否以较长时间显示</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#toasttext-islong\">toast(text, isLong)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "text"
                    },
                    {
                      "name": "isLong"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "toastLog(text, isLong, isForcible)",
              "type": "method",
              "name": "toastLog",
              "desc": "<p><strong><code>Overload 3/4</code></strong></p>\n<ul>\n<li><strong>text</strong> { <a href=\"dataTypes#string\">string</a> } - 消息内容</li>\n<li><strong>isLong = false</strong> { &quot;long&quot; | &quot;l&quot; | &quot;short&quot; | &quot;s&quot; | <a href=\"dataTypes#boolean\">boolean</a> } - 是否以较长时间显示</li>\n<li><strong>isForcible = false</strong> { &quot;forcible&quot; | &quot;f&quot; | <a href=\"dataTypes#boolean\">boolean</a> } - 是否强制覆盖显示</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#toasttext-islong-isforcible\">toast(text, isLong, isForcible)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "text"
                    },
                    {
                      "name": "isLong"
                    },
                    {
                      "name": "isForcible"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "toastLog(text, isForcible)",
              "type": "method",
              "name": "toastLog",
              "desc": "<p><strong><code>Overload 4/4</code></strong></p>\n<ul>\n<li><strong>text</strong> { <a href=\"dataTypes#string\">string</a> } - 消息内容</li>\n<li><strong>isForcible</strong> { &quot;forcible&quot; | &quot;f&quot; } - 强制覆盖显示 (字符标识)</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#toasttext-isforcible\">toast(text, isForcible)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "text"
                    },
                    {
                      "name": "isForcible"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] toastLog"
        },
        {
          "textRaw": "[m] random",
          "name": "[m]_random",
          "methods": [
            {
              "textRaw": "random()",
              "type": "method",
              "name": "random",
              "desc": "<p><strong><code>Overload 1/2</code></strong></p>\n<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>与 Math.random() 相同, 返回落在 [0, 1) 区间的随机数字.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "random(min, max)",
              "type": "method",
              "name": "random",
              "desc": "<p><strong><code>Overload 2/2</code></strong></p>\n<ul>\n<li><strong>min</strong> { <a href=\"dataTypes#number\">number</a> } - 随机数下限</li>\n<li><strong>max</strong> { <a href=\"dataTypes#number\">number</a> } - 随机数上限</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>返回落在 [min, max] 区间的随机数字.</p>\n<blockquote>\n<p>注: random(min, max) 右边界闭合, 而 random() 右边界开放.</p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "min"
                    },
                    {
                      "name": "max"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] random"
        },
        {
          "textRaw": "[m] wait",
          "name": "[m]_wait",
          "methods": [
            {
              "textRaw": "wait(condition)",
              "type": "method",
              "name": "wait",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 1/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>condition</strong> { <a href=\"dataTypes#function\">(() =&gt; any)</a> | <a href=\"dataTypes#pickupselector\">PickupSelector</a> } - 结束等待条件</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<p>阻塞等待, 直到条件满足.<br>默认等待时间为 10 秒, 条件检查间隔为 200 毫秒.<br>若超时, 放弃等待, 并返回特定的条件超时结果 (如 false).<br>若超时之前条件得以满足, 结束等待, 并返回特定的条件满足结果 (如 true).</p>\n<blockquote>\n<p>注: 不同于 while 和 for 等循环语句的 &quot;条件&quot;,<br>该方法的条件是结束等待条件, 只要不满足条件, 就一直等待.<br>而循环语句的条件, 是只要满足条件, 就一直循环.</p>\n</blockquote>\n<p>等待条件支持函数及选择器.</p>\n<p>函数示例, 等待设备屏幕关闭:</p>\n<pre><code class=\"lang-js\">wait(function () {\n    return device.isScreenOff();\n});\n\n/* 使用箭头函数. */\nwait(() =&gt; device.isScreenOff());\n\n/* 使用 bind. */\nwait(device.isScreenOff.bind(device));\n\n/* 对结果分支处理. */\nif (wait(() =&gt; device.isScreenOff())) {\n    console.log(&quot;等待屏幕关闭成功&quot;);\n} else {\n    console.log(&quot;等待屏幕关闭超时&quot;);\n}\n</code></pre>\n<p>选择器示例, 等待文本为 &quot;立即开始&quot; 的控件出现:</p>\n<pre><code class=\"lang-js\">/* 以下三种方式为 Pickup 选择器的不同格式, 效果相同. */\nwait(&quot;立即开始&quot;);\nwait(content(&quot;立即开始&quot;)); /* 同上. */\nwait({ content: &quot;立即开始&quot; }); /* 同上. */\n\n/* 对比上述函数方式. */\nwait(() =&gt; content(&quot;立即开始&quot;).exists());\nwait(() =&gt; pickup(&quot;立即开始&quot;, &quot;?&quot;)); /* 同上. */\n</code></pre>\n<p>等待条件的满足与否, 与函数返回值有关.<br>例如当函数返回 true 时, 等待条件即满足.</p>\n<p>下面列出不满足条件的几种返回值:<br>[ <a href=\"dataTypes#boolean\">false</a> / <a href=\"dataTypes#null\">null</a> / <a href=\"dataTypes#undefined\">undefined</a> / <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/NaN/\">NaN</a> ]<br>除此之外的返回值均视为满足条件 (包括空字符串和数字 0 等).</p>\n<p>一种常见的错误用例, 即函数条件缺少返回值:</p>\n<pre><code class=\"lang-js\">wait(() =&gt; {\n    if (device.isScreenOff()) {\n        console.log(&quot;屏幕已成功关闭&quot;);\n    }\n});\n</code></pre>\n<p>上述示例中, 等待条件永远无法满足, 因函数一直返回 undefined.</p>\n<p>添加合适的返回值即可修正:</p>\n<pre><code class=\"lang-js\">wait(() =&gt; {\n    if (device.isScreenOff()) {\n        console.log(&quot;屏幕已成功关闭&quot;);\n        return true;\n    }\n});\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"uiSelectorType#m-pickup\">pickup</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "condition"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "wait(condition, limit)",
              "type": "method",
              "name": "wait",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 2/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>condition</strong> { <a href=\"dataTypes#function\">(() =&gt; any)</a> | <a href=\"uiSelectorType#m-pickup\">PickupSelector</a> } - 结束等待条件</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<p><a href=\"#waitcondition\">wait(condition)</a> 增加条件检测限制.<br>达到限制后, 表示等待超时, 并放弃等待.<br>限制分为 &quot;次数限制&quot; (limit &lt; 100) 和 &quot;时间限制&quot; (limit &gt;= 100).</p>\n<pre><code class=\"lang-js\">/* 等待屏幕关闭, 最多检测屏幕状态 20 次. */\nwait(() =&gt; device.isScreenOff(), 20); /* limit &lt; 100, 视为次数限制. */\n/* 等待屏幕关闭, 最多检测屏幕状态 5 秒钟. */\nwait(() =&gt; device.isScreenOff(), 5e3); /* limit &gt;= 100, 视为时间限制. */\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "condition"
                    },
                    {
                      "name": "limit"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "wait(condition, limit, interval)",
              "type": "method",
              "name": "wait",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 3/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>condition</strong> { <a href=\"dataTypes#function\">(() =&gt; any)</a> | <a href=\"uiSelectorType#m-pickup\">PickupSelector</a> } - 结束等待条件</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>interval</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测间隔</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<p><a href=\"#waitcondition-limit\">wait(condition, limit)</a> 增加条件检测间隔.<br>只要条件不满足, wait() 方法会持续检测, 直到条件满足或达到检测限制.<br>interval 参数用于设置条件检测之间的间歇时长, 默认为 200 毫秒.</p>\n<pre><code class=\"lang-text\">检查条件 (不满足) - 间歇 - 检查条件 (不满足) - 间歇 - 检查条件...\n</code></pre>\n<pre><code class=\"lang-js\">/* 等待屏幕关闭, 最多检测屏幕状态 20 次, 每次检查间歇 3 秒钟. */\nwait(() =&gt; device.isScreenOff(), 20, 3e3);\n/* 等待屏幕关闭, 最多检测屏幕状态 20 次, 并采用不间断检测 (无间歇). */\nwait(() =&gt; device.isScreenOff(), 20, 0);\n</code></pre>\n<blockquote>\n<p>注: 在最后一次条件检查之后, 将不再发生间歇.<br>包括条件满足或达到检测限制.</p>\n<p>例如在第三次检查时, 条件满足:<br>检查 (×) - 间歇 - 检查 (×) - 间歇 - 检查 (√) - 立即结束 wait()</p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "condition"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "interval"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "wait(condition, callback)",
              "type": "method",
              "name": "wait",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 4/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>condition</strong> { <a href=\"dataTypes#function\">(() =&gt; T)</a> | <a href=\"uiSelectorType#m-pickup\">PickupSelector</a> } - 结束等待条件</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<p><a href=\"#waitcondition\">wait(condition)</a> 增加回调对象.</p>\n<p>回调对象集合了两个方法, then 与 else 分别对应等待成功与等待失败的情况:</p>\n<pre><code class=\"lang-js\">wait(() =&gt; device.isScreenOff(), {\n    then: () =&gt; console.log(&quot;等待屏幕关闭成功&quot;),\n    else: () =&gt; console.log(&quot;等待屏幕关闭超时&quot;),\n});\n</code></pre>\n<p>两种方法都将最后一次检查结果作为实参, 可在方法体内直接使用:</p>\n<pre><code class=\"lang-js\">/* 等待一个落在 99.99 到 100 区间的随机数. */\nwait(() =&gt; {\n    let num = Math.random() * 100;\n    return num &gt; 99.99 &amp;&amp; num;\n}, {\n    then(o) {\n        console.log(`获取随机数成功, 数字是: ${o}`);\n    },\n    else() {\n        console.log(&quot;获取 99.99 到 100 的随机数超时&quot;);\n    },\n});\n</code></pre>\n<blockquote>\n<p>注: else 回调方法的参数只能是 [ <a href=\"dataTypes#boolean\">false</a> / <a href=\"dataTypes#null\">null</a> / <a href=\"dataTypes#undefined\">undefined</a> / <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/NaN/\">NaN</a> ],<br>因此 else 的参数几乎不会用到.</p>\n</blockquote>\n<p>需特别注意, 回调方法的返回值具有穿透性.<br>在回调方法内使用 return 语句, 将直接影响 wait() 的返回值 (undefined 除外).</p>\n<p>上述示例中, then 和 else 回调都没有返回值, 因此 wait() 返回值是 boolean 类型, 表示等待条件是否满足.<br>下述示例在回调函数中增加了返回值 (非 undefined), 则 wait() 也将返回这个值.</p>\n<pre><code class=\"lang-js\">let result = wait(() =&gt; {\n    let num = Math.random() * 100;\n    return num &gt; 99.99 &amp;&amp; num;\n}, {\n    then(o) {\n        console.log(`获取随机数成功`);\n        return o;\n    },\n    else() {\n        console.log(&quot;获取 99.99 到 100 的随机数超时&quot;);\n        return NaN;\n    },\n});\nresult; /* 一个数字 (如 99.99732126036437) 或 NaN. */\n</code></pre>\n<p>上述示例如果等待条件满足, 则返回 then 的返回值 (number 类型),<br>等待条件超时, 则返回 else 的返回值 (NaN, 也为 number 类型).</p>\n<p>如果去掉 else 的返回语句, 则等待条件超时后, wait() 将返回 false (boolean 类型).</p>\n<p>如需对 wait() 的返回值做进一步处理, 则建议两个回调方法的返回值类型一致:</p>\n<pre><code class=\"lang-js\">wait(() =&gt; {\n    let num = Math.random() * 100;\n    return num &gt; 99.99 &amp;&amp; num;\n}, {\n    then(o) {\n        return [ o - 1, o, o + 1 ];\n    },\n    else() {\n        /* 即使等待条件超时, 也可调用 forEach 方法. */\n        return [];\n    },\n}).forEach(x =&gt; console.log(x));\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "condition"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "wait(condition, limit, callback)",
              "type": "method",
              "name": "wait",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 5/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>condition</strong> { <a href=\"dataTypes#function\">(() =&gt; T)</a> | <a href=\"uiSelectorType#m-pickup\">PickupSelector</a> } - 结束等待条件</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<p><a href=\"#waitcondition-callback\">wait(condition, callback)</a> 增加条件检测限制.</p>\n<blockquote>\n<p>参阅: <a href=\"#waitcondition-limit\">wait(condition, limit)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "condition"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "wait(condition, limit, interval, callback)",
              "type": "method",
              "name": "wait",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 6/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>condition</strong> { <a href=\"dataTypes#function\">(() =&gt; T)</a> | <a href=\"uiSelectorType#m-pickup\">PickupSelector</a> } - 结束等待条件</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>interval</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测间隔</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<p><a href=\"#waitcondition-callback\">wait(condition, limit, callback)</a> 增加条件检测间隔.</p>\n<blockquote>\n<p>参阅: <a href=\"#waitcondition-limit-interval\">wait(condition, limit, interval)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "condition"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "interval"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] wait"
        },
        {
          "textRaw": "[m] waitForActivity",
          "name": "[m]_waitforactivity",
          "desc": "<p>等待指定名称的 Activity 出现 (前置).<br>此方法相当于 <code>wait(() =&gt; currentActivity() === activityName, ...args)</code>,<br>因此其所有重载方法的结构与 wait 一致.<br>为节约篇幅, 将仅列出方法签名等重要信息.</p>\n",
          "methods": [
            {
              "textRaw": "waitForActivity(activityName)",
              "type": "method",
              "name": "waitForActivity",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 1/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>activityName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标活动名称</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<blockquote>\n<p>参阅:<a href=\"#waitcondition\">wait(condition)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "activityName"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForActivity(activityName, limit)",
              "type": "method",
              "name": "waitForActivity",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 2/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>activityName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标活动名称</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<blockquote>\n<p>参阅:<a href=\"#waitcondition-limit\">wait(condition, limit)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "activityName"
                    },
                    {
                      "name": "limit"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForActivity(activityName, limit, interval)",
              "type": "method",
              "name": "waitForActivity",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 3/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>activityName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标活动名称</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>interval</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测间隔</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<blockquote>\n<p>参阅:<a href=\"#waitcondition-limit-interval\">wait(condition, limit, interval)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "activityName"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "interval"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForActivity(activityName, callback)",
              "type": "method",
              "name": "waitForActivity",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 4/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>activityName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标活动名称</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#waitcondition-callback\">wait(condition, callback)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "activityName"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForActivity(activityName, limit, callback)",
              "type": "method",
              "name": "waitForActivity",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 5/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>activityName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标活动名称</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#waitcondition-limit-callback\">wait(condition, limit, callback)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "activityName"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForActivity(activityName, limit, interval, callback)",
              "type": "method",
              "name": "waitForActivity",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 6/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>activityName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标活动名称</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>interval</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测间隔</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#waitcondition-limit-interval-callback\">wait(condition, limit, interval, callback)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "activityName"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "interval"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] waitForActivity"
        },
        {
          "textRaw": "[m] waitForPackage",
          "name": "[m]_waitforpackage",
          "desc": "<p>等待指定包名的应用出现 (前置).<br>此方法相当于 <code>wait(() =&gt; currentPackage() === packageName, ...args)</code>,<br>因此其所有重载方法的结构与 wait 一致.<br>为节约篇幅, 将仅列出方法签名等重要信息.</p>\n",
          "methods": [
            {
              "textRaw": "waitForPackage(packageName)",
              "type": "method",
              "name": "waitForPackage",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 1/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>packageName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标应用包名</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<blockquote>\n<p>参阅:<a href=\"#waitcondition\">wait(condition)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "packageName"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForPackage(packageName, limit)",
              "type": "method",
              "name": "waitForPackage",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 2/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>packageName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标应用包名</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<blockquote>\n<p>参阅:<a href=\"#waitcondition-limit\">wait(condition, limit)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "packageName"
                    },
                    {
                      "name": "limit"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForPackage(packageName, limit, interval)",
              "type": "method",
              "name": "waitForPackage",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 3/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>packageName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标应用包名</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>interval</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测间隔</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<blockquote>\n<p>参阅:<a href=\"#waitcondition-limit-interval\">wait(condition, limit, interval)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "packageName"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "interval"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForPackage(packageName, callback)",
              "type": "method",
              "name": "waitForPackage",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 4/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>packageName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标应用包名</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#waitcondition-callback\">wait(condition, callback)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "packageName"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForPackage(packageName, limit, callback)",
              "type": "method",
              "name": "waitForPackage",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 5/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>packageName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标应用包名</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#waitcondition-limit-callback\">wait(condition, limit, callback)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "packageName"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "waitForPackage(packageName, limit, interval, callback)",
              "type": "method",
              "name": "waitForPackage",
              "desc": "<p><strong><code>6.2.0</code></strong> <strong><code>Overload 6/6</code></strong> <strong><code>A11Y?</code></strong> <strong><code>Non-UI</code></strong></p>\n<ul>\n<li><strong>packageName</strong> { <a href=\"dataTypes#string\">string</a> } - 目标应用包名</li>\n<li><strong>limit</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测限制</li>\n<li><strong>interval</strong> { <a href=\"dataTypes#number\">number</a> } - 等待条件检测间隔</li>\n<li><strong>callback</strong> {{<ul>\n<li>then?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n<li>else?(result?: <a href=\"dataTypes#generic\">T</a>): <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n</li>\n<li>}} - 等待结束回调对象</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#generic\">R</a> extends <a href=\"dataTypes#void\">void</a> ? <a href=\"dataTypes#boolean\">boolean</a> : <a href=\"dataTypes#generic\">R</a> }</li>\n<li><ins><strong>template</strong></ins> <a href=\"dataTypes#generic\">T</a>, <a href=\"dataTypes#generic\">R</a></li>\n</ul>\n<blockquote>\n<p>参阅: <a href=\"#waitcondition-limit-interval-callback\">wait(condition, limit, interval, callback)</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "packageName"
                    },
                    {
                      "name": "limit"
                    },
                    {
                      "name": "interval"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] waitForPackage"
        },
        {
          "textRaw": "[m] exit",
          "name": "[m]_exit",
          "desc": "<p>停止脚本运行.</p>\n",
          "methods": [
            {
              "textRaw": "exit()",
              "type": "method",
              "name": "exit",
              "desc": "<p><strong><code>Overload 1/2</code></strong></p>\n<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>通过抛出 <code>ScriptInterruptedException</code> 异常实现脚本停止.<br>因此用 <code>try</code> 包裹 <code>exit()</code> 语句将会使脚本继续运行片刻:</p>\n<pre><code class=\"lang-js\">try {\n    log(&#39;exit now&#39;);\n    exit();\n    log(&quot;after&quot;); /* 控制台不会打印 &quot;after&quot;. */\n} catch (e) {\n    e.javaException instanceof ScriptInterruptedException; // true\n}\nwhile (true) log(&quot;hello&quot;); /* 控制台将打印一定数量的 &quot;hello&quot;. */\n</code></pre>\n<p>如果编写的脚本对 &quot;是否停止&quot; 的状态十分敏感,<br>即要求 exit() 之后的代码一定不被执行,<br>则可通过附加状态判断实现上述需求:</p>\n<pre><code class=\"lang-js\">if (!isStopped()) {\n    // 其他代码...\n}\n</code></pre>\n<p>因此上述示例如果加上状态判断, &quot;hello&quot; 将不会被打印:</p>\n<pre><code class=\"lang-js\">try {\n    log(&#39;exit now&#39;);\n    exit();\n} catch (_) {\n    // Ignored.\n}\nif (!isStopped()) {\n    while (true) {\n        /* 控制台不会打印 &quot;hello&quot;. */\n        log(&quot;hello&quot;);\n    }\n}\n</code></pre>\n<p>除了 <a href=\"#isstopped\">isStopped</a>, 还可通过 threads 或 engines 获取停止状态:</p>\n<pre><code class=\"lang-js\">/* threads. */\nif (!threads.currentThread().isInterrupted()) {\n    // 其他代码...\n}\n\n/* engines. */\nif (!engines.myEngine().isStopped()) {\n    // 其他代码...\n}\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "exit(e)",
              "type": "method",
              "name": "exit",
              "desc": "<p><strong><code>Overload 2/2</code></strong></p>\n<ul>\n<li><strong>e</strong> { <a href=\"exceptions.md#java\">JavaException</a> } - 异常参数</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>停止脚本运行并抛出异常参数指定的异常.</p>\n<p>此方法通常不会在脚本中使用.</p>\n<pre><code class=\"lang-js\">let arg = &#39;hello&#39;;\ntry {\n    if (typeof arg !== &quot;number&quot;) {\n        throw Error(&#39;arg 参数非 number 类型&#39;);\n    }\n} catch (e) {\n    exit(new java.lang.Throwable(e))\n}\n</code></pre>\n<p>需额外留意上述示例的异常参数使用了 Throwable 重新包装, 因为异常参数类型为 Java 的 Exception, 而非 JavaScript 的 Error.<br>关于异常相关的内容, 可参阅 <a href=\"exceptions\">异常</a> 章节.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "e"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] exit"
        },
        {
          "textRaw": "[m] stop",
          "name": "[m]_stop",
          "methods": [
            {
              "textRaw": "stop()",
              "type": "method",
              "name": "stop",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "<ins>**returns**</ins> { [void](dataTypes#void) } ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [void](dataTypes#void) "
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>停止脚本运行.</p>\n<p><a href=\"#exit\">exit()</a> 的别名方法.</p>\n<blockquote>\n<p>注: stop 方法不存在 <a href=\"#exite\">exit(e)</a> 对应的重载方法.</p>\n</blockquote>\n"
            }
          ],
          "type": "module",
          "displayName": "[m] stop"
        },
        {
          "textRaw": "[m] isStopped",
          "name": "[m]_isstopped",
          "methods": [
            {
              "textRaw": "isStopped()",
              "type": "method",
              "name": "isStopped",
              "desc": "<p><strong><code>DEPRECATED</code></strong></p>\n<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<p>检测脚本主线程是否已中断.</p>\n<p>即 <code>runtime.isInterrupted()</code>.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] isStopped"
        },
        {
          "textRaw": "[m] isShuttingDown",
          "name": "[m]_isshuttingdown",
          "methods": [
            {
              "textRaw": "isShuttingDown()",
              "type": "method",
              "name": "isShuttingDown",
              "desc": "<p><strong><code>DEPRECATED</code></strong></p>\n<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<p>检测脚本主线程是否已中断.</p>\n<p>因方法名称易造成歧义及混淆, 因此被弃用, 建议使用 <a href=\"#m-isstopped\">isStopped()</a> 或 <code>runtime.isInterrupted()</code> 替代.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] isShuttingDown"
        },
        {
          "textRaw": "[m] isRunning",
          "name": "[m]_isrunning",
          "methods": [
            {
              "textRaw": "isRunning()",
              "type": "method",
              "name": "isRunning",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "<ins>**returns**</ins> { [boolean](dataTypes#boolean) } ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [boolean](dataTypes#boolean) "
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>检测脚本主线程是否未被中断.</p>\n<p>即 <code>!runtime.isInterrupted()</code>.</p>\n"
            }
          ],
          "type": "module",
          "displayName": "[m] isRunning"
        },
        {
          "textRaw": "[m] notStopped",
          "name": "[m]_notstopped",
          "methods": [
            {
              "textRaw": "notStopped()",
              "type": "method",
              "name": "notStopped",
              "desc": "<p><strong><code>DEPRECATED</code></strong></p>\n<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#boolean\">boolean</a> }</li>\n</ul>\n<p>检测脚本主线程是否未被中断.</p>\n<p>因方法名称易造成歧义及混淆, 因此被弃用, 建议使用 <a href=\"#m-isrunning\">isRunning()</a> 或 <code>!runtime.isInterrupted()</code> 替代.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] notStopped"
        },
        {
          "textRaw": "[m] requiresApi",
          "name": "[m]_requiresapi",
          "methods": [
            {
              "textRaw": "requiresApi(api)",
              "type": "method",
              "name": "requiresApi",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "**api** { [number](dataTypes#number) } - 安卓 API 级别 ",
                      "name": "**api**",
                      "type": " [number](dataTypes#number) ",
                      "desc": "安卓 API 级别"
                    },
                    {
                      "textRaw": "<ins>**returns**</ins> { [void](dataTypes#void) } ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [void](dataTypes#void) "
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "api"
                    }
                  ]
                }
              ],
              "desc": "<p>脚本运行的最低 API 级别要求.</p>\n<p>例如要求脚本运行不低于 <a href=\"apiLevel\">Android API 30 (11) [R]</a>:</p>\n<pre><code class=\"lang-js\">requiresApi(30);\nrequiresApi(util.versionCodes.R.apiLevel); /* 同上. */\nrequiresApi(android.os.Build.VERSION_CODES.R); /* 同上. */\n</code></pre>\n<p>若 API 级别不符合要求, 脚本抛出异常并停止继续执行.</p>\n<blockquote>\n<p>参阅:</p>\n<ul>\n<li><a href=\"apiLevel\">Android API Level - 安卓 API 级别</a></li>\n<li><a href=\"util#versioncodes\">util.versionCodes</a></li>\n</ul>\n</blockquote>\n"
            }
          ],
          "type": "module",
          "displayName": "[m] requiresApi"
        },
        {
          "textRaw": "[m] requiresAutojsVersion",
          "name": "[m]_requiresautojsversion",
          "methods": [
            {
              "textRaw": "requiresAutojsVersion(versionName)",
              "type": "method",
              "name": "requiresAutojsVersion",
              "desc": "<p><strong><code>Overload 1/2</code></strong></p>\n<ul>\n<li><strong>versionName</strong> { <a href=\"dataTypes#string\">string</a> } - AutoJs6 版本名称</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>脚本运行的最低 AutoJs6 版本要求 (版本名称).</p>\n<pre><code class=\"lang-js\">requiresAutojsVersion(&quot;6.2.0&quot;);\n</code></pre>\n<p>可通过 <code>autojs.versionName</code> 查看 AutoJs6 版本名称.</p>\n<blockquote>\n<p>参阅: <a href=\"autojs#versionname\">autojs.versionName</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "versionName"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "requiresAutojsVersion(versionCode)",
              "type": "method",
              "name": "requiresAutojsVersion",
              "desc": "<p><strong><code>Overload 2/2</code></strong></p>\n<ul>\n<li><strong>versionCode</strong> { <a href=\"dataTypes#number\">number</a> } - AutoJs6 版本号</li>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#void\">void</a> }</li>\n</ul>\n<p>脚本运行的最低 AutoJs6 版本要求 (版本号).</p>\n<pre><code class=\"lang-js\">requiresAutojsVersion(1024);\n</code></pre>\n<p>可通过 <code>autojs.versionCode</code> 查看 AutoJs6 版本号.</p>\n<blockquote>\n<p>参阅: <a href=\"autojs#versioncode\">autojs.versionCode</a></p>\n</blockquote>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "versionCode"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] requiresAutojsVersion"
        },
        {
          "textRaw": "[m] importPackage",
          "name": "[m]_importpackage",
          "methods": [
            {
              "textRaw": "importPackage(...pkg)",
              "type": "method",
              "name": "importPackage",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "**pkg** { ...( [string](dataTypes#string) | [object](dataTypes#object) ) } - 需导入的 Java 包 ",
                      "name": "**pkg**",
                      "type": " ...( [string](dataTypes#string) | [object](dataTypes#object) ) ",
                      "desc": "需导入的 Java 包"
                    },
                    {
                      "textRaw": "<ins>**returns**</ins> { [void](dataTypes#void) } ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [void](dataTypes#void) "
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "...pkg"
                    }
                  ]
                }
              ],
              "desc": "<pre><code class=\"lang-js\">/* 导入一个 Java 包. */\n\nimportPackage(java.lang);\nimportPackage(&#39;java.lang&#39;); /* 同上. */\n\n/* 导入多个 Java 包. */\n\nimportPackage(java.io);\nimportPackage(java.lang);\nimportPackage(java.util);\n\nimportPackage(java.io, java.lang, java.util); /* 同上. */\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"scriptingJava#访问-Java-包和类\">访问 Java 包和类</a></p>\n</blockquote>\n"
            }
          ],
          "type": "module",
          "displayName": "[m] importPackage"
        },
        {
          "textRaw": "[m] importClass",
          "name": "[m]_importclass",
          "methods": [
            {
              "textRaw": "importClass(...cls)",
              "type": "method",
              "name": "importClass",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "**cls** { ...( [string](dataTypes#string) | [object](dataTypes#object) ) } - 需导入的 Java 类 ",
                      "name": "**cls**",
                      "type": " ...( [string](dataTypes#string) | [object](dataTypes#object) ) ",
                      "desc": "需导入的 Java 类"
                    },
                    {
                      "textRaw": "<ins>**returns**</ins> { [void](dataTypes#void) } ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [void](dataTypes#void) "
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "...cls"
                    }
                  ]
                }
              ],
              "desc": "<pre><code class=\"lang-js\">/* 导入一个 Java 类. */\n\nimportClass(java.lang.Integer);\nimportClass(&#39;java.lang.Integer&#39;); /* 同上. */\n\n/* 导入多个 Java 类. */\n\nimportClass(java.io.File);\nimportClass(java.lang.Integer);\nimportClass(java.util.HashMap);\n\nimportClass(\n    java.io.File,\n    java.lang.Integer,\n    java.util.HashMap,\n); /* 同上. */\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"scriptingJava#访问-Java-包和类\">访问 Java 包和类</a></p>\n</blockquote>\n"
            }
          ],
          "type": "module",
          "displayName": "[m] importClass"
        },
        {
          "textRaw": "[m] currentPackage",
          "name": "[m]_currentpackage",
          "methods": [
            {
              "textRaw": "currentPackage()",
              "type": "method",
              "name": "currentPackage",
              "desc": "<p><strong><code>A11Y</code></strong></p>\n<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#string\">string</a> }</li>\n</ul>\n<p>获取最近一次监测到的应用包名, 并视为当前正在运行的应用包名.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] currentPackage"
        },
        {
          "textRaw": "[m] currentActivity",
          "name": "[m]_currentactivity",
          "methods": [
            {
              "textRaw": "currentActivity()",
              "type": "method",
              "name": "currentActivity",
              "desc": "<p><strong><code>A11Y</code></strong></p>\n<ul>\n<li><ins><strong>returns</strong></ins> { <a href=\"dataTypes#string\">string</a> }</li>\n</ul>\n<p>获取最近一次监测到的活动名称, 并视为当前正在运行的活动名称.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] currentActivity"
        },
        {
          "textRaw": "[m] setClip",
          "name": "[m]_setclip",
          "methods": [
            {
              "textRaw": "setClip(text)",
              "type": "method",
              "name": "setClip",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "**text** { [string](dataTypes#string) } - 剪贴板内容 ",
                      "name": "**text**",
                      "type": " [string](dataTypes#string) ",
                      "desc": "剪贴板内容"
                    },
                    {
                      "textRaw": "<ins>**returns**</ins> { [void](dataTypes#void) } ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [void](dataTypes#void) "
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "text"
                    }
                  ]
                }
              ],
              "desc": "<p>设置系统剪贴板内容.</p>\n<blockquote>\n<p>参阅: <a href=\"#m-getclip\">getClip</a></p>\n</blockquote>\n"
            }
          ],
          "type": "module",
          "displayName": "[m] setClip"
        },
        {
          "textRaw": "[m] getClip",
          "name": "[m]_getclip",
          "methods": [
            {
              "textRaw": "getClip()",
              "type": "method",
              "name": "getClip",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "<ins>**returns**</ins> { [string](dataTypes#string) } - 系统剪贴板内容 ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [string](dataTypes#string) ",
                      "desc": "系统剪贴板内容"
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>需额外留意, 自 <a href=\"apiLevel\">Android API 29 (10) [Q]</a> 起, 剪贴板数据的访问将受到限制:</p>\n<p>为更好地保护用户隐私权, 除默认输入法及当前获取焦点的前置应用外, 均无法访问剪贴板数据.</p>\n<pre><code class=\"lang-js\">setClip(&quot;test&quot;);\n\n/* 安卓 10 以下: 打印 &quot;test&quot;. */\n/* 安卓 10 及以上: 若 AutoJs6 前置, 打印 &quot;test&quot;, 否则打印空字符串. */\nconsole.log(getClip());\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"#m-setclip\">setClip</a></p>\n</blockquote>\n<blockquote>\n<p>参阅: <a href=\"https://developer.android.com/about/versions/10/privacy/changes#clipboard-data\">Android Docs</a></p>\n</blockquote>\n"
            }
          ],
          "type": "module",
          "displayName": "[m] getClip"
        },
        {
          "textRaw": "[m] selector",
          "name": "[m]_selector",
          "methods": [
            {
              "textRaw": "selector()",
              "type": "method",
              "name": "selector",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "<ins>**returns**</ins> { [UiSelector](uiSelectorType) } ",
                      "name": "<ins>**returns**</ins>",
                      "type": " [UiSelector](uiSelectorType) "
                    }
                  ]
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>构建一个 &quot;空&quot; <a href=\"uiSelectorType\">选择器</a>.\n<!-- [end-include:global.md] --></p>\n<!-- [start-include:automator.md] -->\n"
            }
          ],
          "type": "module",
          "displayName": "[m] selector"
        }
      ],
      "type": "module",
      "displayName": "全局对象 (Global)"
    },
    {
      "textRaw": "自动化 (Automator)",
      "name": "自动化_(automator)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n",
      "modules": [
        {
          "textRaw": "简易自动化 (SimpleActionAutomator)",
          "name": "简易自动化_(simpleactionautomator)",
          "desc": "<p>待补充...</p>\n",
          "type": "module",
          "displayName": "简易自动化 (SimpleActionAutomator)"
        },
        {
          "textRaw": "高权限自动化 (RootAutomator)",
          "name": "高权限自动化_(rootautomator)",
          "desc": "<p>待补充...</p>\n",
          "type": "module",
          "displayName": "高权限自动化 (RootAutomator)"
        },
        {
          "textRaw": "自动化配置 (AutomatorConfiguration)",
          "name": "自动化配置_(automatorconfiguration)",
          "desc": "<p>待补充...</p>\n",
          "type": "module",
          "displayName": "自动化配置 (AutomatorConfiguration)"
        },
        {
          "textRaw": "选择器 (UiSelector)",
          "name": "选择器_(uiselector)",
          "desc": "<p>UiSelector (选择器), 亦可看作是 <a href=\"uiObjectType\">控件节点</a> 的条件筛选器, 用于通过附加不同的条件, 筛选出一个或一组活动窗口中的 <code>控件节点</code>, 并做进一步处理, 如 [ 执行 <a href=\"uiObjectActionsType\">控件行为</a> (点击, 长按, 设置文本等) / 判断位置 / 获取文本内容 / 获取控件特定状态 / 在 <a href=\"glossaries#控件层级\">控件层级</a> 中进行 <a href=\"uiObjectType.md#m-compass\">罗盘</a> 导航 ] 等.</p>\n<p>详情参阅 <a href=\"uiSelectorType\">选择器 (UiSelector)</a> 章节.</p>\n",
          "type": "module",
          "displayName": "选择器 (UiSelector)"
        },
        {
          "textRaw": "控件节点 (UiObject)",
          "name": "控件节点_(uiobject)",
          "desc": "<p>UiObject 通常被称为 [ 控件 / 节点 / 控件节点 ], 可看做是一个通过安卓无障碍服务包装的 <a href=\"https://developer.android.com/reference/android/view/accessibility/AccessibilityNodeInfo\">AccessibilityNodeInfo</a> 对象, 代表一个当前活动窗口中的节点, 通过此节点可收集控件信息或执行控件行为, 进而实现一系列自动化操作.</p>\n<p>详情参阅 <a href=\"uiObjectType\">控件节点 (UiObject)</a> 章节.</p>\n",
          "type": "module",
          "displayName": "控件节点 (UiObject)"
        },
        {
          "textRaw": "控件集合 (UiObjectCollection)",
          "name": "控件集合_(uiobjectcollection)",
          "desc": "<p>UiObjectCollection 代表 <a href=\"uiObjectType\">控件节点 (UiObject)</a> 的对象集合.</p>\n<p>详情参阅 <a href=\"uiObjectCollectionType\">控件集合 (UiObjectCollection)</a> 章节.</p>\n",
          "type": "module",
          "displayName": "控件集合 (UiObjectCollection)"
        },
        {
          "textRaw": "控件节点行为 (UiObjectActions)",
          "name": "控件节点行为_(uiobjectactions)",
          "desc": "<p>UiObjectActions 是一个 Java 接口, 代表 <a href=\"uiObjectType\">控件节点 (UiObject)</a> 的行为集合.</p>\n<p>详情参阅 <a href=\"uiObjectActionsType\">控件节点行为 (UiObjectActions)</a> 章节.</p>\n<hr>\n",
          "type": "module",
          "displayName": "控件节点行为 (UiObjectActions)"
        }
      ],
      "type": "module",
      "displayName": "自动化 (Automator)"
    },
    {
      "textRaw": "基于坐标的触摸模拟",
      "name": "基于坐标的触摸模拟",
      "desc": "<p>本章节介绍了一些使用坐标进行点击、滑动的函数. 这些函数有的需要安卓7.0以上, 有的需要root权限.</p>\n<p>要获取要点击的位置的坐标, 可以在开发者选项中开启&quot;指针位置&quot;.</p>\n<p>基于坐标的脚本通常会有分辨率的问题, 这时可以通过<code>setScreenMetrics()</code>函数来进行自动坐标放缩. 这个函数会影响本章节的所有点击、长按、滑动等函数. 通过设定脚本设计时的分辨率, 使得脚本在其他分辨率下自动放缩坐标.</p>\n<p>控件和坐标也可以相互结合. 一些控件是无法点击的(clickable为false), 无法通过<code>.click()</code>函数来点击, 这时如果安卓版本在7.0以上或者有root权限, 就可以通过以下方式来点击：</p>\n<pre><code>//获取这个控件\nvar widget = id(&quot;xxx&quot;).findOne();\n//获取其中心位置并点击\nclick(widget.bounds().centerX(), widget.bounds().centerY());\n//如果用root权限则用Tap\n</code></pre>",
      "methods": [
        {
          "textRaw": "setScreenMetrics(width, height)",
          "type": "method",
          "name": "setScreenMetrics",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "width {number} 屏幕宽度, 单位像素 ",
                  "name": "width",
                  "type": "number",
                  "desc": "屏幕宽度, 单位像素"
                },
                {
                  "textRaw": "height {number} 屏幕高度, 单位像素 ",
                  "name": "height",
                  "type": "number",
                  "desc": "屏幕高度, 单位像素"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "width"
                },
                {
                  "name": "height"
                }
              ]
            }
          ],
          "desc": "<p>设置脚本坐标点击所适合的屏幕宽高. 如果脚本运行时, 屏幕宽度不一致会自动放缩坐标.</p>\n<p>例如在1920*1080的设备中, 某个操作的代码为</p>\n<pre><code>setScreenMetrics(1080, 1920);\nclick(800, 200);\nlongClick(300, 500);\n</code></pre><p>那么在其他设备上AutoJs会自动放缩坐标以便脚本仍然有效. 例如在540 * 960的屏幕中<code>click(800, 200)</code>实际上会点击位置(400, 100).</p>\n"
        }
      ],
      "type": "module",
      "displayName": "基于坐标的触摸模拟"
    },
    {
      "textRaw": "RootAutomator",
      "name": "rootautomator",
      "desc": "<p>RootAutomator是一个使用root权限来模拟触摸的对象, 用它可以完成触摸与多点触摸, 并且这些动作的执行没有延迟.</p>\n<p>一个脚本中最好只存在一个RootAutomator, 并且保证脚本结束退出他. 可以在exit事件中退出RootAutomator, 例如：</p>\n<pre><code>var ra = new RootAutomator();\nevents.on(&#39;exit&#39;, function(){\n  ra.exit();\n});\n//执行一些点击操作\n...\n\n</code></pre><p><strong>注意以下命令需要root权限</strong></p>\n",
      "methods": [
        {
          "textRaw": "RootAutomator.tap(x, y[, id])",
          "type": "method",
          "name": "tap",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "横坐标"
                },
                {
                  "textRaw": "`y` {number} 纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "纵坐标"
                },
                {
                  "textRaw": "`id` {number} 多点触摸id, 可选, 默认为1, 可以通过setDefaultId指定. ",
                  "name": "id",
                  "type": "number",
                  "desc": "多点触摸id, 可选, 默认为1, 可以通过setDefaultId指定.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "id",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>点击位置(x, y). 其中id是一个整数值, 用于区分多点触摸, 不同的id表示不同的&quot;手指&quot;, 例如：</p>\n<pre><code>var ra = new RootAutomator();\n//让&quot;手指1&quot;点击位置(100, 100)\nra.tap(100, 100, 1);\n//让&quot;手指2&quot;点击位置(200, 200);\nra.tap(200, 200, 2);\nra.exit();\n</code></pre><p>如果不需要多点触摸, 则不需要id这个参数.\n多点触摸通常用于手势或游戏操作, 例如模拟双指捏合、双指上滑等.</p>\n<p>某些情况下可能存在tap点击无反应的情况, 这时可以用<code>RootAutomator.press()</code>函数代替.</p>\n"
        },
        {
          "textRaw": "RootAutomator.swipe(x1, x2, y1, y2[, duration, id])",
          "type": "method",
          "name": "swipe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x1` {number} 滑动起点横坐标 ",
                  "name": "x1",
                  "type": "number",
                  "desc": "滑动起点横坐标"
                },
                {
                  "textRaw": "`y1` {number} 滑动起点纵坐标 ",
                  "name": "y1",
                  "type": "number",
                  "desc": "滑动起点纵坐标"
                },
                {
                  "textRaw": "`x2` {number} 滑动终点横坐标 ",
                  "name": "x2",
                  "type": "number",
                  "desc": "滑动终点横坐标"
                },
                {
                  "textRaw": "`y2` {number} 滑动终点纵坐标 ",
                  "name": "y2",
                  "type": "number",
                  "desc": "滑动终点纵坐标"
                },
                {
                  "textRaw": "`duration` {number} 滑动时长, 单位毫秒, 默认值为300 ",
                  "name": "duration",
                  "type": "number",
                  "desc": "滑动时长, 单位毫秒, 默认值为300",
                  "optional": true
                },
                {
                  "textRaw": "`id` {number} 多点触摸id, 可选, 默认为1 ",
                  "name": "id",
                  "type": "number",
                  "desc": "多点触摸id, 可选, 默认为1",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x1"
                },
                {
                  "name": "x2"
                },
                {
                  "name": "y1"
                },
                {
                  "name": "y2"
                },
                {
                  "name": "duration",
                  "optional": true
                },
                {
                  "name": "id",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>模拟一次从(x1, y1)到(x2, y2)的时间为duration毫秒的滑动.</p>\n"
        },
        {
          "textRaw": "RootAutomator.press(x, y, duration[, id])",
          "type": "method",
          "name": "press",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "横坐标"
                },
                {
                  "textRaw": "`y` {number} 纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "纵坐标"
                },
                {
                  "textRaw": "`duration` {number} 按下时长 ",
                  "name": "duration",
                  "type": "number",
                  "desc": "按下时长"
                },
                {
                  "textRaw": "`id` {number} 多点触摸id, 可选, 默认为1 ",
                  "name": "id",
                  "type": "number",
                  "desc": "多点触摸id, 可选, 默认为1",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "duration"
                },
                {
                  "name": "id",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>模拟按下位置(x, y), 时长为duration毫秒.</p>\n"
        },
        {
          "textRaw": "RootAutomator.longPress(x, y[\\, id\\])",
          "type": "method",
          "name": "longPress",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "横坐标"
                },
                {
                  "textRaw": "`y` {number} 纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "纵坐标"
                },
                {
                  "textRaw": "`duration` {number} 按下时长 ",
                  "name": "duration",
                  "type": "number",
                  "desc": "按下时长"
                },
                {
                  "textRaw": "`id` {number} 多点触摸id, 可选, 默认为1 ",
                  "name": "id",
                  "type": "number",
                  "desc": "多点触摸id, 可选, 默认为1"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y[\\"
                },
                {
                  "name": "id\\"
                }
              ]
            }
          ],
          "desc": "<p>模拟长按位置(x, y).</p>\n<p>以上为简单模拟触摸操作的函数. 如果要模拟一些复杂的手势, 需要更底层的函数.</p>\n"
        },
        {
          "textRaw": "RootAutomator.touchDown(x, y[, id])",
          "type": "method",
          "name": "touchDown",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "横坐标"
                },
                {
                  "textRaw": "`y` {number} 纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "纵坐标"
                },
                {
                  "textRaw": "`id` {number} 多点触摸id, 可选, 默认为1 ",
                  "name": "id",
                  "type": "number",
                  "desc": "多点触摸id, 可选, 默认为1",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "id",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>模拟手指按下位置(x, y).</p>\n"
        },
        {
          "textRaw": "RootAutomator.touchMove(x, y[, id])",
          "type": "method",
          "name": "touchMove",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "横坐标"
                },
                {
                  "textRaw": "`y` {number} 纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "纵坐标"
                },
                {
                  "textRaw": "`id` {number} 多点触摸id, 可选, 默认为1 ",
                  "name": "id",
                  "type": "number",
                  "desc": "多点触摸id, 可选, 默认为1",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "id",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>模拟移动手指到位置(x, y).</p>\n"
        },
        {
          "textRaw": "RootAutomator.touchUp([id])",
          "type": "method",
          "name": "touchUp",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`id` {number} 多点触摸id, 可选, 默认为1 ",
                  "name": "id",
                  "type": "number",
                  "desc": "多点触摸id, 可选, 默认为1",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "id",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>模拟手指弹起.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "RootAutomator"
    },
    {
      "textRaw": "使用root权限点击和滑动的简单命令",
      "name": "使用root权限点击和滑动的简单命令",
      "desc": "<p>注意：本章节的函数在后续版本很可能有改动！请勿过分依赖本章节函数的副作用. 推荐使用<code>RootAutomator</code>代替本章节的触摸函数.</p>\n<p>以下函数均需要root权限, 可以实现任意位置的点击、滑动等.</p>\n<ul>\n<li>这些函数通常首字母大写以表示其特殊的权限.</li>\n<li>这些函数均不返回任何值.</li>\n<li>并且, 这些函数的执行是异步的、非阻塞的, 在不同机型上所用的时间不同. 脚本不会等待动作执行完成才继续执行. 因此最好在每个函数之后加上适当的sleep来达到期望的效果.</li>\n</ul>\n<p>例如:</p>\n<pre><code>Tap(100, 100);\nsleep(500);\n</code></pre><p>注意, 动作的执行可能无法被停止, 例如：</p>\n<pre><code>for(var i = 0; i &lt; 100; i++){\n  Tap(100, 100);\n}\n</code></pre><p>这段代码执行后可能会出现在任务管理中停止脚本后点击仍然继续的情况.\n因此, 强烈建议在每个动作后加上延时：</p>\n<pre><code>for(var i = 0; i &lt; 100; i++){\n  Tap(100, 100);\n  sleep(500);\n}\n</code></pre>",
      "methods": [
        {
          "textRaw": "Tap(x, y)",
          "type": "method",
          "name": "Tap",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "x, y {number} 要点击的坐标. ",
                  "name": "x,",
                  "desc": "y {number} 要点击的坐标."
                },
                {
                  "name": "y"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ],
          "desc": "<p>点击位置(x, y), 您可以通过&quot;开发者选项&quot;开启指针位置来确定点击坐标.</p>\n"
        },
        {
          "textRaw": "Swipe(x1, y1, x2, y2, \\[duration\\])",
          "type": "method",
          "name": "Swipe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "x1, y1 {number} 滑动起点的坐标 ",
                  "name": "x1,",
                  "desc": "y1 {number} 滑动起点的坐标"
                },
                {
                  "textRaw": "x2, y2 {number} 滑动终点的坐标 ",
                  "name": "x2,",
                  "desc": "y2 {number} 滑动终点的坐标"
                },
                {
                  "textRaw": "duration {number} 滑动动作所用的时间 ",
                  "name": "duration",
                  "type": "number",
                  "desc": "滑动动作所用的时间"
                },
                {
                  "name": "y2"
                },
                {
                  "name": "\\[duration\\"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x1"
                },
                {
                  "name": "y1"
                },
                {
                  "name": "x2"
                },
                {
                  "name": "y2"
                },
                {
                  "name": "\\[duration\\"
                }
              ]
            }
          ],
          "desc": "<p>滑动. 从(x1, y1)位置滑动到(x2, y2)位置.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "使用root权限点击和滑动的简单命令"
    },
    {
      "textRaw": "基于控件的操作",
      "name": "基于控件的操作",
      "desc": "<p>基于控件的操作指的是选择屏幕上的控件, 获取其信息或对其进行操作. 对于一般软件而言, 基于控件的操作对不同机型有很好的兼容性；但是对于游戏而言, 由于游戏界面并不是由控件构成, 无法采用本章节的方法, 也无法使用本章节的函数. 有关游戏脚本的编写, 请参考《基于坐标的操作》.</p>\n<p>基于控件的操作依赖于无障碍服务, 因此最好在脚本开头使用<code>auto()</code>函数来确保无障碍服务已经启用. 如果运行到某个需要权限的语句无障碍服务并没启动, 则会抛出异常并跳转到无障碍服务界面. 这样的用户体验并不好, 因为需要重新运行脚本, 后续会加入等待无障碍服务启动并让脚本继续运行的函数.</p>\n<p>您也可以在脚本开头使用<code>&quot;auto&quot;;</code>表示这个脚本需要无障碍服务, 但是不推荐这种做法, 因为这个标记必须在脚本的最开头(前面不能有注释或其他语句、空格等), 我们推荐使用<code>auto()</code>函数来确保无障碍服务已启用.</p>\n",
      "methods": [
        {
          "textRaw": "auto([mode])",
          "type": "method",
          "name": "auto",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`mode` {string} 模式 ",
                  "name": "mode",
                  "type": "string",
                  "desc": "模式",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "mode",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>检查无障碍服务是否已经启用, 如果没有启用则抛出异常并跳转到无障碍服务启用界面；同时设置无障碍模式为mode. mode的可选值为：</p>\n<ul>\n<li><code>fast</code> 快速模式. 该模式下会启用控件缓存, 从而选择器获取屏幕控件更快. 对于需要快速的控件操作的脚本可以使用该模式, 一般脚本则没有必要使用该函数.</li>\n<li><code>normal</code> 正常模式, 默认.</li>\n</ul>\n<p>如果不加mode参数, 则为正常模式.</p>\n<p>建议使用<code>auto.waitFor()</code>和<code>auto.setMode()</code>代替该函数, 因为<code>auto()</code>函数如果无障碍服务未启动会停止脚本；而<code>auto.waitFor()</code>则会在在无障碍服务启动后继续运行.</p>\n<p>示例：</p>\n<pre><code>auto(&quot;fast&quot;);\n</code></pre><p>示例2：</p>\n<pre><code>auto();\n</code></pre>"
        },
        {
          "textRaw": "auto.waitFor()",
          "type": "method",
          "name": "waitFor",
          "desc": "<p>检查无障碍服务是否已经启用, 如果没有启用则跳转到无障碍服务启用界面, 并等待无障碍服务启动；当无障碍服务启动后脚本会继续运行.</p>\n<p>因为该函数是阻塞的, 因此除非是有协程特性, 否则不能在ui模式下运行该函数, 建议在ui模式下使用<code>auto()</code>函数.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "auto.setMode(mode)",
          "type": "method",
          "name": "setMode",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`mode` {string} 模式 ",
                  "name": "mode",
                  "type": "string",
                  "desc": "模式"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "mode"
                }
              ]
            }
          ],
          "desc": "<p>设置无障碍模式为mode. mode的可选值为：</p>\n<ul>\n<li><code>fast</code> 快速模式. 该模式下会启用控件缓存, 从而选择器获取屏幕控件更快. 对于需要快速的控件查看和操作的脚本可以使用该模式, 一般脚本则没有必要使用该函数.</li>\n<li><code>normal</code> 正常模式, 默认.</li>\n</ul>\n"
        },
        {
          "textRaw": "auto.setFlags(flags)",
          "type": "method",
          "name": "setFlags",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>flags</code> {string} | {Array} 一些标志, 来启用和禁用某些特性, 包括：<ul>\n<li><code>findOnUiThread</code> 使用该特性后, 选择器搜索时会在主进程进行. 该特性用于解决线程安全问题导致的次生问题, 不过目前貌似已知问题并不是线程安全问题.</li>\n<li><code>useUsageStats</code> 使用该特性后, 将会以&quot;使用情况统计&quot;服务的结果来检测当前正在运行的应用包名（需要授予&quot;查看使用情况统计&quot;权限). 如果觉得currentPackage()返回的结果不太准确, 可以尝试该特性.</li>\n<li><code>useShell</code> 使用该特性后, 将使用shell命令获取当前正在运行的应用的包名、活动名称, 但是需要root权限.</li>\n</ul>\n</li>\n</ul>\n<p>启用有关automator的一些特性. 例如：</p>\n<pre><code>auto.setFlags([&quot;findOnUiThread&quot;, &quot;useShell&quot;]);\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "flags"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "auto.setWindowFilter(filter)",
          "type": "method",
          "name": "setWindowFilter",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>filter</code> {Function} 参数为窗口(<a href=\"https://developer.android.com/reference/android/view/accessibility/AccessibilityWindowInfo/\">AccessibilityWindowInfo</a>), 返回值为Boolean的函数.</li>\n</ul>\n<p>设置窗口过滤器. 这个过滤器可以决定哪些窗口是目标窗口, 并影响选择器的搜索. 例如, 如果想要选择器在所有窗口（包括状态栏、输入法等）中搜索, 只需要使用以下代码：</p>\n<pre><code>auto.setWindowFilter(function(window){\n    //不管是如何窗口, 都返回true, 表示在该窗口中搜索\n    return true;\n});\n</code></pre><p>又例如, 当前使用了分屏功能, 屏幕上有Auto.js和QQ两个应用, 但我们只想选择器对QQ界面进行搜索, 则：</p>\n<pre><code>auto.setWindowFilter(function(window){\n    // 对于应用窗口, 他的title属性就是应用的名称, 因此可以通过title属性来判断一个应用\n    return window.title == &quot;QQ&quot;;\n});\n</code></pre><p>选择器默认是在当前活跃的窗口中搜索, 不会搜索诸如悬浮窗、状态栏之类的, 使用WindowFilter则可以控制搜索的窗口.</p>\n<p>需要注意的是, 如果WindowFilter返回的结果均为false, 则选择器的搜索结果将为空.</p>\n<p>另外setWindowFilter函数也会影响<code>auto.windowRoots</code>的结果.</p>\n<p>该函数需要Android 5.0以上才有效.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filter"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "auto.service",
          "name": "service",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/accessibilityservice/AccessibilityService/\">AccessibilityService</a></li>\n</ul>\n<p>获取无障碍服务. 如果无障碍服务没有启动, 则返回<code>null</code>.</p>\n<p>参见<a href=\"https://developer.android.com/reference/android/accessibilityservice/AccessibilityService/\">AccessibilityService</a>.</p>\n"
        },
        {
          "textRaw": "auto.windows",
          "name": "windows",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li>{Array}</li>\n</ul>\n<p>当前所有窗口(<a href=\"https://developer.android.com/reference/android/view/accessibility/AccessibilityWindowInfo/\">AccessibilityWindowInfo</a>)的数组, 可能包括状态栏、输入法、当前应用窗口, 弹出窗口、悬浮窗、分屏应用窗口等. 可以分别获取每个窗口的布局信息.</p>\n<p>该函数需要Android 5.0以上才能运行.</p>\n"
        },
        {
          "textRaw": "auto.root",
          "name": "root",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li>{UiObject}</li>\n</ul>\n<p>当前窗口的布局根元素. 如果无障碍服务未启动或者WindowFilter均返回false, 则会返回<code>null</code>.</p>\n<p>如果不设置windowFilter, 则当前窗口即为活跃的窗口（获取到焦点、正在触摸的窗口）；如果设置了windowFilter, 则获取的是过滤的窗口中的第一个窗口.</p>\n<p>如果系统是Android5.0以下, 则始终返回当前活跃的窗口的布局根元素.</p>\n"
        },
        {
          "textRaw": "auto.rootInActiveWindow",
          "name": "rootInActiveWindow",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li>{UiObject}</li>\n</ul>\n<p>当前活跃的窗口（获取到焦点、正在触摸的窗口）的布局根元素. 如果无障碍服务未启动则为<code>null</code>.</p>\n"
        },
        {
          "textRaw": "auto.windowRoots",
          "name": "windowRoots",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li>{Array}</li>\n</ul>\n<p>返回当前被WindowFilter过滤的窗口的布局根元素组成的数组.</p>\n<p>如果系统是Android5.0以下, 则始终返回当前活跃的窗口的布局根元素的数组.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "基于控件的操作"
    },
    {
      "textRaw": "SimpleActionAutomator",
      "name": "simpleactionautomator",
      "desc": "<p>SimpleActionAutomator提供了一些模拟简单操作的函数, 例如点击文字、模拟按键等. 这些函数可以直接作为全局函数使用.</p>\n",
      "methods": [
        {
          "textRaw": "click(text[, i])",
          "type": "method",
          "name": "click",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`text` {string} 要点击的文本 ",
                  "name": "text",
                  "type": "string",
                  "desc": "要点击的文本"
                },
                {
                  "textRaw": "`i` {number} 如果相同的文本在屏幕中出现多次, 则i表示要点击第几个文本, i从0开始计算 ",
                  "name": "i",
                  "type": "number",
                  "desc": "如果相同的文本在屏幕中出现多次, 则i表示要点击第几个文本, i从0开始计算",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "text"
                },
                {
                  "name": "i",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>返回是否点击成功. 当屏幕中并未包含该文本, 或者该文本所在区域不能点击时返回false, 否则返回true.</p>\n<p>该函数可以点击大部分包含文字的按钮. 例如微信主界面下方的&quot;微信&quot;, &quot;联系人&quot;, &quot;发现&quot;, &quot;我&quot;的按钮.<br>通常与while同时使用以便点击按钮直至成功. 例如:</p>\n<pre><code>while(!click(&quot;扫一扫&quot;));\n</code></pre><p>当不指定参数i时则会尝试点击屏幕上出现的所有文字text并返回是否全部点击成功.</p>\n<p>i是从0开始计算的, 也就是, <code>click(&quot;啦啦啦&quot;, 0)</code>表示点击屏幕上第一个&quot;啦啦啦&quot;, <code>click(&quot;啦啦啦&quot;, 1)</code>表示点击屏幕上第二个&quot;啦啦啦&quot;.</p>\n<blockquote>\n<p>文本所在区域指的是, 从文本处向其父视图寻找, 直至发现一个可点击的部件为止.</p>\n</blockquote>\n"
        },
        {
          "textRaw": "click(left, top, bottom, right)",
          "type": "method",
          "name": "click",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`left` {number} 要点击的长方形区域左边与屏幕左边的像素距离 ",
                  "name": "left",
                  "type": "number",
                  "desc": "要点击的长方形区域左边与屏幕左边的像素距离"
                },
                {
                  "textRaw": "`top` {number} 要点击的长方形区域上边与屏幕上边的像素距离 ",
                  "name": "top",
                  "type": "number",
                  "desc": "要点击的长方形区域上边与屏幕上边的像素距离"
                },
                {
                  "textRaw": "`bottom` {number} 要点击的长方形区域下边与屏幕下边的像素距离 ",
                  "name": "bottom",
                  "type": "number",
                  "desc": "要点击的长方形区域下边与屏幕下边的像素距离"
                },
                {
                  "textRaw": "`right` {number} 要点击的长方形区域右边与屏幕右边的像素距离 ",
                  "name": "right",
                  "type": "number",
                  "desc": "要点击的长方形区域右边与屏幕右边的像素距离"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "left"
                },
                {
                  "name": "top"
                },
                {
                  "name": "bottom"
                },
                {
                  "name": "right"
                }
              ]
            }
          ],
          "desc": "<p><strong>注意, 该函数一般只用于录制的脚本中使用, 在自己写的代码中使用该函数一般不要使用该函数. </strong></p>\n<p>点击在指定区域的控件. 当屏幕中并未包含与该区域严格匹配的区域, 或者该区域不能点击时返回false, 否则返回true.</p>\n<p>有些按钮或者部件是图标而不是文字（例如发送朋友圈的照相机图标以及QQ下方的消息、联系人、动态图标）, 这时不能通过<code>click(text, i)</code>来点击, 可以通过描述图标所在的区域来点击. left, bottom, top, right描述的就是点击的区域.</p>\n<p>至于要定位点击的区域, 可以在悬浮窗使用布局分析工具查看控件的bounds属性.</p>\n<p>通过无障碍服务录制脚本会生成该语句.</p>\n"
        },
        {
          "textRaw": "scrollUp([i])",
          "type": "method",
          "name": "scrollUp",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`i` {number} 要滑动的控件序号 ",
                  "name": "i",
                  "type": "number",
                  "desc": "要滑动的控件序号",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "i",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>找到第i+1个可滑动控件上滑或<strong>左滑</strong>. 返回是否操作成功. 屏幕上没有可滑动的控件时返回false.</p>\n<p>另外不加参数时<code>scrollUp()</code>会寻找面积最大的可滑动的控件上滑或左滑, 例如微信消息列表等.</p>\n<p>参数为一个整数i时会找到第i + 1个可滑动控件滑动. 例如<code>scrollUp(0)</code>为滑动第一个可滑动控件.</p>\n"
        },
        {
          "textRaw": "scrollDown([i])",
          "type": "method",
          "name": "scrollDown",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`i` {number} 要滑动的控件序号 ",
                  "name": "i",
                  "type": "number",
                  "desc": "要滑动的控件序号",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "i",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>找到第i+1个可滑动控件下滑或<strong>右滑</strong>. 返回是否操作成功. 屏幕上没有可滑动的控件时返回false.</p>\n<p>另外不加参数时<code>scrollUp()</code>会寻找面积最大的可滑动的控件下滑或右滑.</p>\n<p>参数为一个整数i时会找到第i + 1个可滑动控件滑动. 例如<code>scrollUp(0)</code>为滑动第一个可滑动控件.</p>\n"
        },
        {
          "textRaw": "setText([i, ]text)",
          "type": "method",
          "name": "setText",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "i {number} 表示要输入的为第i + 1个输入框 ",
                  "name": "i",
                  "type": "number",
                  "desc": "表示要输入的为第i + 1个输入框",
                  "optional": true
                },
                {
                  "textRaw": "text {string} 要输入的文本 ",
                  "name": "text",
                  "type": "string",
                  "desc": "要输入的文本"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "i",
                  "optional": true
                },
                {
                  "name": "text"
                }
              ]
            }
          ],
          "desc": "<p>返回是否输入成功. 当找不到对应的文本框时返回false.</p>\n<p>不加参数i则会把所有输入框的文本都置为text. 例如<code>setText(&quot;测试&quot;)</code>.</p>\n<p>这里的输入文本的意思是, 把输入框的文本置为text, 而不是在原来的文本上追加.</p>\n"
        },
        {
          "textRaw": "input([i, ]text)",
          "type": "method",
          "name": "input",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "i {number} 表示要输入的为第i + 1个输入框 ",
                  "name": "i",
                  "type": "number",
                  "desc": "表示要输入的为第i + 1个输入框",
                  "optional": true
                },
                {
                  "textRaw": "text {string} 要输入的文本 ",
                  "name": "text",
                  "type": "string",
                  "desc": "要输入的文本"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "i",
                  "optional": true
                },
                {
                  "name": "text"
                }
              ]
            }
          ],
          "desc": "<p>返回是否输入成功. 当找不到对应的文本框时返回false.</p>\n<p>不加参数i则会把所有输入框的文本追加内容text. 例如<code>input(&quot;测试&quot;)</code>.\n<!-- [end-include:automator.md] --></p>\n<!-- [start-include:autojs.md] -->\n"
        }
      ],
      "modules": [
        {
          "textRaw": "longClick(text[, i]))",
          "name": "longclick(text[,_i]))",
          "desc": "<ul>\n<li><code>text</code> {string} 要长按的文本</li>\n<li><code>i</code> {number} 如果相同的文本在屏幕中出现多次, 则i表示要长按第几个文本, i从0开始计算</li>\n</ul>\n<p>返回是否点击成功. 当屏幕中并未包含该文本, 或者该文本所在区域不能点击时返回false, 否则返回true.</p>\n<p>当不指定参数i时则会尝试点击屏幕上出现的所有文字text并返回是否全部长按成功.</p>\n",
          "type": "module",
          "displayName": "longClick(text[, i]))"
        }
      ],
      "type": "module",
      "displayName": "SimpleActionAutomator"
    },
    {
      "textRaw": "AutoJs6 本体应用",
      "name": "autojs6_本体应用",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<!-- [end-include:autojs.md] -->\n<!-- [start-include:app.md] -->\n",
      "type": "module",
      "displayName": "AutoJs6 本体应用"
    },
    {
      "textRaw": "通用应用 (App)",
      "name": "通用应用_(app)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>app模块提供一系列函数, 用于使用其他应用、与其他应用交互. 例如发送意图、打开文件、发送邮件等.</p>\n<p>同时提供了方便的进阶函数startActivity和sendBroadcast, 用他们可完成app模块没有内置的和其他应用的交互.</p>\n",
      "properties": [
        {
          "textRaw": "`versionCode` {number} ",
          "type": "number",
          "name": "versionCode",
          "desc": "<p>当前软件版本号, 整数值. 例如160, 256等.</p>\n<p>如果在Auto.js中运行则为Auto.js的版本号；在打包的软件中则为打包软件的版本号.</p>\n<pre><code>toastLog(app.versionCode);\n</code></pre>"
        },
        {
          "textRaw": "`versionName` {string} ",
          "type": "string",
          "name": "versionName",
          "desc": "<p>当前软件的版本名称, 例如&quot;3.0.0 Beta&quot;.</p>\n<p>如果在Auto.js中运行则为Auto.js的版本名称；在打包的软件中则为打包软件的版本名称.</p>\n<pre><code>toastLog(app.verionName);\n</code></pre>"
        }
      ],
      "modules": [
        {
          "textRaw": "app.autojs.versionCode",
          "name": "app.autojs.versioncode",
          "desc": "<ul>\n<li>{number}</li>\n</ul>\n<p>Auto.js版本号, 整数值. 例如160, 256等.</p>\n",
          "type": "module",
          "displayName": "app.autojs.versionCode"
        },
        {
          "textRaw": "app.autojs.versionName",
          "name": "app.autojs.versionname",
          "desc": "<ul>\n<li>{string}</li>\n</ul>\n<p>Auto.js版本名称, 例如&quot;3.0.0 Beta&quot;.</p>\n",
          "type": "module",
          "displayName": "app.autojs.versionName"
        }
      ],
      "methods": [
        {
          "textRaw": "app.launchApp(appName)",
          "type": "method",
          "name": "launchApp",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`appName` {string} 应用名称 ",
                  "name": "appName",
                  "type": "string",
                  "desc": "应用名称"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "appName"
                }
              ]
            }
          ],
          "desc": "<p>通过应用名称启动应用. 如果该名称对应的应用不存在, 则返回false; 否则返回true. 如果该名称对应多个应用, 则只启动其中某一个.</p>\n<p>该函数也可以作为全局函数使用.</p>\n<pre><code>launchApp(&quot;Auto.js&quot;);\n</code></pre>"
        },
        {
          "textRaw": "app.launch(packageName)",
          "type": "method",
          "name": "launch",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`packageName` {string} 应用包名 ",
                  "name": "packageName",
                  "type": "string",
                  "desc": "应用包名"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "packageName"
                }
              ]
            }
          ],
          "desc": "<p>通过应用包名启动应用. 如果该包名对应的应用不存在, 则返回false；否则返回true.</p>\n<p>该函数也可以作为全局函数使用.</p>\n<pre><code>//启动微信\nlaunch(&quot;com.tencent.mm&quot;);\n</code></pre>"
        },
        {
          "textRaw": "app.launchPackage(packageName)",
          "type": "method",
          "name": "launchPackage",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`packageName` {string} 应用包名 ",
                  "name": "packageName",
                  "type": "string",
                  "desc": "应用包名"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "packageName"
                }
              ]
            }
          ],
          "desc": "<p>相当于<code>app.launch(packageName)</code>.</p>\n"
        },
        {
          "textRaw": "app.getPackageName(appName)",
          "type": "method",
          "name": "getPackageName",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`appName` {string} 应用名称 ",
                  "name": "appName",
                  "type": "string",
                  "desc": "应用名称"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "appName"
                }
              ]
            }
          ],
          "desc": "<p>获取应用名称对应的已安装的应用的包名. 如果该找不到该应用, 返回null；如果该名称对应多个应用, 则只返回其中某一个的包名.</p>\n<p>该函数也可以作为全局函数使用.</p>\n<pre><code>var name = getPackageName(&quot;QQ&quot;); //返回&quot;com.tencent.mobileqq&quot;\n</code></pre>"
        },
        {
          "textRaw": "app.getAppName(packageName)",
          "type": "method",
          "name": "getAppName",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`packageName` {string} 应用包名 ",
                  "name": "packageName",
                  "type": "string",
                  "desc": "应用包名"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "packageName"
                }
              ]
            }
          ],
          "desc": "<p>获取应用包名对应的已安装的应用的名称. 如果该找不到该应用, 返回null.</p>\n<p>该函数也可以作为全局函数使用.</p>\n<pre><code>var name = getAppName(&quot;com.tencent.mobileqq&quot;); //返回&quot;QQ&quot;\n</code></pre>"
        },
        {
          "textRaw": "app.openAppSetting(packageName)",
          "type": "method",
          "name": "openAppSetting",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`packageName` {string} 应用包名 ",
                  "name": "packageName",
                  "type": "string",
                  "desc": "应用包名"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "packageName"
                }
              ]
            }
          ],
          "desc": "<p>打开应用的详情页(设置页). 如果找不到该应用, 返回false; 否则返回true.</p>\n<p>该函数也可以作为全局函数使用.</p>\n"
        },
        {
          "textRaw": "app.viewFile(path)",
          "type": "method",
          "name": "viewFile",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 文件路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "文件路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>用其他应用查看文件. 文件不存在的情况由查看文件的应用处理.</p>\n<p>如果找不出可以查看该文件的应用, 则抛出<code>ActivityNotException</code>.</p>\n<pre><code>//查看文本文件\napp.viewFile(&quot;/sdcard/1.txt&quot;);\n</code></pre>"
        },
        {
          "textRaw": "app.editFile(path)",
          "type": "method",
          "name": "editFile",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 文件路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "文件路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>用其他应用编辑文件. 文件不存在的情况由编辑文件的应用处理.</p>\n<p>如果找不出可以编辑该文件的应用, 则抛出<code>ActivityNotException</code>.</p>\n<pre><code>//编辑文本文件\napp.editFile(&quot;/sdcard/1.txt/);\n</code></pre>"
        },
        {
          "textRaw": "app.uninstall(packageName)",
          "type": "method",
          "name": "uninstall",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`packageName` {string} 应用包名 ",
                  "name": "packageName",
                  "type": "string",
                  "desc": "应用包名"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "packageName"
                }
              ]
            }
          ],
          "desc": "<p>卸载应用. 执行后会会弹出卸载应用的提示框. 如果该包名的应用未安装, 由应用卸载程序处理, 可能弹出&quot;未找到应用&quot;的提示.</p>\n<pre><code>//卸载QQ\napp.uninstall(&quot;com.tencent.mobileqq&quot;);\n</code></pre>"
        },
        {
          "textRaw": "app.openUrl(url)",
          "type": "method",
          "name": "openUrl",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`url` {string} 网站的Url, 如果不以\"http://\"或\"https://\"开头则默认是\"http://\". ",
                  "name": "url",
                  "type": "string",
                  "desc": "网站的Url, 如果不以\"http://\"或\"https://\"开头则默认是\"http://\"."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "url"
                }
              ]
            }
          ],
          "desc": "<p>用浏览器打开网站url.</p>\n<p>如果没有安装浏览器应用, 则抛出<code>ActivityNotException</code>.</p>\n"
        },
        {
          "textRaw": "app.sendEmail(options)",
          "type": "method",
          "name": "sendEmail",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} 发送邮件的参数. 包括: ",
                  "name": "options",
                  "type": "Object",
                  "desc": "发送邮件的参数. 包括:"
                },
                {
                  "textRaw": "`email` {string} | {Array} 收件人的邮件地址. 如果有多个收件人, 则用字符串数组表示 ",
                  "name": "email",
                  "type": "string",
                  "desc": "| {Array} 收件人的邮件地址. 如果有多个收件人, 则用字符串数组表示"
                },
                {
                  "textRaw": "`cc` {string} | {Array} 抄送收件人的邮件地址. 如果有多个抄送收件人, 则用字符串数组表示 ",
                  "name": "cc",
                  "type": "string",
                  "desc": "| {Array} 抄送收件人的邮件地址. 如果有多个抄送收件人, 则用字符串数组表示"
                },
                {
                  "textRaw": "`bcc` {string} | {Array} 密送收件人的邮件地址. 如果有多个密送收件人, 则用字符串数组表示 ",
                  "name": "bcc",
                  "type": "string",
                  "desc": "| {Array} 密送收件人的邮件地址. 如果有多个密送收件人, 则用字符串数组表示"
                },
                {
                  "textRaw": "`subject` {string} 邮件主题(标题) ",
                  "name": "subject",
                  "type": "string",
                  "desc": "邮件主题(标题)"
                },
                {
                  "textRaw": "`text` {string} 邮件正文 ",
                  "name": "text",
                  "type": "string",
                  "desc": "邮件正文"
                },
                {
                  "textRaw": "`attachment` {string} 附件的路径. ",
                  "name": "attachment",
                  "type": "string",
                  "desc": "附件的路径."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ],
          "desc": "<p>根据选项options调用邮箱应用发送邮件. 这些选项均是可选的.</p>\n<p>如果没有安装邮箱应用, 则抛出<code>ActivityNotException</code>.</p>\n<pre><code>//发送邮件给10086@qq.com和10001@qq.com.\napp.sendEmail({\n    email: [&quot;10086@qq.com&quot;, &quot;10001@qq.com&quot;],\n    subject: &quot;这是一个邮件标题&quot;,\n    text: &quot;这是邮件正文&quot;\n});\n</code></pre>"
        },
        {
          "textRaw": "app.startActivity(name)",
          "type": "method",
          "name": "startActivity",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`name` {string} 活动名称, 可选的值为: ",
                  "options": [
                    {
                      "textRaw": "`console` 日志界面 ",
                      "name": "console",
                      "desc": "日志界面"
                    },
                    {
                      "textRaw": "`settings` 设置界面 ",
                      "name": "settings",
                      "desc": "设置界面"
                    }
                  ],
                  "name": "name",
                  "type": "string",
                  "desc": "活动名称, 可选的值为:"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "name"
                }
              ]
            }
          ],
          "desc": "<p>启动Auto.js的特定界面. 该函数在Auto.js内运行则会打开Auto.js内的界面, 在打包应用中运行则会打开打包应用的相应界面.</p>\n<pre><code>app.startActivity(&quot;console&quot;);\n</code></pre>"
        },
        {
          "textRaw": "app.intent(options)",
          "type": "method",
          "name": "intent",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} 选项, 包括： ",
                  "options": [
                    {
                      "textRaw": "`action` {string} 意图的Action, 指意图要完成的动作, 是一个字符串常量, 比如\"android.intent.action.SEND\". 当action以\"android.intent.action\"开头时, 可以省略前缀, 直接用\"SEND\"代替. 参见[Actions](https://developer.android.com/reference/android/content/Intent.html#standard-activity-actions/). ",
                      "name": "action",
                      "type": "string",
                      "desc": "意图的Action, 指意图要完成的动作, 是一个字符串常量, 比如\"android.intent.action.SEND\". 当action以\"android.intent.action\"开头时, 可以省略前缀, 直接用\"SEND\"代替. 参见[Actions](https://developer.android.com/reference/android/content/Intent.html#standard-activity-actions/)."
                    },
                    {
                      "textRaw": "`type` {string} 意图的MimeType, 表示和该意图直接相关的数据的类型, 表示比如\"text/plain\"为纯文本类型. ",
                      "name": "type",
                      "type": "string",
                      "desc": "意图的MimeType, 表示和该意图直接相关的数据的类型, 表示比如\"text/plain\"为纯文本类型."
                    },
                    {
                      "textRaw": "`data` {string} 意图的Data, 表示和该意图直接相关的数据, 是一个Uri, 可以是文件路径或者Url等. 例如要打开一个文件, action为\"android.intent.action.VIEW\", data为\"file:///sdcard/1.txt\". ",
                      "name": "data",
                      "type": "string",
                      "desc": "意图的Data, 表示和该意图直接相关的数据, 是一个Uri, 可以是文件路径或者Url等. 例如要打开一个文件, action为\"android.intent.action.VIEW\", data为\"file:///sdcard/1.txt\"."
                    },
                    {
                      "textRaw": "`category` {Array} 意图的类别. 比较少用. 参见[Categories](https://developer.android.com/reference/android/content/Intent.html#standard-categories/). ",
                      "name": "category",
                      "type": "Array",
                      "desc": "意图的类别. 比较少用. 参见[Categories](https://developer.android.com/reference/android/content/Intent.html#standard-categories/)."
                    },
                    {
                      "textRaw": "`packageName` {string} 目标包名 ",
                      "name": "packageName",
                      "type": "string",
                      "desc": "目标包名"
                    },
                    {
                      "textRaw": "`className` {string} 目标Activity或Service等组件的名称 ",
                      "name": "className",
                      "type": "string",
                      "desc": "目标Activity或Service等组件的名称"
                    },
                    {
                      "textRaw": "`extras` {Object} 以键值对构成的这个Intent的Extras(额外信息). 提供该意图的其他信息, 例如发送邮件时的邮件标题、邮件正文. 参见[Extras](https://developer.android.com/reference/android/content/Intent.html#standard-extra-data/). ",
                      "name": "extras",
                      "type": "Object",
                      "desc": "以键值对构成的这个Intent的Extras(额外信息). 提供该意图的其他信息, 例如发送邮件时的邮件标题、邮件正文. 参见[Extras](https://developer.android.com/reference/android/content/Intent.html#standard-extra-data/)."
                    },
                    {
                      "textRaw": "`flags` {Array} intent的标识, 字符串数组, 例如`[\"activity_new_task\", \"grant_read_uri_permission\"]`. 参见[Flags](https://developer.android.com/reference/android/content/Intent.html#setFlags%28int%29/). **[v4.1.0新增]** ",
                      "name": "flags",
                      "type": "Array",
                      "desc": "intent的标识, 字符串数组, 例如`[\"activity_new_task\", \"grant_read_uri_permission\"]`. 参见[Flags](https://developer.android.com/reference/android/content/Intent.html#setFlags%28int%29/). **[v4.1.0新增]**"
                    },
                    {
                      "textRaw": "`root` {Boolea} 是否以root权限启动、发送该intent. 使用该参数后, 不能使用`context.startActivity()`等方法, 而应该直接使用诸如`app.startActivity({...})`的方法. **[v4.1.0新增]** ",
                      "name": "root",
                      "type": "Boolea",
                      "desc": "是否以root权限启动、发送该intent. 使用该参数后, 不能使用`context.startActivity()`等方法, 而应该直接使用诸如`app.startActivity({...})`的方法. **[v4.1.0新增]**"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "desc": "选项, 包括："
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ],
          "desc": "<p>根据选项, 构造一个意图Intent对象.</p>\n<p>例如：</p>\n<pre><code>//打开应用来查看图片文件\nvar i = app.intent({\n    action: &quot;VIEW&quot;,\n    type: &quot;image/png&quot;,\n    data: &quot;file:///sdcard/1.png&quot;\n});\ncontext.startActivity(i);\n</code></pre><p>需要注意的是, 除非应用专门暴露Activity出来, 否则在没有root权限的情况下使用intent是无法跳转到特定Activity、应用的特定界面的. 例如我们能通过Intent跳转到QQ的分享界面, 是因为QQ对外暴露了分享的Activity；而在没有root权限的情况下, 我们无法通过intent跳转到QQ的设置界面, 因为QQ并没有暴露这个Activity.</p>\n<p>但如果有root权限, 则在intent的参数加上<code>&quot;root&quot;: true</code>即可. 例如使用root权限跳转到Auto.js的设置界面为：</p>\n<pre><code>app.startActivity({\n    packageName: &quot;org.autojs.autojs&quot;,\n    className: &quot;org.autojs.autojs.ui.settings.SettingsActivity_&quot;,\n    root: true\n});\n</code></pre><p>另外, 关于intent的参数如何获取的问题, 一些intent是意外发现并且在网络中传播的（例如跳转QQ聊天窗口是因为QQ给网页提供了跳转到客服QQ的方法）, 如果要自己获取活动的intent的参数, 可以通过例如&quot;intent记录&quot;, &quot;隐式启动&quot;等应用拦截内部intent或者查询暴露的intent. 其中拦截内部intent需要XPosed框架, 或者可以通过反编译等手段获取参数. 总之, 没有简单直接的方法.</p>\n<p>更多信息, 请百度<a href=\"https://www.baidu.com/s?wd=android%20Intent\">安卓Intent</a>或参考<a href=\"https://developer.android.com/guide/components/intents-filters.html#Types\">Android指南: Intent</a>.</p>\n"
        },
        {
          "textRaw": "app.startActivity(options)",
          "type": "method",
          "name": "startActivity",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} 选项 ",
                  "name": "options",
                  "type": "Object",
                  "desc": "选项"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ],
          "desc": "<p>根据选项构造一个Intent, 并启动该Activity.</p>\n<pre><code>app.startActivity({\n    action: &quot;SEND&quot;,\n    type: &quot;text/plain&quot;,\n    data: &quot;file:///sdcard/1.txt&quot;\n});\n</code></pre>"
        },
        {
          "textRaw": "app.sendBroadcast(options)",
          "type": "method",
          "name": "sendBroadcast",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} 选项 ",
                  "name": "options",
                  "type": "Object",
                  "desc": "选项"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ],
          "desc": "<p>根据选项构造一个Intent, 并发送该广播.</p>\n"
        },
        {
          "textRaw": "app.startService(options)",
          "type": "method",
          "name": "startService",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} 选项 ",
                  "name": "options",
                  "type": "Object",
                  "desc": "选项"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ],
          "desc": "<p>根据选项构造一个Intent, 并启动该服务.</p>\n"
        },
        {
          "textRaw": "app.sendBroadcast(name)",
          "type": "method",
          "name": "sendBroadcast",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>name</code> {string} 特定的广播名称, 包括：<ul>\n<li><code>inspect_layout_hierarchy</code> 布局层次分析</li>\n<li><code>inspect_layout_bounds</code> 布局范围</li>\n</ul>\n</li>\n</ul>\n<p>发送以上特定名称的广播可以触发Auto.js的布局分析, 方便脚本调试. 这些广播在Auto.js发送才有效, 在打包的脚本上运行将没有任何效果.</p>\n<pre><code>app.sendBroadcast(&quot;inspect_layout_bounds&quot;);\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "name"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "app.intentToShell(options)",
          "type": "method",
          "name": "intentToShell",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>options</code> {Object} 选项</li>\n</ul>\n<p>根据选项构造一个Intent, 转换为对应的shell的intent命令的参数.</p>\n<p>例如:</p>\n<pre><code>shell(&quot;am start &quot; + app.intentToShell({\n    packageName: &quot;org.autojs.autojs&quot;,\n    className: &quot;org.autojs.autojs.ui.settings.SettingsActivity_&quot;\n}), true);\n</code></pre><p>参见<a href=\"https://developer.android.com/studio/command-line/adb#IntentSpec/\">intent参数的规范</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "app.parseUri(uri)",
          "type": "method",
          "name": "parseUri",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>uri</code> {string} 一个代表Uri的字符串, 例如&quot;file:///sdcard/1.txt&quot;, &quot;<a href=\"https://www.autojs.org&quot;\">https://www.autojs.org&quot;</a></li>\n<li>返回 {Uri} 一个代表Uri的对象, 参见<a href=\"https://developer.android.com/reference/android/net/Uri/\">android.net.Uri</a>.</li>\n</ul>\n<p>解析uri字符串并返回相应的Uri对象. 即使Uri格式错误, 该函数也会返回一个Uri对象, 但之后如果访问该对象的scheme, path等值可能因解析失败而返回<code>null</code>.</p>\n<p>需要注意的是, 在高版本Android上, 由于系统限制直接在Uri暴露文件的绝对路径, 因此如果uri字符串是文件<code>file://...</code>, 返回的Uri会是诸如<code>content://...</code>的形式.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "uri"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "app.getUriForFile(path)",
          "type": "method",
          "name": "getUriForFile",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>path</code> {string} 文件路径, 例如&quot;/sdcard/1.txt&quot;</li>\n<li>返回 {Uri} 一个指向该文件的Uri的对象, 参见<a href=\"https://developer.android.com/reference/android/net/Uri/\">android.net.Uri</a>.</li>\n</ul>\n<p>从一个文件路径创建一个uri对象. 需要注意的是, 在高版本Android上, 由于系统限制直接在Uri暴露文件的绝对路径, 因此返回的Uri会是诸如<code>content://...</code>的形式.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "app.getInstalledApps([options])",
          "type": "method",
          "name": "getInstalledApps",
          "desc": "<p><strong> [<a href=\"https://pro.autojs.org//\">Pro 8.0.0新增</a>] </strong></p>\n<ul>\n<li><code>options</code> {Object} 选项, 包括：<ul>\n<li><code>get</code>: 指定返回的应用信息中包含的信息<ul>\n<li><code>&quot;activities&quot;</code> 应用的Activity组件信息</li>\n<li><code>&quot;configurations&quot;</code> 应用的硬件配置</li>\n<li><code>&quot;gids&quot;</code> 应用的group id</li>\n<li><code>&quot;instrumentation&quot;</code> 应用的Instrumentation信息</li>\n<li><code>&quot;intent_filters&quot;</code> 应用的意图过滤</li>\n<li><code>&quot;meta_data&quot;</code> 应用的元信息（默认）</li>\n<li><code>&quot;permissions&quot;</code> 应用的权限信息</li>\n<li><code>&quot;providers&quot;</code> 应用的ContentProvider组件信息</li>\n<li><code>&quot;receivers&quot;</code> 应用的BroadcastReceiver组件信息</li>\n<li><code>&quot;services&quot;</code> 应用的Service组件信息</li>\n<li><code>&quot;shared_library_files&quot;</code> 应用的动态链接库文件信息</li>\n<li><code>&quot;signatures&quot;</code> 应用的签名信息（已弃用</li>\n<li><code>&quot;signing_certificates&quot;</code> 应用的签名信息</li>\n<li><code>&quot;uri_permission_patterns&quot;</code></li>\n<li><code>&quot;disabled_components&quot;</code> 被卸载的但保留了数据的应用</li>\n<li><code>&quot;disabled_until_used_components&quot;</code> 禁用直到被使用的组件</li>\n<li><code>&quot;uninstalled_packages&quot;</code> 被卸载的但保留了数据的应用</li>\n</ul>\n</li>\n<li><code>match</code>: 指定要匹配的应用列表<ul>\n<li><code>&quot;uninstalled_packages&quot;</code> 被卸载的但保留了数据的应用</li>\n<li><code>&quot;disabled_components&quot;</code> 被禁用的组件</li>\n<li><code>&quot;disabled_until_used_components&quot;</code> 禁用直到被使用的组件</li>\n<li><code>&quot;system_only&quot;</code> 只匹配系统应用</li>\n<li><code>&quot;factory_only&quot;</code> 只匹配预装应用</li>\n<li><code>&quot;apex&quot;</code> APEX应用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>返回 {Array\\&lt;ApplicationInfo>}</li>\n</ul>\n<p>返回为当前用户安装的所有应用程序包的列表. 如果设置了match选项 <code>uninstalled_packages</code>, 则包括被删除但保留了数据的应用程序.\n获取安装的应用列表.</p>\n<p>返回值是ApplicationInfo对象的数组.  如果没有安装任何应用, 则返回一个空数组.</p>\n<p>选项options的match选项用于指定要返回哪些应用程序, get选项用于指定返回的应用程序携带哪些信息.</p>\n<pre><code>let apps = $app.getInstalledApps({\n    matcg\n})\n</code></pre><!-- [end-include:app.md] -->\n<!-- [start-include:color.md] -->\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "通用应用 (App)"
    },
    {
      "textRaw": "颜色 (Colors)",
      "name": "颜色_(colors)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>在Auto.js有两种方式表示一个颜色.</p>\n<p>一种是使用一个字符串&quot;#AARRGGBB&quot;或&quot;#RRGGBB&quot;, 其中 AA 是Alpha通道(透明度)的值, RR 是R通道(红色)的值, GG 是G通道(绿色)的值, BB是B通道(蓝色)的值. 例如&quot;#ffffff&quot;表示白色, &quot;#7F000000&quot;表示半透明的黑色.</p>\n<p>另一种是使用一个16进制的&quot;32位整数&quot; 0xAARRGGBB 来表示一个颜色, 例如 <code>0xFF112233</code>表示颜色&quot;#112233&quot;, <code>0x11223344</code>表示颜色&quot;#11223344&quot;.</p>\n<p>可以通过<code>colors.toString()</code>把颜色整数转换为字符串, 通过<code>colors.parseColor()</code>把颜色字符串解析为颜色整数.</p>\n",
      "methods": [
        {
          "textRaw": "colors.toString(color)",
          "type": "method",
          "name": "toString",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color` {number} 整数RGB颜色值 ",
                  "name": "color",
                  "type": "number",
                  "desc": "整数RGB颜色值"
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color"
                }
              ]
            }
          ],
          "desc": "<p>返回颜色值的字符串, 格式为 &quot;#AARRGGBB&quot;.</p>\n"
        },
        {
          "textRaw": "colors.red(color)",
          "type": "method",
          "name": "red",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color` {number} | {string} 颜色值 ",
                  "name": "color",
                  "type": "number",
                  "desc": "| {string} 颜色值"
                },
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color"
                }
              ]
            }
          ],
          "desc": "<p>返回颜色color的R通道的值, 范围0~255.</p>\n"
        },
        {
          "textRaw": "colors.green(color)",
          "type": "method",
          "name": "green",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color` {number} | {string} 颜色值 ",
                  "name": "color",
                  "type": "number",
                  "desc": "| {string} 颜色值"
                },
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color"
                }
              ]
            }
          ],
          "desc": "<p>返回颜色color的G通道的值, 范围0~255.</p>\n"
        },
        {
          "textRaw": "colors.blue(color)",
          "type": "method",
          "name": "blue",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color` {number} | {string} 颜色值 ",
                  "name": "color",
                  "type": "number",
                  "desc": "| {string} 颜色值"
                },
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color"
                }
              ]
            }
          ],
          "desc": "<p>返回颜色color的B通道的值, 范围0~255.</p>\n"
        },
        {
          "textRaw": "colors.alpha(color)",
          "type": "method",
          "name": "alpha",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color` {number} | {string} 颜色值 ",
                  "name": "color",
                  "type": "number",
                  "desc": "| {string} 颜色值"
                },
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color"
                }
              ]
            }
          ],
          "desc": "<p>返回颜色color的Alpha通道的值, 范围0~255.</p>\n"
        },
        {
          "textRaw": "colors.rgb(red, green, blue)",
          "type": "method",
          "name": "rgb",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "red {number} 颜色的R通道的值 ",
                  "name": "red",
                  "type": "number",
                  "desc": "颜色的R通道的值"
                },
                {
                  "textRaw": "blue {number} 颜色的G通道的值 ",
                  "name": "blue",
                  "type": "number",
                  "desc": "颜色的G通道的值"
                },
                {
                  "textRaw": "green {number} 颜色的B通道的值 ",
                  "name": "green",
                  "type": "number",
                  "desc": "颜色的B通道的值"
                },
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "red"
                },
                {
                  "name": "green"
                },
                {
                  "name": "blue"
                }
              ]
            }
          ],
          "desc": "<p>返回这些颜色通道构成的整数颜色值. Alpha通道将是255（不透明）.</p>\n"
        },
        {
          "textRaw": "colors.argb(alpha, red, green, blue)",
          "type": "method",
          "name": "argb",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`alpha` {number} 颜色的Alpha通道的值 ",
                  "name": "alpha",
                  "type": "number",
                  "desc": "颜色的Alpha通道的值"
                },
                {
                  "textRaw": "`red` {number} 颜色的R通道的值 ",
                  "name": "red",
                  "type": "number",
                  "desc": "颜色的R通道的值"
                },
                {
                  "textRaw": "`green` {number} 颜色的G通道的值 ",
                  "name": "green",
                  "type": "number",
                  "desc": "颜色的G通道的值"
                },
                {
                  "textRaw": "`blue` {number} 颜色的B通道的值 ",
                  "name": "blue",
                  "type": "number",
                  "desc": "颜色的B通道的值"
                },
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "alpha"
                },
                {
                  "name": "red"
                },
                {
                  "name": "green"
                },
                {
                  "name": "blue"
                }
              ]
            }
          ],
          "desc": "<p>返回这些颜色通道构成的整数颜色值.</p>\n"
        },
        {
          "textRaw": "colors.parseColor(colorStr)",
          "type": "method",
          "name": "parseColor",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`colorStr` {string} 表示颜色的字符串, 例如\"#112233\" ",
                  "name": "colorStr",
                  "type": "string",
                  "desc": "表示颜色的字符串, 例如\"#112233\""
                },
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "colorStr"
                }
              ]
            }
          ],
          "desc": "<p>返回颜色的整数值.</p>\n"
        },
        {
          "textRaw": "colors.isSimilar(color2, color2[, threshold, algorithm])",
          "type": "method",
          "name": "isSimilar",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color1` {number} | {string} 颜色值1 ",
                  "name": "color1",
                  "type": "number",
                  "desc": "| {string} 颜色值1"
                },
                {
                  "textRaw": "`color1` {number} | {string} 颜色值2 ",
                  "name": "color1",
                  "type": "number",
                  "desc": "| {string} 颜色值2"
                },
                {
                  "textRaw": "`threshold` {number} 颜色相似度临界值, 默认为4. 取值范围为0~255. 这个值越大表示允许的相似程度越小, 如果这个值为0, 则两个颜色相等时该函数才会返回true. ",
                  "name": "threshold",
                  "type": "number",
                  "desc": "颜色相似度临界值, 默认为4. 取值范围为0~255. 这个值越大表示允许的相似程度越小, 如果这个值为0, 则两个颜色相等时该函数才会返回true.",
                  "optional": true
                },
                {
                  "textRaw": "`algorithm` {string} 颜色匹配算法, 默认为\"diff\", 包括: ",
                  "options": [
                    {
                      "textRaw": "\"diff\": 差值匹配. 与给定颜色的R、G、B差的绝对值之和小于threshold时匹配. ",
                      "name": "diff",
                      "desc": "差值匹配. 与给定颜色的R、G、B差的绝对值之和小于threshold时匹配."
                    },
                    {
                      "textRaw": "\"rgb\": rgb欧拉距离相似度. 与给定颜色color的rgb欧拉距离小于等于threshold时匹配. ",
                      "name": "rgb",
                      "desc": "rgb欧拉距离相似度. 与给定颜色color的rgb欧拉距离小于等于threshold时匹配."
                    },
                    {
                      "textRaw": "\"rgb+\": 加权rgb欧拉距离匹配([LAB Delta E](https://en.wikipedia.org/wiki/Color_difference/)). ",
                      "name": "rgb+",
                      "desc": "加权rgb欧拉距离匹配([LAB Delta E](https://en.wikipedia.org/wiki/Color_difference/))."
                    },
                    {
                      "textRaw": "\"hs\": hs欧拉距离匹配. hs为HSV空间的色调值. ",
                      "name": "hs",
                      "desc": "hs欧拉距离匹配. hs为HSV空间的色调值."
                    }
                  ],
                  "name": "algorithm",
                  "type": "string",
                  "desc": "颜色匹配算法, 默认为\"diff\", 包括:",
                  "optional": true
                },
                {
                  "textRaw": "返回 {Boolean} ",
                  "name": "返回",
                  "type": "Boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color2"
                },
                {
                  "name": "color2"
                },
                {
                  "name": "threshold",
                  "optional": true
                },
                {
                  "name": "algorithm",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>返回两个颜色是否相似.</p>\n"
        },
        {
          "textRaw": "colors.equals(color1, color2)",
          "type": "method",
          "name": "equals",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color1` {number} | {string} 颜色值1 ",
                  "name": "color1",
                  "type": "number",
                  "desc": "| {string} 颜色值1"
                },
                {
                  "textRaw": "`color1` {number} | {string} 颜色值2 ",
                  "name": "color1",
                  "type": "number",
                  "desc": "| {string} 颜色值2"
                },
                {
                  "textRaw": "返回 {Boolean} ",
                  "name": "返回",
                  "type": "Boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color1"
                },
                {
                  "name": "color2"
                }
              ]
            }
          ],
          "desc": "<p>返回两个颜色是否相等. *<em>注意该函数会忽略Alpha通道的值进行比较</em>.</p>\n<pre><code>log(colors.equals(&quot;#112233&quot;, &quot;#112234&quot;));\nlog(colors.equals(0xFF112233, 0xFF223344));\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "颜色 (Colors)"
    },
    {
      "textRaw": "图像 (Images)",
      "name": "图像_(images)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>images模块提供了一些手机设备中常见的图片处理函数, 包括截图、读写图片、图片剪裁、旋转、二值化、找色找图等.</p>\n<p>该模块分为两个部分, 找图找色部分和图片处理部分.</p>\n<p>需要注意的是, image对象创建后尽量在不使用时进行回收, 同时避免循环创建大量图片. 因为图片是一种占用内存比较大的资源, 尽管Auto.js通过各种方式（比如图片缓存机制、垃圾回收时回收图片、脚本结束时回收所有图片）尽量降低图片资源的泄漏和内存占用, 但是糟糕的代码仍然可以占用大量内存.</p>\n<p>Image对象通过调用<code>recycle()</code>函数来回收. 例如：</p>\n<pre><code>// 读取图片\nvar img = images.read(&quot;./1.png&quot;);\n//对图片进行操作\n... \n// 回收图片\nimg.recycle();\n</code></pre><p>例外的是, <code>caputerScreen()</code>返回的图片不需要回收.</p>\n",
      "methods": [
        {
          "textRaw": "图片处理",
          "name": "图片处理",
          "type": "method",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 图片路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "图片路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>读取在路径path的图片文件并返回一个Image对象. 如果文件不存在或者文件无法解码则返回null.</p>\n"
        },
        {
          "textRaw": "images.read(path)",
          "type": "method",
          "name": "read",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 图片路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "图片路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>读取在路径path的图片文件并返回一个Image对象. 如果文件不存在或者文件无法解码则返回null.</p>\n"
        },
        {
          "textRaw": "images.load(url)",
          "type": "method",
          "name": "load",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`url` {string} 图片URL地址 ",
                  "name": "url",
                  "type": "string",
                  "desc": "图片URL地址"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "url"
                }
              ]
            }
          ],
          "desc": "<p>加载在地址URL的网络图片并返回一个Image对象. 如果地址不存在或者图片无法解码则返回null.</p>\n"
        },
        {
          "textRaw": "images.copy(img)",
          "type": "method",
          "name": "copy",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`img` {Image} 图片 ",
                  "name": "img",
                  "type": "Image",
                  "desc": "图片"
                },
                {
                  "textRaw": "返回 {Image} ",
                  "name": "返回",
                  "type": "Image"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "img"
                }
              ]
            }
          ],
          "desc": "<p>复制一张图片并返回新的副本. 该函数会完全复制img对象的数据.</p>\n"
        },
        {
          "textRaw": "images.save(image, path[, format = \"png\", quality = 100])",
          "type": "method",
          "name": "save",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`image` {Image} 图片 ",
                  "name": "image",
                  "type": "Image",
                  "desc": "图片"
                },
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "`format` {string} 图片格式, 可选的值为: ",
                  "options": [
                    {
                      "textRaw": "`png` ",
                      "name": "png"
                    },
                    {
                      "textRaw": "`jpeg`/`jpg` ",
                      "name": "jpeg",
                      "desc": "/`jpg`"
                    },
                    {
                      "textRaw": "`webp` ",
                      "name": "webp"
                    }
                  ],
                  "name": "format",
                  "type": "string",
                  "desc": "图片格式, 可选的值为:",
                  "optional": true,
                  "default": " \"png\""
                },
                {
                  "textRaw": "`quality` {number} 图片质量, 为0~100的整数值 ",
                  "name": "quality",
                  "type": "number",
                  "desc": "图片质量, 为0~100的整数值",
                  "optional": true,
                  "default": " 100"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "image"
                },
                {
                  "name": "path"
                },
                {
                  "name": "format ",
                  "optional": true,
                  "default": " \"png\""
                },
                {
                  "name": "quality ",
                  "optional": true,
                  "default": " 100"
                }
              ]
            }
          ],
          "desc": "<p>把图片image以PNG格式保存到path中. 如果文件不存在会被创建；文件存在会被覆盖.</p>\n<pre><code>//把图片压缩为原来的一半质量并保存\nvar img = images.read(&quot;/sdcard/1.png&quot;);\nimages.save(img, &quot;/sdcard/1.jpg&quot;, &quot;jpg&quot;, 50);\napp.viewFile(&quot;/sdcard/1.jpg&quot;);\n</code></pre>"
        },
        {
          "textRaw": "images.fromBase64(base64)",
          "type": "method",
          "name": "fromBase64",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`base64` {string} 图片的Base64数据 ",
                  "name": "base64",
                  "type": "string",
                  "desc": "图片的Base64数据"
                },
                {
                  "textRaw": "返回 {Image} ",
                  "name": "返回",
                  "type": "Image"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "base64"
                }
              ]
            }
          ],
          "desc": "<p>解码Base64数据并返回解码后的图片Image对象. 如果base64无法解码则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "images.toBase64(img[, format = \"png\", quality = 100])",
          "type": "method",
          "name": "toBase64",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`image` {image} 图片 ",
                  "name": "image",
                  "type": "image",
                  "desc": "图片"
                },
                {
                  "textRaw": "`format` {string} 图片格式, 可选的值为: ",
                  "options": [
                    {
                      "textRaw": "`png` ",
                      "name": "png"
                    },
                    {
                      "textRaw": "`jpeg`/`jpg` ",
                      "name": "jpeg",
                      "desc": "/`jpg`"
                    },
                    {
                      "textRaw": "`webp` ",
                      "name": "webp"
                    }
                  ],
                  "name": "format",
                  "type": "string",
                  "desc": "图片格式, 可选的值为:",
                  "optional": true,
                  "default": " \"png\""
                },
                {
                  "textRaw": "`quality` {number} 图片质量, 为0~100的整数值 ",
                  "name": "quality",
                  "type": "number",
                  "desc": "图片质量, 为0~100的整数值",
                  "optional": true,
                  "default": " 100"
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "format ",
                  "optional": true,
                  "default": " \"png\""
                },
                {
                  "name": "quality ",
                  "optional": true,
                  "default": " 100"
                }
              ]
            }
          ],
          "desc": "<p>把图片编码为base64数据并返回.</p>\n"
        },
        {
          "textRaw": "images.fromBytes(bytes)",
          "type": "method",
          "name": "fromBytes",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`bytes` {byte[]} 字节数组 ",
                  "name": "bytes",
                  "type": "byte[]",
                  "desc": "字节数组"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "bytes"
                }
              ]
            }
          ],
          "desc": "<p>解码字节数组bytes并返回解码后的图片Image对象. 如果bytes无法解码则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "images.toBytes(img[, format = \"png\", quality = 100])",
          "type": "method",
          "name": "toBytes",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`image` {image} 图片 ",
                  "name": "image",
                  "type": "image",
                  "desc": "图片"
                },
                {
                  "textRaw": "`format` {string} 图片格式, 可选的值为: ",
                  "options": [
                    {
                      "textRaw": "`png` ",
                      "name": "png"
                    },
                    {
                      "textRaw": "`jpeg`/`jpg` ",
                      "name": "jpeg",
                      "desc": "/`jpg`"
                    },
                    {
                      "textRaw": "`webp` ",
                      "name": "webp"
                    }
                  ],
                  "name": "format",
                  "type": "string",
                  "desc": "图片格式, 可选的值为:",
                  "optional": true,
                  "default": " \"png\""
                },
                {
                  "textRaw": "`quality` {number} 图片质量, 为0~100的整数值 ",
                  "name": "quality",
                  "type": "number",
                  "desc": "图片质量, 为0~100的整数值",
                  "optional": true,
                  "default": " 100"
                },
                {
                  "textRaw": "返回 {byte[]} ",
                  "name": "返回",
                  "type": "byte[]"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "format ",
                  "optional": true,
                  "default": " \"png\""
                },
                {
                  "name": "quality ",
                  "optional": true,
                  "default": " 100"
                }
              ]
            }
          ],
          "desc": "<p>把图片编码为字节数组并返回.</p>\n"
        },
        {
          "textRaw": "images.clip(img, x, y, w, h)",
          "type": "method",
          "name": "clip",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`img` {Image} 图片 ",
                  "name": "img",
                  "type": "Image",
                  "desc": "图片"
                },
                {
                  "textRaw": "`x` {number} 剪切区域的左上角横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "剪切区域的左上角横坐标"
                },
                {
                  "textRaw": "`y` {number} 剪切区域的左上角纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "剪切区域的左上角纵坐标"
                },
                {
                  "textRaw": "`w` {number} 剪切区域的宽度 ",
                  "name": "w",
                  "type": "number",
                  "desc": "剪切区域的宽度"
                },
                {
                  "textRaw": "`h` {number} 剪切区域的高度 ",
                  "name": "h",
                  "type": "number",
                  "desc": "剪切区域的高度"
                },
                {
                  "textRaw": "返回 {Image} ",
                  "name": "返回",
                  "type": "Image"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "w"
                },
                {
                  "name": "h"
                }
              ]
            }
          ],
          "desc": "<p>从图片img的位置(x, y)处剪切大小为w * h的区域, 并返回该剪切区域的新图片.</p>\n<pre><code>var src = images.read(&quot;/sdcard/1.png&quot;);\nvar clip = images.clip(src, 100, 100, 400, 400);\nimages.save(clip, &quot;/sdcard/clip.png&quot;);\n</code></pre>"
        },
        {
          "textRaw": "images.resize(img, size[, interpolation])",
          "type": "method",
          "name": "resize",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>size</code> {Array} 两个元素的数组[w, h], 分别表示宽度和高度；如果只有一个元素, 则宽度和高度相等</li>\n<li><p><code>interpolation</code> {string} 插值方法, 可选, 默认为&quot;LINEAR&quot;（线性插值）, 可选的值有：</p>\n<ul>\n<li><code>NEAREST</code> 最近邻插值</li>\n<li><code>LINEAR</code> 线性插值（默认）</li>\n<li><code>AREA</code> 区域插值</li>\n<li><code>CUBIC</code> 三次样条插值</li>\n<li><code>LANCZOS4</code> Lanczos插值\n参见<a href=\"https://docs.opencv.org/3.4.4/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121/\">InterpolationFlags</a></li>\n</ul>\n</li>\n<li><p>返回 {Image}</p>\n</li>\n</ul>\n<p>调整图片大小, 并返回调整后的图片. 例如把图片放缩为200*300：<code>images.resize(img, [200, 300])</code>.</p>\n<p>参见<a href=\"https://docs.opencv.org/3.4.4/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d/\">Imgproc.resize</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "size"
                },
                {
                  "name": "interpolation",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.scale(img, fx, fy[, interpolation])",
          "type": "method",
          "name": "scale",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>fx</code> {number} 宽度放缩倍数</li>\n<li><code>fy</code> {number} 高度放缩倍数</li>\n<li><p><code>interpolation</code> {string} 插值方法, 可选, 默认为&quot;LINEAR&quot;（线性插值）, 可选的值有：</p>\n<ul>\n<li><code>NEAREST</code> 最近邻插值</li>\n<li><code>LINEAR</code> 线性插值（默认）</li>\n<li><code>AREA</code> 区域插值</li>\n<li><code>CUBIC</code> 三次样条插值</li>\n<li><code>LANCZOS4</code> Lanczos插值\n参见<a href=\"https://docs.opencv.org/3.4.4/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121/\">InterpolationFlags</a></li>\n</ul>\n</li>\n<li><p>返回 {Image}</p>\n</li>\n</ul>\n<p>放缩图片, 并返回放缩后的图片. 例如把图片变成原来的一半：<code>images.scale(img, 0.5, 0.5)</code>.</p>\n<p>参见<a href=\"https://docs.opencv.org/3.4.4/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d/\">Imgproc.resize</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "fx"
                },
                {
                  "name": "fy"
                },
                {
                  "name": "interpolation",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.rotate(img, degress[, x, y])",
          "type": "method",
          "name": "rotate",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>degress</code> {number} 旋转角度.</li>\n<li><code>x</code> {number} 旋转中心x坐标, 默认为图片中点</li>\n<li><code>y</code> {number} 旋转中心y坐标, 默认为图片中点</li>\n<li>返回 {Image}</li>\n</ul>\n<p>将图片逆时针旋转degress度, 返回旋转后的图片对象.</p>\n<p>例如逆时针旋转90度为<code>images.rotate(img, 90)</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "degress"
                },
                {
                  "name": "x",
                  "optional": true
                },
                {
                  "name": "y",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.concat(img1, image2[, direction])",
          "type": "method",
          "name": "concat",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img1</code> {Image} 图片1</li>\n<li><code>img2</code> {Image} 图片2</li>\n<li>direction {string} 连接方向, 默认为&quot;RIGHT&quot;, 可选的值有：<ul>\n<li><code>LEFT</code> 将图片2接到图片1左边</li>\n<li><code>RIGHT</code> 将图片2接到图片1右边</li>\n<li><code>TOP</code> 将图片2接到图片1上边</li>\n<li><code>BOTTOM</code> 将图片2接到图片1下边</li>\n</ul>\n</li>\n<li>返回 {Image}</li>\n</ul>\n<p>连接两张图片, 并返回连接后的图像. 如果两张图片大小不一致, 小的那张将适当居中.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img1"
                },
                {
                  "name": "image2"
                },
                {
                  "name": "direction",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.grayscale(img)",
          "type": "method",
          "name": "grayscale",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li>返回 {Image}</li>\n</ul>\n<p>灰度化图片, 并返回灰度化后的图片.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "image.threshold(img, threshold, maxVal[, type])",
          "type": "method",
          "name": "threshold",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>threshold</code> {number} 阈值</li>\n<li><code>maxVal</code> {number} 最大值</li>\n<li><p><code>type</code> {string} 阈值化类型, 默认为&quot;BINARY&quot;, 参见<a href=\"https://docs.opencv.org/3.4.4/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576/\">ThresholdTypes</a>, 可选的值:</p>\n<ul>\n<li><code>BINARY</code></li>\n<li><code>BINARY_INV</code></li>\n<li><code>TRUNC</code></li>\n<li><code>TOZERO</code></li>\n<li><code>TOZERO_INV</code></li>\n<li><code>OTSU</code></li>\n<li><code>TRIANGLE</code></li>\n</ul>\n</li>\n<li><p>返回 {Image}</p>\n</li>\n</ul>\n<p>将图片阈值化, 并返回处理后的图像. 可以用这个函数进行图片二值化. 例如：<code>images.threshold(img, 100, 255, &quot;BINARY&quot;)</code>, 这个代码将图片中大于100的值全部变成255, 其余变成0, 从而达到二值化的效果. 如果img是一张灰度化图片, 这个代码将会得到一张黑白图片.</p>\n<p>可以参考有关博客（比如<a href=\"https://blog.csdn.net/u012566751/article/details/77046445/\">threshold函数的使用</a>）或者OpenCV文档<a href=\"https://docs.opencv.org/3.4.4/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57/\">threshold</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "threshold"
                },
                {
                  "name": "maxVal"
                },
                {
                  "name": "type",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.adaptiveThreshold(img, maxValue, adaptiveMethod, thresholdType, blockSize, C)",
          "type": "method",
          "name": "adaptiveThreshold",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>maxValue</code> {number} 最大值</li>\n<li><code>adaptiveMethod</code> {string} 在一个邻域内计算阈值所采用的算法, 可选的值有：<ul>\n<li><code>MEAN_C</code> 计算出领域的平均值再减去参数C的值</li>\n<li><code>GAUSSIAN_C</code> 计算出领域的高斯均值再减去参数C的值</li>\n</ul>\n</li>\n<li><code>thresholdType</code> {string} 阈值化类型, 可选的值有：<ul>\n<li><code>BINARY</code></li>\n<li><code>BINARY_INV</code></li>\n</ul>\n</li>\n<li><code>blockSize</code> {number} 邻域块大小</li>\n<li><code>C</code> {number} 偏移值调整量</li>\n<li>返回 {Image}</li>\n</ul>\n<p>对图片进行自适应阈值化处理, 并返回处理后的图像.</p>\n<p>可以参考有关博客（比如<a href=\"https://blog.csdn.net/guduruyu/article/details/68059450/\">threshold与adaptiveThreshold</a>）或者OpenCV文档<a href=\"https://docs.opencv.org/3.4.4/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3\n/\">adaptiveThreshold</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "maxValue"
                },
                {
                  "name": "adaptiveMethod"
                },
                {
                  "name": "thresholdType"
                },
                {
                  "name": "blockSize"
                },
                {
                  "name": "C"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.cvtColor(img, code[, dstCn])",
          "type": "method",
          "name": "cvtColor",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>code</code> {string} 颜色空间转换的类型, 可选的值有一共有205个（参见<a href=\"https://docs.opencv.org/3.4.4/d8/d01/group__imgproc__color__conversions.html#ga4e0972be5de079fed4e3a10e24ef5ef0/\">ColorConversionCodes</a>）, 这里只列出几个：<ul>\n<li><code>BGR2GRAY</code> BGR转换为灰度</li>\n<li><code>BGR2HSV</code> BGR转换为HSV</li>\n<li><code></code></li>\n</ul>\n</li>\n<li><code>dstCn</code> {number} 目标图像的颜色通道数量, 如果不填写则根据其他参数自动决定.</li>\n<li>返回 {Image}</li>\n</ul>\n<p>对图像进行颜色空间转换, 并返回转换后的图像.</p>\n<p>可以参考有关博客（比如<a href=\"https://blog.csdn.net/u011574296/article/details/70896811?locationNum=14&amp;fps=1\">颜色空间转换</a>）或者OpenCV文档<a href=\"https://docs.opencv.org/3.4.4/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab/\">cvtColor</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "code"
                },
                {
                  "name": "dstCn",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.inRange(img, lowerBound, upperBound)",
          "type": "method",
          "name": "inRange",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>lowerBound</code> {string} | {number} 颜色下界</li>\n<li><code>upperBound</code> {string} | {number} 颜色下界</li>\n<li>返回 {Image}</li>\n</ul>\n<p>将图片二值化, 在lowerBound~upperBound范围以外的颜色都变成0, 在范围以内的颜色都变成255.</p>\n<p>例如<code>images.inRange(img, &quot;#000000&quot;, &quot;#222222&quot;)</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "lowerBound"
                },
                {
                  "name": "upperBound"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.interval(img, color, interval)",
          "type": "method",
          "name": "interval",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>color</code> {string} | {number} 颜色值</li>\n<li><code>interval</code> {number} 每个通道的范围间隔</li>\n<li>返回 {Image}</li>\n</ul>\n<p>将图片二值化, 在color-interval ~ color+interval范围以外的颜色都变成0, 在范围以内的颜色都变成255. 这里对color的加减是对每个通道而言的.</p>\n<p>例如<code>images.interval(img, &quot;#888888&quot;, 16)</code>, 每个通道的颜色值均为0x88, 加减16后的范围是[0x78, 0x98], 因此这个代码将把#787878~#989898的颜色变成#FFFFFF, 而把这个范围以外的变成#000000.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "color"
                },
                {
                  "name": "interval"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.blur(img, size[, anchor, type])",
          "type": "method",
          "name": "blur",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>size</code> {Array} 定义滤波器的大小, 如[3, 3]</li>\n<li><code>anchor</code> {Array} 指定锚点位置(被平滑点), 默认为图像中心</li>\n<li><code>type</code> {string} 推断边缘像素类型, 默认为&quot;DEFAULT&quot;, 可选的值有：<ul>\n<li><code>CONSTANT</code> iiiiii|abcdefgh|iiiiiii with some specified i</li>\n<li><code>REPLICATE</code> aaaaaa|abcdefgh|hhhhhhh</li>\n<li><code>REFLECT</code> fedcba|abcdefgh|hgfedcb</li>\n<li><code>WRAP</code> cdefgh|abcdefgh|abcdefg</li>\n<li><code>REFLECT_101</code> gfedcb|abcdefgh|gfedcba</li>\n<li><code>TRANSPARENT</code> uvwxyz|abcdefgh|ijklmno</li>\n<li><code>REFLECT101</code> same as BORDER_REFLECT_101</li>\n<li><code>DEFAULT</code> same as BORDER_REFLECT_101</li>\n<li><code>ISOLATED</code> do not look outside of ROI</li>\n</ul>\n</li>\n<li>返回 {Image}</li>\n</ul>\n<p>对图像进行模糊（平滑处理）, 返回处理后的图像.</p>\n<p>可以参考有关博客（比如<a href=\"https://www.cnblogs.com/denny402/p/3848316.html\">实现图像平滑处理</a>）或者OpenCV文档<a href=\"https://docs.opencv.org/3.4.4/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37/\">blur</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "size"
                },
                {
                  "name": "anchor",
                  "optional": true
                },
                {
                  "name": "type",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.medianBlur(img, size)",
          "type": "method",
          "name": "medianBlur",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>size</code> {Array} 定义滤波器的大小, 如[3, 3]</li>\n<li>返回 {Image}</li>\n</ul>\n<p>对图像进行中值滤波, 返回处理后的图像.</p>\n<p>可以参考有关博客（比如<a href=\"https://www.cnblogs.com/denny402/p/3848316.html\">实现图像平滑处理</a>）或者OpenCV文档<a href=\"https://docs.opencv.org/3.4.4/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9/\">blur</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "size"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.gaussianBlur(img, size[, sigmaX, sigmaY, type])",
          "type": "method",
          "name": "gaussianBlur",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 图片</li>\n<li><code>size</code> {Array} 定义滤波器的大小, 如[3, 3]</li>\n<li><code>sigmaX</code> {number} x方向的标准方差, 不填写则自动计算</li>\n<li><code>sigmaY</code> {number} y方向的标准方差, 不填写则自动计算</li>\n<li><code>type</code> {string} 推断边缘像素类型, 默认为&quot;DEFAULT&quot;, 参见<code>images.blur</code></li>\n<li>返回 {Image}</li>\n</ul>\n<p>对图像进行高斯模糊, 返回处理后的图像.</p>\n<p>可以参考有关博客（比如<a href=\"https://www.cnblogs.com/denny402/p/3848316.html\">实现图像平滑处理</a>）或者OpenCV文档<a href=\"https://docs.opencv.org/3.4.4/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1/\">GaussianBlur</a>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "size"
                },
                {
                  "name": "sigmaX",
                  "optional": true
                },
                {
                  "name": "sigmaY",
                  "optional": true
                },
                {
                  "name": "type",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.matToImage(mat)",
          "type": "method",
          "name": "matToImage",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>mat</code> {Mat} OpenCV的Mat对象</li>\n<li>返回 {Image}</li>\n</ul>\n<p>把Mat对象转换为Image对象.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "mat"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "找图找色",
          "name": "找图找色",
          "type": "method",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`landscape` {boolean} 布尔值,  表示将要执行的截屏是否为横屏. 如果landscape为false, 则表示竖屏截图; true为横屏截图. ",
                  "name": "landscape",
                  "type": "boolean",
                  "desc": "布尔值,  表示将要执行的截屏是否为横屏. 如果landscape为false, 则表示竖屏截图; true为横屏截图.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "landscape",
                  "optional": true
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>向系统申请屏幕截图权限, 返回是否请求成功.</p>\n<p>第一次使用该函数会弹出截图权限请求, 建议选择“总是允许”.</p>\n<p>这个函数只是申请截图权限, 并不会真正执行截图, 真正的截图函数是<code>captureScreen()</code>.</p>\n<p>该函数在截图脚本中只需执行一次, 而无需每次调用<code>captureScreen()</code>都调用一次.</p>\n<p><strong>如果不指定landscape值, 则截图方向由当前设备屏幕方向决定</strong>, 因此务必注意执行该函数时的屏幕方向.</p>\n<p>建议在本软件界面运行该函数, 在其他软件界面运行时容易出现一闪而过的黑屏现象.</p>\n<p>示例:</p>\n<pre><code>//请求截图\nif(!requestScreenCapture()){\n    toast(&quot;请求截图失败&quot;);\n    exit();\n}\n//连续截图10张图片(间隔1秒)并保存到存储卡目录\nfor(var i = 0; i &lt; 10; i++){\n    captureScreen(&quot;/sdcard/screencapture&quot; + i + &quot;.png&quot;);\n    sleep(1000);\n}\n\n</code></pre><p>该函数也可以作为全局函数使用.</p>\n"
        },
        {
          "textRaw": "images.requestScreenCapture([landscape])",
          "type": "method",
          "name": "requestScreenCapture",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`landscape` {boolean} 布尔值,  表示将要执行的截屏是否为横屏. 如果landscape为false, 则表示竖屏截图; true为横屏截图. ",
                  "name": "landscape",
                  "type": "boolean",
                  "desc": "布尔值,  表示将要执行的截屏是否为横屏. 如果landscape为false, 则表示竖屏截图; true为横屏截图.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "landscape",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>向系统申请屏幕截图权限, 返回是否请求成功.</p>\n<p>第一次使用该函数会弹出截图权限请求, 建议选择“总是允许”.</p>\n<p>这个函数只是申请截图权限, 并不会真正执行截图, 真正的截图函数是<code>captureScreen()</code>.</p>\n<p>该函数在截图脚本中只需执行一次, 而无需每次调用<code>captureScreen()</code>都调用一次.</p>\n<p><strong>如果不指定landscape值, 则截图方向由当前设备屏幕方向决定</strong>, 因此务必注意执行该函数时的屏幕方向.</p>\n<p>建议在本软件界面运行该函数, 在其他软件界面运行时容易出现一闪而过的黑屏现象.</p>\n<p>示例:</p>\n<pre><code>//请求截图\nif(!requestScreenCapture()){\n    toast(&quot;请求截图失败&quot;);\n    exit();\n}\n//连续截图10张图片(间隔1秒)并保存到存储卡目录\nfor(var i = 0; i &lt; 10; i++){\n    captureScreen(&quot;/sdcard/screencapture&quot; + i + &quot;.png&quot;);\n    sleep(1000);\n}\n\n</code></pre><p>该函数也可以作为全局函数使用.</p>\n"
        },
        {
          "textRaw": "images.captureScreen()",
          "type": "method",
          "name": "captureScreen",
          "desc": "<p>截取当前屏幕并返回一个Image对象.</p>\n<p>没有截图权限时执行该函数会抛出SecurityException.</p>\n<p>该函数不会返回null, 两次调用可能返回相同的Image对象. 这是因为设备截图的更新需要一定的时间, 短时间内（一般来说是16ms）连续调用则会返回同一张截图.</p>\n<p>截图需要转换为Bitmap格式, 从而该函数执行需要一定的时间(0~20ms).</p>\n<p>另外在requestScreenCapture()执行成功后需要一定时间后才有截图可用, 因此如果立即调用captureScreen(), 会等待一定时间后(一般为几百ms)才返回截图.</p>\n<p>例子:</p>\n<pre><code>//请求横屏截图\nrequestScreenCapture(true);\n//截图\nvar img = captureScreen();\n//获取在点(100, 100)的颜色值\nvar color = images.pixel(img, 100, 100);\n//显示该颜色值\ntoast(colors.toString(color));\n</code></pre><p>该函数也可以作为全局函数使用.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "images.captureScreen(path)",
          "type": "method",
          "name": "captureScreen",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 截图保存路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "截图保存路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>截取当前屏幕并以PNG格式保存到path中. 如果文件不存在会被创建；文件存在会被覆盖.</p>\n<p>该函数不会返回任何值. 该函数也可以作为全局函数使用.</p>\n"
        },
        {
          "textRaw": "images.pixel(image, x, y)",
          "type": "method",
          "name": "pixel",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`image` {Image} 图片 ",
                  "name": "image",
                  "type": "Image",
                  "desc": "图片"
                },
                {
                  "textRaw": "`x` {number} 要获取的像素的横坐标. ",
                  "name": "x",
                  "type": "number",
                  "desc": "要获取的像素的横坐标."
                },
                {
                  "textRaw": "`y` {number} 要获取的像素的纵坐标. ",
                  "name": "y",
                  "type": "number",
                  "desc": "要获取的像素的纵坐标."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "image"
                },
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ],
          "desc": "<p>返回图片image在点(x, y)处的像素的ARGB值.</p>\n<p>该值的格式为0xAARRGGBB, 是一个&quot;32位整数&quot;(虽然JavaScript中并不区分整数类型和其他数值类型).</p>\n<p>坐标系以图片左上角为原点. 以图片左侧边为y轴, 上侧边为x轴.</p>\n"
        },
        {
          "textRaw": "images.findColor(image, color, options)",
          "type": "method",
          "name": "findColor",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`image` {Image} 图片 ",
                  "name": "image",
                  "type": "Image",
                  "desc": "图片"
                },
                {
                  "textRaw": "`color` {number} | {string} 要寻找的颜色的RGB值. 如果是一个整数, 则以0xRRGGBB的形式代表RGB值（A通道会被忽略）；如果是字符串, 则以\"#RRGGBB\"代表其RGB值. ",
                  "name": "color",
                  "type": "number",
                  "desc": "| {string} 要寻找的颜色的RGB值. 如果是一个整数, 则以0xRRGGBB的形式代表RGB值（A通道会被忽略）；如果是字符串, 则以\"#RRGGBB\"代表其RGB值."
                },
                {
                  "textRaw": "`options` {Object} 选项 ",
                  "name": "options",
                  "type": "Object",
                  "desc": "选项"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "image"
                },
                {
                  "name": "color"
                },
                {
                  "name": "options"
                }
              ]
            }
          ],
          "desc": "<p>在图片中寻找颜色color. 找到时返回找到的点Point, 找不到时返回null.</p>\n<p>选项包括：</p>\n<ul>\n<li><code>region</code> {Array} 找色区域. 是一个两个或四个元素的数组. (region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高. 如果只有region只有两个元素, 则找色区域为(region[0], region[1])到屏幕右下角. 如果不指定region选项, 则找色区域为整张图片.</li>\n<li><code>threshold</code> {number} 找色时颜色相似度的临界值, 范围为0~255（越小越相似, 0为颜色相等, 255为任何颜色都能匹配）. 默认为4. threshold和浮点数相似度(0.0~1.0)的换算为 similarity = (255 - threshold) / 255.</li>\n</ul>\n<p>该函数也可以作为全局函数使用.</p>\n<p>一个循环找色的例子如下：</p>\n<pre><code>requestScreenCapture();\n\n//循环找色, 找到红色(#ff0000)时停止并报告坐标\nwhile(true){\n    var img = captureScreen();\n    var point = findColor(img, &quot;#ff0000&quot;);\n    if(point){\n        toast(&quot;找到红色, 坐标为(&quot; + point.x + &quot;, &quot; + point.y + &quot;)&quot;);\n    }\n}\n\n</code></pre><p>一个区域找色的例子如下：</p>\n<pre><code>//读取本地图片/sdcard/1.png\nvar img = images.read(&quot;/sdcard/1.png&quot;);\n//判断图片是否加载成功\nif(!img){\n    toast(&quot;没有该图片&quot;);\n    exit();\n}\n//在该图片中找色, 指定找色区域为在位置(400, 500)的宽为300长为200的区域, 指定找色临界值为4\nvar point = findColor(img, &quot;#00ff00&quot;, {\n     region: [400, 500, 300, 200],\n     threshold: 4\n });\nif(point){\n    toast(&quot;找到啦:&quot; + point);\n}else{\n    toast(&quot;没找到&quot;);\n}\n</code></pre>"
        },
        {
          "textRaw": "images.findColorInRegion(img, color, x, y[, width, height, threshold])",
          "type": "method",
          "name": "findColorInRegion",
          "desc": "<p>区域找色的简便方法.</p>\n<p>相当于</p>\n<pre><code>images.findColor(img, color, {\n     region: [x, y, width, height],\n     threshold: threshold\n});\n</code></pre><p>该函数也可以作为全局函数使用.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "color"
                },
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "width",
                  "optional": true
                },
                {
                  "name": "height",
                  "optional": true
                },
                {
                  "name": "threshold",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.findColorEquals(img, color[, x, y, width, height])",
          "type": "method",
          "name": "findColorEquals",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`img` {Image} 图片 ",
                  "name": "img",
                  "type": "Image",
                  "desc": "图片"
                },
                {
                  "textRaw": "`color` {number} | {string} 要寻找的颜色 ",
                  "name": "color",
                  "type": "number",
                  "desc": "| {string} 要寻找的颜色"
                },
                {
                  "textRaw": "`x` {number} 找色区域的左上角横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "找色区域的左上角横坐标",
                  "optional": true
                },
                {
                  "textRaw": "`y` {number} 找色区域的左上角纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "找色区域的左上角纵坐标",
                  "optional": true
                },
                {
                  "textRaw": "`width` {number} 找色区域的宽度 ",
                  "name": "width",
                  "type": "number",
                  "desc": "找色区域的宽度",
                  "optional": true
                },
                {
                  "textRaw": "`height` {number} 找色区域的高度 ",
                  "name": "height",
                  "type": "number",
                  "desc": "找色区域的高度",
                  "optional": true
                },
                {
                  "textRaw": "返回 {Point} ",
                  "name": "返回",
                  "type": "Point"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "color"
                },
                {
                  "name": "x",
                  "optional": true
                },
                {
                  "name": "y",
                  "optional": true
                },
                {
                  "name": "width",
                  "optional": true
                },
                {
                  "name": "height",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>在图片img指定区域中找到颜色和color完全相等的某个点, 并返回该点的左边；如果没有找到, 则返回<code>null</code>.</p>\n<p>找色区域通过<code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>指定, 如果不指定找色区域, 则在整张图片中寻找.</p>\n<p>该函数也可以作为全局函数使用.</p>\n<p>示例：\n(通过找QQ红点的颜色来判断是否有未读消息)</p>\n<pre><code>requestScreenCapture();\nlaunchApp(&quot;QQ&quot;);\nsleep(1200);\nvar p = findColorEquals(captureScreen(), &quot;#f64d30&quot;);\nif(p){\n    toast(&quot;有未读消息&quot;);\n}else{\n    toast(&quot;没有未读消息&quot;);\n}\n</code></pre>"
        },
        {
          "textRaw": "images.findMultiColors(img, firstColor, colors[, options])",
          "type": "method",
          "name": "findMultiColors",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`img` {Image} 要找色的图片 ",
                  "name": "img",
                  "type": "Image",
                  "desc": "要找色的图片"
                },
                {
                  "textRaw": "`firstColor` {number} | {string} 第一个点的颜色 ",
                  "name": "firstColor",
                  "type": "number",
                  "desc": "| {string} 第一个点的颜色"
                },
                {
                  "textRaw": "`colors` {Array} 表示剩下的点相对于第一个点的位置和颜色的数组, 数组的每个元素为[x, y, color] ",
                  "name": "colors",
                  "type": "Array",
                  "desc": "表示剩下的点相对于第一个点的位置和颜色的数组, 数组的每个元素为[x, y, color]"
                },
                {
                  "textRaw": "`options` {Object} 选项, 包括： ",
                  "options": [
                    {
                      "textRaw": "`region` {Array} 找色区域. 是一个两个或四个元素的数组. (region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高. 如果只有region只有两个元素, 则找色区域为(region[0], region[1])到屏幕右下角. 如果不指定region选项, 则找色区域为整张图片. ",
                      "name": "region",
                      "type": "Array",
                      "desc": "找色区域. 是一个两个或四个元素的数组. (region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高. 如果只有region只有两个元素, 则找色区域为(region[0], region[1])到屏幕右下角. 如果不指定region选项, 则找色区域为整张图片."
                    },
                    {
                      "textRaw": "`threshold` {number} 找色时颜色相似度的临界值, 范围为0~255（越小越相似, 0为颜色相等, 255为任何颜色都能匹配）. 默认为4. threshold和浮点数相似度(0.0~1.0)的换算为 similarity = (255 - threshold) / 255. ",
                      "name": "threshold",
                      "type": "number",
                      "desc": "找色时颜色相似度的临界值, 范围为0~255（越小越相似, 0为颜色相等, 255为任何颜色都能匹配）. 默认为4. threshold和浮点数相似度(0.0~1.0)的换算为 similarity = (255 - threshold) / 255."
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "desc": "选项, 包括：",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "firstColor"
                },
                {
                  "name": "colors"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>多点找色, 类似于按键精灵的多点找色, 其过程如下：</p>\n<ol>\n<li>在图片img中找到颜色firstColor的位置(x0, y0)</li>\n<li>对于数组colors的每个元素[x, y, color], 检查图片img在位置(x + x0, y + y0)上的像素是否是颜色color, 是的话返回(x0, y0), 否则继续寻找firstColor的位置, 重新执行第1步</li>\n<li>整张图片都找不到时返回<code>null</code></li>\n</ol>\n<p>例如, 对于代码<code>images.findMultiColors(img, &quot;#123456&quot;, [[10, 20, &quot;#ffffff&quot;], [30, 40, &quot;#000000&quot;]])</code>, 假设图片在(100, 200)的位置的颜色为#123456, 这时如果(110, 220)的位置的颜色为#fffff且(130, 240)的位置的颜色为#000000, 则函数返回点(100, 200).</p>\n<p>如果要指定找色区域, 则在options中指定, 例如:</p>\n<pre><code>var p = images.findMultiColors(img, &quot;#123456&quot;, [[10, 20, &quot;#ffffff&quot;], [30, 40, &quot;#000000&quot;]], {\n    region: [0, 960, 1080, 960]\n});\n</code></pre>"
        },
        {
          "textRaw": "images.detectsColor(image, color, x, y[, threshold = 16, algorithm = \"diff\"])",
          "type": "method",
          "name": "detectsColor",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`image` {Image} 图片 ",
                  "name": "image",
                  "type": "Image",
                  "desc": "图片"
                },
                {
                  "textRaw": "`color` {number} | {string} 要检测的颜色 ",
                  "name": "color",
                  "type": "number",
                  "desc": "| {string} 要检测的颜色"
                },
                {
                  "textRaw": "`x` {number} 要检测的位置横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "要检测的位置横坐标"
                },
                {
                  "textRaw": "`y` {number} 要检测的位置纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "要检测的位置纵坐标"
                },
                {
                  "textRaw": "`threshold` {number} 颜色相似度临界值, 默认为16. 取值范围为0~255. ",
                  "name": "threshold",
                  "type": "number",
                  "desc": "颜色相似度临界值, 默认为16. 取值范围为0~255.",
                  "optional": true,
                  "default": " 16"
                },
                {
                  "textRaw": "`algorithm` {string} 颜色匹配算法, 包括: ",
                  "options": [
                    {
                      "textRaw": "\"equal\": 相等匹配, 只有与给定颜色color完全相等时才匹配. ",
                      "name": "equal",
                      "desc": "相等匹配, 只有与给定颜色color完全相等时才匹配."
                    },
                    {
                      "textRaw": "\"diff\": 差值匹配. 与给定颜色的R、G、B差的绝对值之和小于threshold时匹配. ",
                      "name": "diff",
                      "desc": "差值匹配. 与给定颜色的R、G、B差的绝对值之和小于threshold时匹配."
                    },
                    {
                      "textRaw": "\"rgb\": rgb欧拉距离相似度. 与给定颜色color的rgb欧拉距离小于等于threshold时匹配. ",
                      "name": "rgb",
                      "desc": "rgb欧拉距离相似度. 与给定颜色color的rgb欧拉距离小于等于threshold时匹配."
                    },
                    {
                      "textRaw": "\"rgb+\": 加权rgb欧拉距离匹配([LAB Delta E](https://en.wikipedia.org/wiki/Color_difference/)). ",
                      "name": "rgb+",
                      "desc": "加权rgb欧拉距离匹配([LAB Delta E](https://en.wikipedia.org/wiki/Color_difference/))."
                    },
                    {
                      "textRaw": "\"hs\": hs欧拉距离匹配. hs为HSV空间的色调值. ",
                      "name": "hs",
                      "desc": "hs欧拉距离匹配. hs为HSV空间的色调值."
                    }
                  ],
                  "name": "algorithm",
                  "type": "string",
                  "desc": "颜色匹配算法, 包括:",
                  "optional": true,
                  "default": " \"diff\""
                }
              ]
            },
            {
              "params": [
                {
                  "name": "image"
                },
                {
                  "name": "color"
                },
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "threshold ",
                  "optional": true,
                  "default": " 16"
                },
                {
                  "name": "algorithm ",
                  "optional": true,
                  "default": " \"diff\""
                }
              ]
            }
          ],
          "desc": "<p>返回图片image在位置(x, y)处是否匹配到颜色color. 用于检测图片中某个位置是否是特定颜色.</p>\n<p>一个判断微博客户端的某个微博是否被点赞过的例子：</p>\n<pre><code>requestScreenCapture();\n//找到点赞控件\nvar like = id(&quot;ly_feed_like_icon&quot;).findOne();\n//获取该控件中点坐标\nvar x = like.bounds().centerX();\nvar y = like.bounds().centerY();\n//截图\nvar img = captureScreen();\n//判断在该坐标的颜色是否为橙红色\nif(images.detectsColor(img, &quot;#fed9a8&quot;, x, y)){\n    //是的话则已经是点赞过的了, 不做任何动作\n}else{\n    //否则点击点赞按钮\n    like.click();\n}\n</code></pre>"
        },
        {
          "textRaw": "images.findImage(img, template[, options])",
          "type": "method",
          "name": "findImage",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`img` {Image} 大图片 ",
                  "name": "img",
                  "type": "Image",
                  "desc": "大图片"
                },
                {
                  "textRaw": "`template` {Image} 小图片（模板） ",
                  "name": "template",
                  "type": "Image",
                  "desc": "小图片（模板）"
                },
                {
                  "textRaw": "`options` {Object} 找图选项 ",
                  "name": "options",
                  "type": "Object",
                  "desc": "找图选项",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "template"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>找图. 在大图片img中查找小图片template的位置（模块匹配）, 找到时返回位置坐标(Point), 找不到时返回null.</p>\n<p>选项包括：</p>\n<ul>\n<li><code>threshold</code> {number} 图片相似度. 取值范围为0~1的浮点数. 默认值为0.9.</li>\n<li><code>region</code> {Array} 找图区域. 参见findColor函数关于region的说明.</li>\n<li><code>level</code> {number} <strong>一般而言不必修改此参数</strong>. 不加此参数时该参数会根据图片大小自动调整. 找图算法是采用图像金字塔进行的, level参数表示金字塔的层次, level越大可能带来越高的找图效率, 但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置. 因此, 除非您清楚该参数的意义并需要进行性能调优, 否则不需要用到该参数.</li>\n</ul>\n<p>该函数也可以作为全局函数使用.</p>\n<p>一个最简单的找图例子如下：</p>\n<pre><code>var img = images.read(&quot;/sdcard/大图.png&quot;);\nvar templ = images.read(&quot;/sdcard/小图.png&quot;);\nvar p = findImage(img, templ);\nif(p){\n    toast(&quot;找到啦:&quot; + p);\n}else{\n    toast(&quot;没找到&quot;);\n}\n</code></pre><p>稍微复杂点的区域找图例子如下：</p>\n<pre><code>auto();\nrequestScreenCapture();\nvar wx = images.read(&quot;/sdcard/微信图标.png&quot;);\n//返回桌面\nhome();\n//截图并找图\nvar p = findImage(captureScreen(), wx, {\n    region: [0, 50],\n    threshold: 0.8\n});\nif(p){\n    toast(&quot;在桌面找到了微信图标啦: &quot; + p);\n}else{\n    toast(&quot;在桌面没有找到微信图标&quot;);\n}\n</code></pre>"
        },
        {
          "textRaw": "images.findImageInRegion(img, template, x, y[, width, height, threshold])",
          "type": "method",
          "name": "findImageInRegion",
          "desc": "<p>区域找图的简便方法. 相当于：</p>\n<pre><code>images.findImage(img, template, {\n    region: [x, y, width, height],\n    threshold: threshold\n})\n</code></pre><p>该函数也可以作为全局函数使用.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "template"
                },
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "width",
                  "optional": true
                },
                {
                  "name": "height",
                  "optional": true
                },
                {
                  "name": "threshold",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "images.matchTemplate(img, template, options)",
          "type": "method",
          "name": "matchTemplate",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>img</code> {Image} 大图片</li>\n<li><code>template</code> {Image} 小图片（模板）</li>\n<li><code>options</code> {Object} 找图选项：<ul>\n<li><code>threshold</code> {number} 图片相似度. 取值范围为0~1的浮点数. 默认值为0.9.</li>\n<li><code>region</code> {Array} 找图区域. 参见findColor函数关于region的说明.</li>\n<li><code>max</code> {number} 找图结果最大数量, 默认为5</li>\n<li><code>level</code> {number} <strong>一般而言不必修改此参数</strong>. 不加此参数时该参数会根据图片大小自动调整. 找图算法是采用图像金字塔进行的, level参数表示金字塔的层次, level越大可能带来越高的找图效率, 但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置. 因此, 除非您清楚该参数的意义并需要进行性能调优, 否则不需要用到该参数.</li>\n</ul>\n</li>\n<li>返回 {MatchingResult}</li>\n</ul>\n<p>在大图片中搜索小图片, 并返回搜索结果MatchingResult. 该函数可以用于找图时找出多个位置, 可以通过max参数控制最大的结果数量. 也可以对匹配结果进行排序、求最值等操作.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "img"
                },
                {
                  "name": "template"
                },
                {
                  "name": "options"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "图像 (Images)"
    },
    {
      "textRaw": "MatchingResult",
      "name": "matchingresult",
      "desc": "<p><strong>[v4.1.0新增]</strong></p>\n",
      "modules": [
        {
          "textRaw": "matches",
          "name": "matches",
          "desc": "<ul>\n<li>{Array} 匹配结果的数组.</li>\n</ul>\n<p>数组的元素是一个Match对象：</p>\n<ul>\n<li><code>point</code> {Point} 匹配位置</li>\n<li><code>similarity</code> {number} 相似度</li>\n</ul>\n<p>例如:</p>\n<pre><code>var result = images.matchTemplate(img, template, {\n    max: 100\n});\nresult.matches.forEach(match =&gt; {\n    log(&quot;point = &quot; + match.point + &quot;, similarity = &quot; + match.similarity);\n});\n</code></pre>",
          "type": "module",
          "displayName": "matches"
        }
      ],
      "methods": [
        {
          "textRaw": "points",
          "name": "points",
          "desc": "<ul>\n<li>{Array} 匹配位置的数组.</li>\n</ul>\n",
          "type": "method",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            },
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "first()",
          "type": "method",
          "name": "first",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>第一个匹配结果. 如果没有任何匹配, 则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "last()",
          "type": "method",
          "name": "last",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>最后一个匹配结果. 如果没有任何匹配, 则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "leftmost()",
          "type": "method",
          "name": "leftmost",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>位于大图片最左边的匹配结果. 如果没有任何匹配, 则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "topmost()",
          "type": "method",
          "name": "topmost",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>位于大图片最上边的匹配结果. 如果没有任何匹配, 则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "rightmost()",
          "type": "method",
          "name": "rightmost",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>位于大图片最右边的匹配结果. 如果没有任何匹配, 则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "bottommost()",
          "type": "method",
          "name": "bottommost",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>位于大图片最下边的匹配结果. 如果没有任何匹配, 则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "best()",
          "type": "method",
          "name": "best",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>相似度最高的匹配结果. 如果没有任何匹配, 则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "worst()",
          "type": "method",
          "name": "worst",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Match} ",
                  "name": "返回",
                  "type": "Match"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>相似度最低的匹配结果. 如果没有任何匹配, 则返回<code>null</code>.</p>\n"
        },
        {
          "textRaw": "sortBy(cmp)",
          "type": "method",
          "name": "sortBy",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "cmp {Function}|{string} 比较函数, 或者是一个字符串表示排序方向. 例如\"left\"表示将匹配结果按匹配位置从左往右排序、\"top\"表示将匹配结果按匹配位置从上往下排序, \"left-top\"表示将匹配结果按匹配位置从左往右、从上往下排序. 方向包括`left`（左）, `top` （上）, `right` （右）, `bottom`（下）. ",
                  "name": "cmp",
                  "type": "Function",
                  "desc": "|{string} 比较函数, 或者是一个字符串表示排序方向. 例如\"left\"表示将匹配结果按匹配位置从左往右排序、\"top\"表示将匹配结果按匹配位置从上往下排序, \"left-top\"表示将匹配结果按匹配位置从左往右、从上往下排序. 方向包括`left`（左）, `top` （上）, `right` （右）, `bottom`（下）."
                },
                {
                  "textRaw": "{MatchingResult} ",
                  "type": "MatchingResult"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "cmp"
                }
              ]
            }
          ],
          "desc": "<p>对匹配结果进行排序, 并返回排序后的结果.</p>\n<pre><code>var result = images.matchTemplate(img, template, {\n    max: 100\n});\nlog(result.sortBy(&quot;top-right&quot;));\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "MatchingResult"
    },
    {
      "textRaw": "Image",
      "name": "image",
      "desc": "<p>表示一张图片, 可以是截图的图片, 或者本地读取的图片, 或者从网络获取的图片.</p>\n",
      "methods": [
        {
          "textRaw": "Image.getWidth()",
          "type": "method",
          "name": "getWidth",
          "desc": "<p>返回以像素为单位图片宽度.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Image.getHeight()",
          "type": "method",
          "name": "getHeight",
          "desc": "<p>返回以像素为单位的图片高度.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Image.saveTo(path)",
          "type": "method",
          "name": "saveTo",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>把图片保存到路径path. （如果文件存在则覆盖）</p>\n"
        },
        {
          "textRaw": "Image.pixel(x, y)",
          "type": "method",
          "name": "pixel",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "横坐标"
                },
                {
                  "textRaw": "`y` {number} 纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "纵坐标"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ],
          "desc": "<p>返回图片image在点(x, y)处的像素的ARGB值.</p>\n<p>该值的格式为0xAARRGGBB, 是一个&quot;32位整数&quot;(虽然JavaScript中并不区分整数类型和其他数值类型).</p>\n<p>坐标系以图片左上角为原点. 以图片左侧边为y轴, 上侧边为x轴.</p>\n<p>##</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Image"
    },
    {
      "textRaw": "Point",
      "name": "point",
      "desc": "<p>findColor, findImage返回的对象. 表示一个点（坐标）.</p>\n",
      "properties": [
        {
          "textRaw": "Point.x",
          "name": "x",
          "desc": "<p>横坐标.</p>\n"
        },
        {
          "textRaw": "Point.y",
          "name": "y",
          "desc": "<p>纵坐标.</p>\n<!-- [end-include:image.md] -->\n<!-- [start-include:keys.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "Point"
    },
    {
      "textRaw": "按键 (Keys)",
      "name": "按键_(keys)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>按键模拟部分提供了一些模拟物理按键的全局函数, 包括Home、音量键、照相键等, 有的函数依赖于无障碍服务, 有的函数依赖于root权限.</p>\n<p>一般来说, 以大写字母开头的函数都依赖于root权限. 执行此类函数时, 如果没有root权限, 则函数执行后没有效果, 并会在控制台输出一个警告.</p>\n",
      "methods": [
        {
          "textRaw": "back()",
          "type": "method",
          "name": "back",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>模拟按下返回键. 返回是否执行成功.\n此函数依赖于无障碍服务.</p>\n"
        },
        {
          "textRaw": "home()",
          "type": "method",
          "name": "home",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>模拟按下Home键. 返回是否执行成功.\n此函数依赖于无障碍服务.</p>\n"
        },
        {
          "textRaw": "powerDialog()",
          "type": "method",
          "name": "powerDialog",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>弹出电源键菜单. 返回是否执行成功.\n此函数依赖于无障碍服务.</p>\n"
        },
        {
          "textRaw": "notifications()",
          "type": "method",
          "name": "notifications",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>拉出通知栏. 返回是否执行成功.\n此函数依赖于无障碍服务.</p>\n"
        },
        {
          "textRaw": "quickSettings()",
          "type": "method",
          "name": "quickSettings",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>显示快速设置(下拉通知栏到底). 返回是否执行成功.\n此函数依赖于无障碍服务.</p>\n"
        },
        {
          "textRaw": "recents()",
          "type": "method",
          "name": "recents",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>显示最近任务. 返回是否执行成功.\n此函数依赖于无障碍服务.</p>\n"
        },
        {
          "textRaw": "splitScreen()",
          "type": "method",
          "name": "splitScreen",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>分屏. 返回是否执行成功.\n此函数依赖于无障碍服务, 并且需要系统自身功能的支持.</p>\n"
        },
        {
          "textRaw": "Home()",
          "type": "method",
          "name": "Home",
          "desc": "<p>模拟按下Home键.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Back()",
          "type": "method",
          "name": "Back",
          "desc": "<p>模拟按下返回键.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Power()",
          "type": "method",
          "name": "Power",
          "desc": "<p>模拟按下电源键.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Menu()",
          "type": "method",
          "name": "Menu",
          "desc": "<p>模拟按下菜单键.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "VolumeUp()",
          "type": "method",
          "name": "VolumeUp",
          "desc": "<p>按下音量上键.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "VolumeDown()",
          "type": "method",
          "name": "VolumeDown",
          "desc": "<p>按键音量上键.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Camera()",
          "type": "method",
          "name": "Camera",
          "desc": "<p>模拟按下照相键.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Up()",
          "type": "method",
          "name": "Up",
          "desc": "<p>模拟按下物理按键上.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Down()",
          "type": "method",
          "name": "Down",
          "desc": "<p>模拟按下物理按键下.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Left()",
          "type": "method",
          "name": "Left",
          "desc": "<p>模拟按下物理按键左.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Right()",
          "type": "method",
          "name": "Right",
          "desc": "<p>模拟按下物理按键右.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "OK()",
          "type": "method",
          "name": "OK",
          "desc": "<p>模拟按下物理按键确定.\n此函数依赖于root权限.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Text(text)",
          "type": "method",
          "name": "Text",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "text {string} 要输入的文字, 只能为英文或英文符号 输入文字text. 例如`Text(\"aaa\");` ",
                  "name": "text",
                  "type": "string",
                  "desc": "要输入的文字, 只能为英文或英文符号 输入文字text. 例如`Text(\"aaa\");`"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "text"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "KeyCode(code)",
          "type": "method",
          "name": "KeyCode",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "code {number} | <String> 要按下的按键的数字代码或名称. 参见下表. 模拟物理按键. 例如`KeyCode(29)`和`KeyCode(\"KEYCODE_A\")`是按下A键. ",
                  "name": "code",
                  "type": "number",
                  "desc": "| <String> 要按下的按键的数字代码或名称. 参见下表. 模拟物理按键. 例如`KeyCode(29)`和`KeyCode(\"KEYCODE_A\")`是按下A键."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "code"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "按键 (Keys)"
    },
    {
      "textRaw": "附录: KeyCode对照表",
      "name": "附录:_keycode对照表",
      "desc": "<p>KeyCode KeyEvent Value</p>\n<ul>\n<li>KEYCODE_MENU 1</li>\n<li>KEYCODE_SOFT_RIGHT 2</li>\n<li>KEYCODE_HOME 3</li>\n<li>KEYCODE_BACK 4</li>\n<li>KEYCODE_CALL 5</li>\n<li>KEYCODE_ENDCALL 6</li>\n<li>KEYCODE_0 7</li>\n<li>KEYCODE_1 8</li>\n<li>KEYCODE_2 9</li>\n<li>KEYCODE_3 10</li>\n<li>KEYCODE_4 11</li>\n<li>KEYCODE_5 12</li>\n<li>KEYCODE_6 13</li>\n<li>KEYCODE_7 14</li>\n<li>KEYCODE_8 15</li>\n<li>KEYCODE_9 16</li>\n<li>KEYCODE_STAR 17</li>\n<li>KEYCODE_POUND 18</li>\n<li>KEYCODE_DPAD_UP 19</li>\n<li>KEYCODE_DPAD_DOWN 20</li>\n<li>KEYCODE_DPAD_LEFT 21</li>\n<li>KEYCODE_DPAD_RIGHT 22</li>\n<li>KEYCODE_DPAD_CENTER 23</li>\n<li>KEYCODE_VOLUME_UP 24</li>\n<li>KEYCODE_VOLUME_DOWN 25</li>\n<li>KEYCODE_POWER 26</li>\n<li>KEYCODE_CAMERA 27</li>\n<li>KEYCODE_CLEAR 28</li>\n<li>KEYCODE_A 29</li>\n<li>KEYCODE_B 30</li>\n<li>KEYCODE_C 31</li>\n<li>KEYCODE_D 32</li>\n<li>KEYCODE_E 33</li>\n<li>KEYCODE_F 34</li>\n<li>KEYCODE_G 35</li>\n<li>KEYCODE_H 36</li>\n<li>KEYCODE_I 37</li>\n<li>KEYCODE_J 38</li>\n<li>KEYCODE_K 39</li>\n<li>KEYCODE_L 40</li>\n<li>KEYCODE_M 41</li>\n<li>KEYCODE_N 42</li>\n<li>KEYCODE_O 43</li>\n<li>KEYCODE_P 44</li>\n<li>KEYCODE_Q 45</li>\n<li>KEYCODE_R 46</li>\n<li>KEYCODE_S 47</li>\n<li>KEYCODE_T 48</li>\n<li>KEYCODE_U 49</li>\n<li>KEYCODE_V 50</li>\n<li>KEYCODE_W 51</li>\n<li>KEYCODE_X 52</li>\n<li>KEYCODE_Y 53</li>\n<li>KEYCODE_Z 54</li>\n<li>KEYCODE_COMMA 55</li>\n<li>KEYCODE_PERIOD 56</li>\n<li>KEYCODE_ALT_LEFT 57</li>\n<li>KEYCODE_ALT_RIGHT 58</li>\n<li>KEYCODE_SHIFT_LEFT 59</li>\n<li>KEYCODE_SHIFT_RIGHT 60</li>\n<li>KEYCODE_TAB 61</li>\n<li>KEYCODE_SPACE 62</li>\n<li>KEYCODE_SYM 63</li>\n<li>KEYCODE_EXPLORER 64</li>\n<li>KEYCODE_ENVELOPE 65</li>\n<li>KEYCODE_ENTER 66</li>\n<li>KEYCODE_DEL 67</li>\n<li>KEYCODE_GRAVE 68</li>\n<li>KEYCODE_MINUS 69</li>\n<li>KEYCODE_EQUALS 70</li>\n<li>KEYCODE_LEFT_BRACKET 71</li>\n<li>KEYCODE_RIGHT_BRACKET 72</li>\n<li>KEYCODE_BACKSLASH 73</li>\n<li>KEYCODE_SEMICOLON 74</li>\n<li>KEYCODE_APOSTROPHE 75</li>\n<li>KEYCODE_SLASH 76</li>\n<li>KEYCODE_AT 77</li>\n<li>KEYCODE_NUM 78</li>\n<li>KEYCODE_HEADSETHOOK 79</li>\n<li>KEYCODE_FOCUS 80</li>\n<li>KEYCODE_PLUS 81</li>\n<li>KEYCODE_MENU 82</li>\n<li>KEYCODE_NOTIFICATION 83</li>\n<li>KEYCODE_SEARCH 84</li>\n<li>TAG_LAST_ KEYCODE 85  </li>\n</ul>\n<!-- [end-include:keys.md] -->\n<!-- [start-include:device.md] -->\n",
      "type": "module",
      "displayName": "附录: KeyCode对照表"
    },
    {
      "textRaw": "设备 (Device)",
      "name": "设备_(device)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>device模块提供了与设备有关的信息与操作, 例如获取设备宽高, 内存使用率, IMEI, 调整设备亮度、音量等.</p>\n<p>此模块的部分函数, 例如调整音量, 需要&quot;修改系统设置&quot;的权限. 如果没有该权限, 会抛出<code>SecurityException</code>并跳转到权限设置界面.</p>\n",
      "properties": [
        {
          "textRaw": "`width` {number} ",
          "type": "number",
          "name": "width",
          "desc": "<p>设备屏幕分辨率宽度. 例如1080.</p>\n"
        },
        {
          "textRaw": "`height` {number} ",
          "type": "number",
          "name": "height",
          "desc": "<p>设备屏幕分辨率高度. 例如1920.</p>\n"
        },
        {
          "textRaw": "`buildId` {string} ",
          "type": "string",
          "name": "buildId",
          "desc": "<p>Either a changelist number, or a label like &quot;M4-rc20&quot;.</p>\n<p>修订版本号, 或者诸如&quot;M4-rc20&quot;的标识.</p>\n"
        },
        {
          "textRaw": "`broad` {string} ",
          "type": "string",
          "name": "broad",
          "desc": "<p>The name of the underlying board, like &quot;goldfish&quot;.</p>\n<p>设备的主板(?)型号.</p>\n"
        },
        {
          "textRaw": "`brand` {string} ",
          "type": "string",
          "name": "brand",
          "desc": "<p>The consumer-visible brand with which the product/hardware will be associated, if any.</p>\n<p>与产品或硬件相关的厂商品牌, 如&quot;Xiaomi&quot;, &quot;Huawei&quot;等.</p>\n"
        },
        {
          "textRaw": "`device` {string} ",
          "type": "string",
          "name": "device",
          "desc": "<p>The name of the industrial design.</p>\n<p>设备在工业设计中的名称.</p>\n"
        },
        {
          "textRaw": "`model` {string} ",
          "type": "string",
          "name": "model",
          "desc": "<p>The end-user-visible name for the end product.</p>\n<p>设备型号.</p>\n"
        },
        {
          "textRaw": "`product` {string} ",
          "type": "string",
          "name": "product",
          "desc": "<p>The name of the overall product.</p>\n<p>整个产品的名称.</p>\n"
        },
        {
          "textRaw": "`bootloader` {string} ",
          "type": "string",
          "name": "bootloader",
          "desc": "<p>The system bootloader version number.</p>\n<p>设备Bootloader的版本.</p>\n"
        },
        {
          "textRaw": "`hardware` {string} ",
          "type": "string",
          "name": "hardware",
          "desc": "<p>The name of the hardware (from the kernel command line or /proc).</p>\n<p>设备的硬件名称(来自内核命令行或者/proc).</p>\n"
        },
        {
          "textRaw": "`fingerprint` {string} ",
          "type": "string",
          "name": "fingerprint",
          "desc": "<p>A string that uniquely identifies this build. Do not attempt to parse this value.</p>\n<p>构建(build)的唯一标识码.</p>\n"
        },
        {
          "textRaw": "`serial` {string} ",
          "type": "string",
          "name": "serial",
          "desc": "<p>A hardware serial number, if available. Alphanumeric only, case-insensitive.</p>\n<p>硬件序列号.</p>\n"
        },
        {
          "textRaw": "`sdkInt` {number} ",
          "type": "number",
          "name": "sdkInt",
          "desc": "<p>The user-visible SDK version of the framework; its possible values are defined in Build.VERSION_CODES.</p>\n<p>安卓系统API版本. 例如安卓4.4的sdkInt为19.</p>\n"
        },
        {
          "textRaw": "`incremental` {string} ",
          "type": "string",
          "name": "incremental",
          "desc": "<p>The internal value used by the underlying source control to represent this build. E.g., a perforce changelist number or a git hash.</p>\n"
        },
        {
          "textRaw": "`release` {string} ",
          "type": "string",
          "name": "release",
          "desc": "<p>The user-visible version string. E.g., &quot;1.0&quot; or &quot;3.4b5&quot;.</p>\n<p>Android系统版本号. 例如&quot;5.0&quot;, &quot;7.1.1&quot;.</p>\n"
        },
        {
          "textRaw": "`baseOS` {string} ",
          "type": "string",
          "name": "baseOS",
          "desc": "<p>The base OS build the product is based on.</p>\n"
        },
        {
          "textRaw": "`securityPatch` {string} ",
          "type": "string",
          "name": "securityPatch",
          "desc": "<p>The user-visible security patch level.</p>\n<p>安全补丁程序级别.</p>\n"
        },
        {
          "textRaw": "`codename` {string} ",
          "type": "string",
          "name": "codename",
          "desc": "<p>The current development codename, or the string &quot;REL&quot; if this is a release build.</p>\n<p>开发代号, 例如发行版是&quot;REL&quot;.</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "device.getIMEI()",
          "type": "method",
          "name": "getIMEI",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{string} ",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回设备的IMEI.</p>\n"
        },
        {
          "textRaw": "device.getAndroidId()",
          "type": "method",
          "name": "getAndroidId",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{string} ",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回设备的Android ID.</p>\n<p>Android ID为一个用16进制字符串表示的64位整数, 在设备第一次使用时随机生成, 之后不会更改, 除非恢复出厂设置.</p>\n"
        },
        {
          "textRaw": "device.getMacAddress()",
          "type": "method",
          "name": "getMacAddress",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{string} ",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回设备的Mac地址. 该函数需要在有WLAN连接的情况下才能获取, 否则会返回null.</p>\n<p><strong>可能的后续修改</strong>：未来可能增加有root权限的情况下通过root权限获取, 从而在没有WLAN连接的情况下也能返回正确的Mac地址, 因此请勿使用此函数判断WLAN连接.</p>\n"
        },
        {
          "textRaw": "device.getBrightness()",
          "type": "method",
          "name": "getBrightness",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} ",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前的(手动)亮度. 范围为0~255.</p>\n"
        },
        {
          "textRaw": "device.getBrightnessMode()",
          "type": "method",
          "name": "getBrightnessMode",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} ",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前亮度模式, 0为手动亮度, 1为自动亮度.</p>\n"
        },
        {
          "textRaw": "device.setBrightness(b)",
          "type": "method",
          "name": "setBrightness",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`b` {number} 亮度, 范围0~255 ",
                  "name": "b",
                  "type": "number",
                  "desc": "亮度, 范围0~255"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "b"
                }
              ]
            }
          ],
          "desc": "<p>设置当前手动亮度. 如果当前是自动亮度模式, 该函数不会影响屏幕的亮度.</p>\n<p>此函数需要&quot;修改系统设置&quot;的权限. 如果没有该权限, 会抛出SecurityException并跳转到权限设置界面.</p>\n"
        },
        {
          "textRaw": "device.setBrightnessMode(mode)",
          "type": "method",
          "name": "setBrightnessMode",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`mode` {number} 亮度模式, 0为手动亮度, 1为自动亮度 ",
                  "name": "mode",
                  "type": "number",
                  "desc": "亮度模式, 0为手动亮度, 1为自动亮度"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "mode"
                }
              ]
            }
          ],
          "desc": "<p>设置当前亮度模式.</p>\n<p>此函数需要&quot;修改系统设置&quot;的权限. 如果没有该权限, 会抛出SecurityException并跳转到权限设置界面.</p>\n"
        },
        {
          "textRaw": "device.getMusicVolume()",
          "type": "method",
          "name": "getMusicVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} 整数值 ",
                  "type": "number",
                  "desc": "整数值"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前媒体音量.</p>\n"
        },
        {
          "textRaw": "device.getNotificationVolume()",
          "type": "method",
          "name": "getNotificationVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} 整数值 ",
                  "type": "number",
                  "desc": "整数值"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前通知音量.</p>\n"
        },
        {
          "textRaw": "device.getAlarmVolume()",
          "type": "method",
          "name": "getAlarmVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} 整数值 ",
                  "type": "number",
                  "desc": "整数值"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前闹钟音量.</p>\n"
        },
        {
          "textRaw": "device.getMusicMaxVolume()",
          "type": "method",
          "name": "getMusicMaxVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} 整数值 ",
                  "type": "number",
                  "desc": "整数值"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回媒体音量的最大值.</p>\n"
        },
        {
          "textRaw": "device.getNotificationMaxVolume()",
          "type": "method",
          "name": "getNotificationMaxVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} 整数值 ",
                  "type": "number",
                  "desc": "整数值"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回通知音量的最大值.</p>\n"
        },
        {
          "textRaw": "device.getAlarmMaxVolume()",
          "type": "method",
          "name": "getAlarmMaxVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} 整数值 ",
                  "type": "number",
                  "desc": "整数值"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回闹钟音量的最大值.</p>\n"
        },
        {
          "textRaw": "device.setMusicVolume(volume)",
          "type": "method",
          "name": "setMusicVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`volume` {number} 音量 ",
                  "name": "volume",
                  "type": "number",
                  "desc": "音量"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "volume"
                }
              ]
            }
          ],
          "desc": "<p>设置当前媒体音量.</p>\n<p>此函数需要&quot;修改系统设置&quot;的权限. 如果没有该权限, 会抛出SecurityException并跳转到权限设置界面.</p>\n"
        },
        {
          "textRaw": "device.setNotificationVolume(volume)",
          "type": "method",
          "name": "setNotificationVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`volume` {number} 音量 ",
                  "name": "volume",
                  "type": "number",
                  "desc": "音量"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "volume"
                }
              ]
            }
          ],
          "desc": "<p>设置当前通知音量.</p>\n<p>此函数需要&quot;修改系统设置&quot;的权限. 如果没有该权限, 会抛出SecurityException并跳转到权限设置界面.</p>\n"
        },
        {
          "textRaw": "device.setAlarmVolume(volume)",
          "type": "method",
          "name": "setAlarmVolume",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`volume` {number} 音量 ",
                  "name": "volume",
                  "type": "number",
                  "desc": "音量"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "volume"
                }
              ]
            }
          ],
          "desc": "<p>设置当前闹钟音量.</p>\n<p>此函数需要&quot;修改系统设置&quot;的权限. 如果没有该权限, 会抛出SecurityException并跳转到权限设置界面.</p>\n"
        },
        {
          "textRaw": "device.getBattery()",
          "type": "method",
          "name": "getBattery",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} 0.0~100.0的浮点数 ",
                  "type": "number",
                  "desc": "0.0~100.0的浮点数"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前电量百分比.</p>\n"
        },
        {
          "textRaw": "device.isCharging()",
          "type": "method",
          "name": "isCharging",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{boolean} ",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回设备是否正在充电.</p>\n"
        },
        {
          "textRaw": "device.getTotalMem()",
          "type": "method",
          "name": "getTotalMem",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} ",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回设备内存总量, 单位字节(B). 1MB = 1024 * 1024B.</p>\n"
        },
        {
          "textRaw": "device.getAvailMem()",
          "type": "method",
          "name": "getAvailMem",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "{number} ",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回设备当前可用的内存, 单位字节(B).</p>\n"
        },
        {
          "textRaw": "device.isScreenOn()",
          "type": "method",
          "name": "isScreenOn",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回设备屏幕是否是亮着的. 如果屏幕亮着, 返回<code>true</code>; 否则返回<code>false</code>.</p>\n<p>需要注意的是, 类似于vivo xplay系列的息屏时钟不属于&quot;屏幕亮着&quot;的情况, 虽然屏幕确实亮着但只能显示时钟而且不可交互, 此时<code>isScreenOn()</code>也会返回<code>false</code>.</p>\n"
        },
        {
          "textRaw": "device.wakeUp()",
          "type": "method",
          "name": "wakeUp",
          "desc": "<p>唤醒设备. 包括唤醒设备CPU、屏幕等. 可以用来点亮屏幕.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "device.wakeUpIfNeeded()",
          "type": "method",
          "name": "wakeUpIfNeeded",
          "desc": "<p>如果屏幕没有点亮, 则唤醒设备.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "device.keepScreenOn([timeout])",
          "type": "method",
          "name": "keepScreenOn",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`timeout` {number} 屏幕保持常亮的时间, 单位毫秒. 如果不加此参数, 则一直保持屏幕常亮. ",
                  "name": "timeout",
                  "type": "number",
                  "desc": "屏幕保持常亮的时间, 单位毫秒. 如果不加此参数, 则一直保持屏幕常亮.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "timeout",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>保持屏幕常亮.</p>\n<p>此函数无法阻止用户使用锁屏键等正常关闭屏幕, 只能使得设备在无人操作的情况下保持屏幕常亮；同时, 如果此函数调用时屏幕没有点亮, 则会唤醒屏幕.</p>\n<p>在某些设备上, 如果不加参数timeout, 只能在Auto.js的界面保持屏幕常亮, 在其他界面会自动失效, 这是因为设备的省电策略造成的. 因此, 建议使用比较长的时长来代替&quot;一直保持屏幕常亮&quot;的功能, 例如<code>device.keepScreenOn(3600 * 1000)</code>.</p>\n<p>可以使用<code>device.cancelKeepingAwake()</code>来取消屏幕常亮.</p>\n<pre><code>//一直保持屏幕常亮\ndevice.keepScreenOn()\n</code></pre>"
        },
        {
          "textRaw": "device.keepScreenDim([timeout])",
          "type": "method",
          "name": "keepScreenDim",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`timeout` {number} 屏幕保持常亮的时间, 单位毫秒. 如果不加此参数, 则一直保持屏幕常亮. ",
                  "name": "timeout",
                  "type": "number",
                  "desc": "屏幕保持常亮的时间, 单位毫秒. 如果不加此参数, 则一直保持屏幕常亮.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "timeout",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>保持屏幕常亮, 但允许屏幕变暗来节省电量. 此函数可以用于定时脚本唤醒屏幕操作, 不需要用户观看屏幕, 可以让屏幕变暗来节省电量.</p>\n<p>此函数无法阻止用户使用锁屏键等正常关闭屏幕, 只能使得设备在无人操作的情况下保持屏幕常亮；同时, 如果此函数调用时屏幕没有点亮, 则会唤醒屏幕.</p>\n<p>可以使用<code>device.cancelKeepingAwake()</code>来取消屏幕常亮.</p>\n"
        },
        {
          "textRaw": "device.cancelKeepingAwake()",
          "type": "method",
          "name": "cancelKeepingAwake",
          "desc": "<p>取消设备保持唤醒状态. 用于取消<code>device.keepScreenOn()</code>, <code>device.keepScreenDim()</code>等函数设置的屏幕常亮.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "device.vibrate(millis)",
          "type": "method",
          "name": "vibrate",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`millis` {number} 震动时间, 单位毫秒 ",
                  "name": "millis",
                  "type": "number",
                  "desc": "震动时间, 单位毫秒"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "millis"
                }
              ]
            }
          ],
          "desc": "<p>使设备震动一段时间.</p>\n<pre><code>//震动两秒\ndevice.vibrate(2000);\n</code></pre>"
        },
        {
          "textRaw": "device.cancelVibration()",
          "type": "method",
          "name": "cancelVibration",
          "desc": "<p>如果设备处于震动状态, 则取消震动.</p>\n<!-- [end-include:device.md] -->\n<!-- [start-include:storages.md] -->\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "设备 (Device)"
    },
    {
      "textRaw": "存储 (Storages)",
      "name": "存储_(storages)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>storages模块提供了保存简单数据、用户配置等的支持. 保存的数据除非应用被卸载或者被主动删除, 否则会一直保留.</p>\n<p>storages支持<code>number</code>, <code>boolean</code>, <code>string</code>等数据类型以及把<code>Object</code>, <code>Array</code>用<code>JSON.stringify</code>序列化存取.</p>\n<p>storages保存的数据在脚本之间是共享的, 任何脚本只要知道storage名称便可以获取到相应的数据, 因此它不能用于敏感数据的储存.\nstorages无法像Web开发中LocalStorage一样提供根据域名独立的存储, 因为脚本的路径随时可能改变.</p>\n",
      "methods": [
        {
          "textRaw": "storages.create(name)",
          "type": "method",
          "name": "create",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`name` {string} 本地存储名称 ",
                  "name": "name",
                  "type": "string",
                  "desc": "本地存储名称"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "name"
                }
              ]
            }
          ],
          "desc": "<p>创建一个本地存储并返回一个<code>Storage</code>对象. 不同名称的本地存储的数据是隔开的, 而相同名称的本地存储的数据是共享的.</p>\n<p>例如在一个脚本中, 创建名称为ABC的存储并存入a=123:</p>\n<pre><code>var storage = storages.create(&quot;ABC&quot;);\nstorage.put(&quot;a&quot;, 123);\n</code></pre><p>而在另一个脚本中是可以获取到ABC以及a的值的：</p>\n<pre><code>var storage = storages.create(&quot;ABC&quot;);\nlog(&quot;a = &quot; + storage.get(&quot;a&quot;));\n</code></pre><p>因此, 本地存储的名称比较重要, 尽量使用含有域名、作者邮箱等唯一信息的名称来避免冲突, 例如：</p>\n<pre><code>var storage = storages.create(&quot;2732014414@qq.com:ABC&quot;);\n</code></pre>"
        },
        {
          "textRaw": "storages.remove(name)",
          "type": "method",
          "name": "remove",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`name` {string} 本地存储名称 ",
                  "name": "name",
                  "type": "string",
                  "desc": "本地存储名称"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "name"
                }
              ]
            }
          ],
          "desc": "<p>删除一个本地存储以及他的全部数据. 如果该存储不存在, 返回false；否则返回true.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "存储 (Storages)"
    },
    {
      "textRaw": "Storages",
      "name": "storages",
      "methods": [
        {
          "textRaw": "Storage.get(key[, defaultValue])",
          "type": "method",
          "name": "get",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`key` {string} 键值 ",
                  "name": "key",
                  "type": "string",
                  "desc": "键值"
                },
                {
                  "textRaw": "`defaultValue` {any} 可选, 默认值 ",
                  "name": "defaultValue",
                  "type": "any",
                  "desc": "可选, 默认值",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "key"
                },
                {
                  "name": "defaultValue",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>从本地存储中取出键值为key的数据并返回.</p>\n<p>如果该存储中不包含该数据, 这时若指定了默认值参数则返回默认值, 否则返回undefined.</p>\n<p>返回的数据可能是任意数据类型, 这取决于使用<code>Storage.put</code>保存该键值的数据时的数据类型.</p>\n"
        },
        {
          "textRaw": "Storage.put(key, value)",
          "type": "method",
          "name": "put",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`key` {string} 键值 ",
                  "name": "key",
                  "type": "string",
                  "desc": "键值"
                },
                {
                  "textRaw": "`value` {any} 值 ",
                  "name": "value",
                  "type": "any",
                  "desc": "值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "key"
                },
                {
                  "name": "value"
                }
              ]
            }
          ],
          "desc": "<p>把值value保存到本地存储中. value可以是undefined以外的任意数据类型. 如果value为undefined则抛出TypeError.</p>\n<p>存储的过程实际上是使用JSON.stringify把value转换为字符串再保存, 因此value必须是可JSON化的才能被接受.</p>\n"
        },
        {
          "textRaw": "Storage.remove(key)",
          "type": "method",
          "name": "remove",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`key` {string} 键值 ",
                  "name": "key",
                  "type": "string",
                  "desc": "键值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "key"
                }
              ]
            }
          ],
          "desc": "<p>移除键值为key的数据. 不返回任何值.</p>\n"
        },
        {
          "textRaw": "Storage.contains(key)",
          "type": "method",
          "name": "contains",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`key` {string} 键值 ",
                  "name": "key",
                  "type": "string",
                  "desc": "键值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "key"
                }
              ]
            }
          ],
          "desc": "<p>返回该本地存储是否包含键值为key的数据. 是则返回true, 否则返回false.</p>\n"
        },
        {
          "textRaw": "Storage.clear()",
          "type": "method",
          "name": "clear",
          "desc": "<p>移除该本地存储的所有数据. 不返回任何值.\n<!-- [end-include:storages.md] --></p>\n<!-- [start-include:files.md] -->\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Storages"
    },
    {
      "textRaw": "文件 (Files)",
      "name": "文件_(files)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>files模块提供了一些常见的文件处理, 包括文件读写、移动、复制、删掉等.</p>\n<p>一次性的文件读写可以直接使用<code>files.read()</code>, <code>files.write()</code>, <code>files.append()</code>等方便的函数, 但如果需要频繁读写或随机读写, 则使用<code>open()</code>函数打开一个文件对象来操作文件, 并在操作完毕后调用<code>close()</code>函数关闭文件.</p>\n",
      "methods": [
        {
          "textRaw": "files.isFile(path)",
          "type": "method",
          "name": "isFile",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>返回路径path是否是文件.</p>\n<pre><code>log(files.isDir(&quot;/sdcard/文件夹/&quot;)); //返回false\nlog(files.isDir(&quot;/sdcard/文件.txt&quot;)); //返回true\n</code></pre>"
        },
        {
          "textRaw": "files.isDir(path)",
          "type": "method",
          "name": "isDir",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>返回路径path是否是文件夹.</p>\n<pre><code>log(files.isDir(&quot;/sdcard/文件夹/&quot;)); //返回true\nlog(files.isDir(&quot;/sdcard/文件.txt&quot;)); //返回false\n</code></pre>"
        },
        {
          "textRaw": "files.isEmptyDir(path)",
          "type": "method",
          "name": "isEmptyDir",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>返回文件夹path是否为空文件夹. 如果该路径并非文件夹, 则直接返回<code>false</code>.</p>\n"
        },
        {
          "textRaw": "files.join(parent, child)",
          "type": "method",
          "name": "join",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`parent` {string} 父目录路径 ",
                  "name": "parent",
                  "type": "string",
                  "desc": "父目录路径"
                },
                {
                  "textRaw": "`child` {string} 子路径 ",
                  "name": "child",
                  "type": "string",
                  "desc": "子路径"
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "parent"
                },
                {
                  "name": "child"
                }
              ]
            }
          ],
          "desc": "<p>连接两个路径并返回, 例如<code>files.join(&quot;/sdcard/&quot;, &quot;1.txt&quot;)</code>返回&quot;/sdcard/1.txt&quot;.</p>\n"
        },
        {
          "textRaw": "files.create(path)",
          "type": "method",
          "name": "create",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>创建一个文件或文件夹并返回是否创建成功. 如果文件已经存在, 则直接返回<code>false</code>.</p>\n<pre><code>files.create(&quot;/sdcard/新文件夹/&quot;);\n</code></pre>"
        },
        {
          "textRaw": "files.createWithDirs(path)",
          "type": "method",
          "name": "createWithDirs",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>创建一个文件或文件夹并返回是否创建成功. 如果文件所在文件夹不存在, 则先创建他所在的一系列文件夹. 如果文件已经存在, 则直接返回<code>false</code>.</p>\n<pre><code>files.createWithDirs(&quot;/sdcard/新文件夹/新文件夹/新文件夹/1.txt&quot;);\n</code></pre>"
        },
        {
          "textRaw": "files.exists(path)",
          "type": "method",
          "name": "exists",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>返回在路径path处的文件是否存在.</p>\n"
        },
        {
          "textRaw": "files.ensureDir(path)",
          "type": "method",
          "name": "ensureDir",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>确保路径path所在的文件夹存在. 如果该路径所在文件夹不存在, 则创建该文件夹.</p>\n<p>例如对于路径&quot;/sdcard/Download/ABC/1.txt&quot;, 如果/Download/文件夹不存在, 则会先创建Download, 再创建ABC文件夹.</p>\n"
        },
        {
          "textRaw": "files.read(path[, encoding = \"utf-8\"])",
          "type": "method",
          "name": "read",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "`encoding` {string} 字符编码, 可选, 默认为utf-8 ",
                  "name": "encoding",
                  "type": "string",
                  "desc": "字符编码, 可选, 默认为utf-8",
                  "optional": true,
                  "default": " \"utf-8\""
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "encoding ",
                  "optional": true,
                  "default": " \"utf-8\""
                }
              ]
            }
          ],
          "desc": "<p>读取文本文件path的所有内容并返回. 如果文件不存在, 则抛出<code>FileNotFoundException</code>.</p>\n<pre><code>log(files.read(&quot;/sdcard/1.txt&quot;));\n</code></pre>"
        },
        {
          "textRaw": "files.readBytes(path)",
          "type": "method",
          "name": "readBytes",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {byte[]} ",
                  "name": "返回",
                  "type": "byte[]"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>读取文件path的所有内容并返回一个字节数组. 如果文件不存在, 则抛出<code>FileNotFoundException</code>.</p>\n<p>注意, 该数组是Java的数组, 不具有JavaScript数组的forEach, slice等函数.</p>\n<p>一个以16进制形式打印文件的例子如下:</p>\n<pre><code>var data = files.readBytes(&quot;/sdcard/1.png&quot;);\nvar sb = new java.lang.StringBuilder();\nfor(var i = 0; i &lt; data.length; i++){\n    sb.append(data[i].toString(16));\n}\nlog(sb.toString());\n</code></pre>"
        },
        {
          "textRaw": "files.write(path, text[, encoding = \"utf-8\"])",
          "type": "method",
          "name": "write",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "`text` {string} 要写入的文本内容 ",
                  "name": "text",
                  "type": "string",
                  "desc": "要写入的文本内容"
                },
                {
                  "textRaw": "`encoding` {string} 字符编码 ",
                  "name": "encoding",
                  "type": "string",
                  "desc": "字符编码",
                  "optional": true,
                  "default": " \"utf-8\""
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "text"
                },
                {
                  "name": "encoding ",
                  "optional": true,
                  "default": " \"utf-8\""
                }
              ]
            }
          ],
          "desc": "<p>把text写入到文件path中. 如果文件存在则覆盖, 不存在则创建.</p>\n<pre><code>var text = &quot;文件内容&quot;;\n//写入文件\nfiles.write(&quot;/sdcard/1.txt&quot;, text);\n//用其他应用查看文件\napp.viewFile(&quot;/sdcard/1.txt&quot;);\n</code></pre>"
        },
        {
          "textRaw": "files.writeBytes(path, bytes)",
          "type": "method",
          "name": "writeBytes",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "`bytes` {byte[]} 字节数组, 要写入的二进制数据 ",
                  "name": "bytes",
                  "type": "byte[]",
                  "desc": "字节数组, 要写入的二进制数据"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "bytes"
                }
              ]
            }
          ],
          "desc": "<p>把bytes写入到文件path中. 如果文件存在则覆盖, 不存在则创建.</p>\n"
        },
        {
          "textRaw": "files.append(path, text[, encoding = 'utf-8'])",
          "type": "method",
          "name": "append",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "`text` {string} 要写入的文本内容 ",
                  "name": "text",
                  "type": "string",
                  "desc": "要写入的文本内容"
                },
                {
                  "textRaw": "`encoding` {string} 字符编码 ",
                  "name": "encoding",
                  "type": "string",
                  "desc": "字符编码",
                  "optional": true,
                  "default": " 'utf-8'"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "text"
                },
                {
                  "name": "encoding ",
                  "optional": true,
                  "default": " 'utf-8'"
                }
              ]
            }
          ],
          "desc": "<p>把text追加到文件path的末尾. 如果文件不存在则创建.</p>\n<pre><code>var text = &quot;追加的文件内容&quot;;\nfiles.append(&quot;/sdcard/1.txt&quot;, text);\nfiles.append(&quot;/sdcard/1.txt&quot;, text);\n//用其他应用查看文件\napp.viewFile(&quot;/sdcard/1.txt&quot;);\n</code></pre>"
        },
        {
          "textRaw": "files.appendBytes(path, text[, encoding = 'utf-8'])",
          "type": "method",
          "name": "appendBytes",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "`bytes` {byte[]} 字节数组, 要写入的二进制数据 ",
                  "name": "bytes",
                  "type": "byte[]",
                  "desc": "字节数组, 要写入的二进制数据"
                },
                {
                  "name": "encoding ",
                  "optional": true,
                  "default": " 'utf-8'"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "text"
                },
                {
                  "name": "encoding ",
                  "optional": true,
                  "default": " 'utf-8'"
                }
              ]
            }
          ],
          "desc": "<p>把bytes追加到文件path的末尾. 如果文件不存在则创建.</p>\n"
        },
        {
          "textRaw": "files.copy(fromPath, toPath)",
          "type": "method",
          "name": "copy",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`fromPath` {string} 要复制的原文件路径 ",
                  "name": "fromPath",
                  "type": "string",
                  "desc": "要复制的原文件路径"
                },
                {
                  "textRaw": "`toPath` {string} 复制到的文件路径 ",
                  "name": "toPath",
                  "type": "string",
                  "desc": "复制到的文件路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "fromPath"
                },
                {
                  "name": "toPath"
                }
              ]
            }
          ],
          "desc": "<p>复制文件, 返回是否复制成功. 例如<code>files.copy(&quot;/sdcard/1.txt&quot;, &quot;/sdcard/Download/1.txt&quot;)</code>.</p>\n"
        },
        {
          "textRaw": "files.move(fromPath, toPath)",
          "type": "method",
          "name": "move",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`fromPath` {string} 要移动的原文件路径 ",
                  "name": "fromPath",
                  "type": "string",
                  "desc": "要移动的原文件路径"
                },
                {
                  "textRaw": "`toPath` {string} 移动到的文件路径 ",
                  "name": "toPath",
                  "type": "string",
                  "desc": "移动到的文件路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "fromPath"
                },
                {
                  "name": "toPath"
                }
              ]
            }
          ],
          "desc": "<p>移动文件, 返回是否移动成功. 例如<code>files.move(&quot;/sdcard/1.txt&quot;, &quot;/sdcard/Download/1.txt&quot;)</code>会把1.txt文件从sd卡根目录移动到Download文件夹.</p>\n"
        },
        {
          "textRaw": "files.rename(path, newName)",
          "type": "method",
          "name": "rename",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 要重命名的原文件路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "要重命名的原文件路径"
                },
                {
                  "textRaw": "`newName` {string} 要重命名的新文件名 ",
                  "name": "newName",
                  "type": "string",
                  "desc": "要重命名的新文件名"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "newName"
                }
              ]
            }
          ],
          "desc": "<p>重命名文件, 并返回是否重命名成功. 例如<code>files.rename(&quot;/sdcard/1.txt&quot;, &quot;2.txt&quot;)</code>.</p>\n"
        },
        {
          "textRaw": "files.renameWithoutExtension(path, newName)",
          "type": "method",
          "name": "renameWithoutExtension",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 要重命名的原文件路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "要重命名的原文件路径"
                },
                {
                  "textRaw": "`newName` {string} 要重命名的新文件名 ",
                  "name": "newName",
                  "type": "string",
                  "desc": "要重命名的新文件名"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "newName"
                }
              ]
            }
          ],
          "desc": "<p>重命名文件, 不包含拓展名, 并返回是否重命名成功. 例如<code>files.rename(&quot;/sdcard/1.txt&quot;, &quot;2&quot;)</code>会把&quot;1.txt&quot;重命名为&quot;2.txt&quot;.</p>\n"
        },
        {
          "textRaw": "files.getName(path)",
          "type": "method",
          "name": "getName",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>返回文件的文件名. 例如<code>files.getName(&quot;/sdcard/1.txt&quot;)</code>返回&quot;1.txt&quot;.</p>\n"
        },
        {
          "textRaw": "files.getNameWithoutExtension(path)",
          "type": "method",
          "name": "getNameWithoutExtension",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>返回不含拓展名的文件的文件名. 例如<code>files.getName(&quot;/sdcard/1.txt&quot;)</code>返回&quot;1&quot;.</p>\n"
        },
        {
          "textRaw": "files.getExtension(path)",
          "type": "method",
          "name": "getExtension",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>返回文件的拓展名. 例如<code>files.getExtension(&quot;/sdcard/1.txt&quot;)</code>返回&quot;txt&quot;.</p>\n"
        },
        {
          "textRaw": "files.remove(path)",
          "type": "method",
          "name": "remove",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>删除文件或<strong>空文件夹</strong>, 返回是否删除成功.</p>\n"
        },
        {
          "textRaw": "files.removeDir(path)",
          "type": "method",
          "name": "removeDir",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>删除文件夹, 如果文件夹不为空, 则删除该文件夹的所有内容再删除该文件夹, 返回是否全部删除成功.</p>\n"
        },
        {
          "textRaw": "files.getSdcardPath()",
          "type": "method",
          "name": "getSdcardPath",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回SD卡路径. 所谓SD卡, 即外部存储器.</p>\n"
        },
        {
          "textRaw": "files.cwd()",
          "type": "method",
          "name": "cwd",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回脚本的&quot;当前工作文件夹路径&quot;. 该路径指的是, 如果脚本本身为脚本文件, 则返回这个脚本文件所在目录；否则返回<code>null</code>获取其他设定路径.</p>\n<p>例如, 对于脚本文件&quot;/sdcard/脚本/1.js&quot;运行<code>files.cwd()</code>返回&quot;/sdcard/脚本/&quot;.</p>\n"
        },
        {
          "textRaw": "files.path(relativePath)",
          "type": "method",
          "name": "path",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`relativePath` {string} 相对路径 ",
                  "name": "relativePath",
                  "type": "string",
                  "desc": "相对路径"
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "relativePath"
                }
              ]
            }
          ],
          "desc": "<p>返回相对路径对应的绝对路径. 例如<code>files.path(&quot;./1.png&quot;)</code>, 如果运行这个语句的脚本位于文件夹&quot;/sdcard/脚本/&quot;中, 则返回<code>&quot;/sdcard/脚本/1.png&quot;</code>.</p>\n"
        },
        {
          "textRaw": "files.listDir(path[, filter])",
          "type": "method",
          "name": "listDir",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "路径"
                },
                {
                  "textRaw": "`filter` {Function} 过滤函数, 可选. 接收一个`string`参数（文件名）, 返回一个`boolean`值. ",
                  "name": "filter",
                  "type": "Function",
                  "desc": "过滤函数, 可选. 接收一个`string`参数（文件名）, 返回一个`boolean`值.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "filter",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>列出文件夹path下的满足条件的文件和文件夹的名称的数组. 如果不加filter参数, 则返回所有文件和文件夹.</p>\n<p>列出sdcard目录下所有文件和文件夹为:</p>\n<pre><code>var arr = files.listDir(&quot;/sdcard/&quot;);\nlog(arr);\n</code></pre><p>列出脚本目录下所有js脚本文件为:</p>\n<pre><code>var dir = &quot;/sdcard/脚本/&quot;;\nvar jsFiles = files.listDir(dir, function(name){\n    return name.endsWith(&quot;.js&quot;) &amp;&amp; files.isFile(files.join(dir, name));\n});\nlog(jsFiles);\n</code></pre>"
        },
        {
          "textRaw": "open(path[, mode = \"r\", encoding = \"utf-8\", bufferSize = 8192])",
          "type": "method",
          "name": "open",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 文件路径, 例如\"/sdcard/1.txt\". ",
                  "name": "path",
                  "type": "string",
                  "desc": "文件路径, 例如\"/sdcard/1.txt\"."
                },
                {
                  "textRaw": "`mode` {string} 文件打开模式, 包括: ",
                  "options": [
                    {
                      "textRaw": "\"r\": 只读文本模式. 该模式下只能对文件执行**文本**读取操作. ",
                      "name": "r",
                      "desc": "只读文本模式. 该模式下只能对文件执行**文本**读取操作."
                    },
                    {
                      "textRaw": "\"w\": 只写文本模式. 该模式下只能对文件执行**文本**覆盖写入操作. ",
                      "name": "w",
                      "desc": "只写文本模式. 该模式下只能对文件执行**文本**覆盖写入操作."
                    },
                    {
                      "textRaw": "\"a\": 附加文本模式. 该模式下将会把写入的文本附加到文件末尾. ",
                      "name": "a",
                      "desc": "附加文本模式. 该模式下将会把写入的文本附加到文件末尾."
                    },
                    {
                      "textRaw": "\"rw\": 随机读写文本模式. 该模式下将会把写入的文本附加到文件末尾.    目前暂不支持二进制模式, 随机读写模式. ",
                      "name": "rw",
                      "desc": "随机读写文本模式. 该模式下将会把写入的文本附加到文件末尾.    目前暂不支持二进制模式, 随机读写模式."
                    }
                  ],
                  "name": "mode",
                  "type": "string",
                  "desc": "文件打开模式, 包括:",
                  "optional": true,
                  "default": " \"r\""
                },
                {
                  "textRaw": "`encoding` {string} 字符编码. ",
                  "name": "encoding",
                  "type": "string",
                  "desc": "字符编码.",
                  "optional": true,
                  "default": " \"utf-8\""
                },
                {
                  "textRaw": "`bufferSize` {number} 文件读写的缓冲区大小. ",
                  "name": "bufferSize",
                  "type": "number",
                  "desc": "文件读写的缓冲区大小.",
                  "optional": true,
                  "default": " 8192"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode ",
                  "optional": true,
                  "default": " \"r\""
                },
                {
                  "name": "encoding ",
                  "optional": true,
                  "default": " \"utf-8\""
                },
                {
                  "name": "bufferSize ",
                  "optional": true,
                  "default": " 8192"
                }
              ]
            }
          ],
          "desc": "<p>打开一个文件. 根据打开模式返回不同的文件对象. 包括：</p>\n<ul>\n<li>&quot;r&quot;: 返回一个ReadableTextFile对象.</li>\n<li>&quot;w&quot;, &quot;a&quot;: 返回一个WritableTextFile对象.</li>\n</ul>\n<p>对于&quot;w&quot;模式, 如果文件并不存在, 则会创建一个, 已存在则会清空该文件内容；其他模式文件不存在会抛出FileNotFoundException.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "文件 (Files)"
    },
    {
      "textRaw": "ReadableTextFile",
      "name": "readabletextfile",
      "desc": "<p>可读文件对象.</p>\n",
      "methods": [
        {
          "textRaw": "ReadableTextFile.read()",
          "type": "method",
          "name": "read",
          "desc": "<p>返回该文件剩余的所有内容的字符串.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "ReadableTextFile.read(maxCount)",
          "type": "method",
          "name": "read",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`maxCount` {Number} 最大读取的字符数量 ",
                  "name": "maxCount",
                  "type": "Number",
                  "desc": "最大读取的字符数量"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "maxCount"
                }
              ]
            }
          ],
          "desc": "<p>读取该文件接下来最长为maxCount的字符串并返回. 即使文件剩余内容不足maxCount也不会出错.</p>\n"
        },
        {
          "textRaw": "ReadableTextFile.readline()",
          "type": "method",
          "name": "readline",
          "desc": "<p>读取一行并返回（不包含换行符）.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "ReadableTextFile.readlines()",
          "type": "method",
          "name": "readlines",
          "desc": "<p>读取剩余的所有行, 并返回它们按顺序组成的字符串数组.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "close()",
          "type": "method",
          "name": "close",
          "desc": "<p>关闭该文件.</p>\n<p><strong>打开一个文件不再使用时务必关闭</strong></p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "ReadableTextFile"
    },
    {
      "textRaw": "PWritableTextFile",
      "name": "pwritabletextfile",
      "desc": "<p>可写文件对象.</p>\n",
      "methods": [
        {
          "textRaw": "PWritableTextFile.write(text)",
          "type": "method",
          "name": "write",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`text` {string} 文本 ",
                  "name": "text",
                  "type": "string",
                  "desc": "文本"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "text"
                }
              ]
            }
          ],
          "desc": "<p>把文本内容text写入到文件中.</p>\n"
        },
        {
          "textRaw": "PWritableTextFile.writeline(line)",
          "type": "method",
          "name": "writeline",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`text` {string} 文本 ",
                  "name": "text",
                  "type": "string",
                  "desc": "文本"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "line"
                }
              ]
            }
          ],
          "desc": "<p>把文本line写入到文件中并写入一个换行符.</p>\n"
        },
        {
          "textRaw": "PWritableTextFile.writelines(lines)",
          "type": "method",
          "name": "writelines",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`lines` {Array} 字符串数组 ",
                  "name": "lines",
                  "type": "Array",
                  "desc": "字符串数组"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "lines"
                }
              ]
            }
          ],
          "desc": "<p>把很多行写入到文件中....</p>\n"
        },
        {
          "textRaw": "PWritableTextFile.flush()",
          "type": "method",
          "name": "flush",
          "desc": "<p>把缓冲区内容输出到文件中.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "PWritableTextFile.close()",
          "type": "method",
          "name": "close",
          "desc": "<p>关闭文件. 同时会被缓冲区内容输出到文件.</p>\n<p><strong>打开一个文件写入后, 不再使用时务必关闭, 否则文件可能会丢失</strong></p>\n<!-- [end-include:files.md] -->\n<!-- [start-include:engines.md] -->\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "PWritableTextFile"
    },
    {
      "textRaw": "引擎 (Engines)",
      "name": "引擎_(engines)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>engines模块包含了一些与脚本环境、脚本运行、脚本引擎有关的函数, 包括运行其他脚本, 关闭脚本等.</p>\n<p>例如, 获取脚本所在目录：</p>\n<pre><code>toast(engines.myEngine().cwd());\n</code></pre>",
      "methods": [
        {
          "textRaw": "engines.execScript(name, script[, config])",
          "type": "method",
          "name": "execScript",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`name` {string} 要运行的脚本名称. 这个名称和文件名称无关, 只是在任务管理中显示的名称. ",
                  "name": "name",
                  "type": "string",
                  "desc": "要运行的脚本名称. 这个名称和文件名称无关, 只是在任务管理中显示的名称."
                },
                {
                  "textRaw": "`script` {string} 要运行的脚本内容. ",
                  "name": "script",
                  "type": "string",
                  "desc": "要运行的脚本内容."
                },
                {
                  "textRaw": "`config` {Object} 运行配置项 ",
                  "options": [
                    {
                      "textRaw": "`delay` {number} 延迟执行的毫秒数, 默认为0 ",
                      "name": "delay",
                      "type": "number",
                      "desc": "延迟执行的毫秒数, 默认为0"
                    },
                    {
                      "textRaw": "`loopTimes` {number} 循环运行次数, 默认为1. 0为无限循环. ",
                      "name": "loopTimes",
                      "type": "number",
                      "desc": "循环运行次数, 默认为1. 0为无限循环."
                    },
                    {
                      "textRaw": "`interval` {number} 循环运行时两次运行之间的时间间隔, 默认为0 ",
                      "name": "interval",
                      "type": "number",
                      "desc": "循环运行时两次运行之间的时间间隔, 默认为0"
                    },
                    {
                      "textRaw": "`path` {Array} | {string} 指定脚本运行的目录. 这些路径会用于require时寻找模块文件. ",
                      "name": "path",
                      "type": "Array",
                      "desc": "| {string} 指定脚本运行的目录. 这些路径会用于require时寻找模块文件."
                    }
                  ],
                  "name": "config",
                  "type": "Object",
                  "desc": "运行配置项",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "name"
                },
                {
                  "name": "script"
                },
                {
                  "name": "config",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>在新的脚本环境中运行脚本script. 返回一个<a href=\"#engines_scriptexecution\">ScriptExectuion</a>对象.</p>\n<p>所谓新的脚本环境, 指定是, 脚本中的变量和原脚本的变量是不共享的, 并且, 脚本会在新的线程中运行.</p>\n<p>最简单的例子如下：</p>\n<pre><code>engines.execScript(&quot;hello world&quot;, &quot;toast(&#39;hello world&#39;)&quot;);\n</code></pre><p>如果要循环运行, 则：</p>\n<pre><code>//每隔3秒运行一次脚本, 循环10次\nengines.execScript(&quot;hello world&quot;, &quot;toast(&#39;hello world&#39;)&quot;, {\n    loopTimes: 10,\n    interval: 3000\n});\n</code></pre><p>用字符串来编写脚本非常不方便, 可以结合 <code>Function.toString()</code>的方法来执行特定函数:</p>\n<pre><code>function helloWorld(){\n    //注意, 这里的变量和脚本主体的变量并不共享\n    toast(&quot;hello world&quot;);\n}\nengines.execScript(&quot;hello world&quot;, &quot;helloWorld();\\n&quot; + helloWorld.toString());\n</code></pre><p>如果要传递变量, 则可以把这些封装成一个函数：</p>\n<pre><code>function exec(action, args){\n    args = args || {};\n    engines.execScript(action.name, action.name + &quot;(&quot; + JSON.stringify(args) + &quot;);\\n&quot; + action.toString());\n}\n\n//要执行的函数, 是一个简单的加法\nfunction add(args){\n    toast(args.a + args.b);\n}\n\n//在新的脚本环境中执行 1 + 2\nexec(add, {a: 1, b:2});\n</code></pre>"
        },
        {
          "textRaw": "engines.execScriptFile(path[, config])",
          "type": "method",
          "name": "execScriptFile",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 要运行的脚本路径. ",
                  "name": "path",
                  "type": "string",
                  "desc": "要运行的脚本路径."
                },
                {
                  "textRaw": "`config` {Object} 运行配置项 ",
                  "options": [
                    {
                      "textRaw": "`delay` {number} 延迟执行的毫秒数, 默认为0 ",
                      "name": "delay",
                      "type": "number",
                      "desc": "延迟执行的毫秒数, 默认为0"
                    },
                    {
                      "textRaw": "`loopTimes` {number} 循环运行次数, 默认为1. 0为无限循环. ",
                      "name": "loopTimes",
                      "type": "number",
                      "desc": "循环运行次数, 默认为1. 0为无限循环."
                    },
                    {
                      "textRaw": "`interval` {number} 循环运行时两次运行之间的时间间隔, 默认为0 ",
                      "name": "interval",
                      "type": "number",
                      "desc": "循环运行时两次运行之间的时间间隔, 默认为0"
                    },
                    {
                      "textRaw": "`path` {Array} | {string} 指定脚本运行的目录. 这些路径会用于require时寻找模块文件. ",
                      "name": "path",
                      "type": "Array",
                      "desc": "| {string} 指定脚本运行的目录. 这些路径会用于require时寻找模块文件."
                    }
                  ],
                  "name": "config",
                  "type": "Object",
                  "desc": "运行配置项",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "config",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>在新的脚本环境中运行脚本文件path. 返回一个<a href=\"#ScriptExecution\">ScriptExecution</a>对象.</p>\n<pre><code>engines.execScriptFile(&quot;/sdcard/脚本/1.js&quot;);\n</code></pre>"
        },
        {
          "textRaw": "engines.execAutoFile(path[, config])",
          "type": "method",
          "name": "execAutoFile",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 要运行的录制文件路径. ",
                  "name": "path",
                  "type": "string",
                  "desc": "要运行的录制文件路径."
                },
                {
                  "textRaw": "`config` {Object} 运行配置项 ",
                  "options": [
                    {
                      "textRaw": "`delay` {number} 延迟执行的毫秒数, 默认为0 ",
                      "name": "delay",
                      "type": "number",
                      "desc": "延迟执行的毫秒数, 默认为0"
                    },
                    {
                      "textRaw": "`loopTimes` {number} 循环运行次数, 默认为1. 0为无限循环. ",
                      "name": "loopTimes",
                      "type": "number",
                      "desc": "循环运行次数, 默认为1. 0为无限循环."
                    },
                    {
                      "textRaw": "`interval` {number} 循环运行时两次运行之间的时间间隔, 默认为0 ",
                      "name": "interval",
                      "type": "number",
                      "desc": "循环运行时两次运行之间的时间间隔, 默认为0"
                    },
                    {
                      "textRaw": "`path` {Array} | {string} 指定脚本运行的目录. 这些路径会用于require时寻找模块文件. ",
                      "name": "path",
                      "type": "Array",
                      "desc": "| {string} 指定脚本运行的目录. 这些路径会用于require时寻找模块文件."
                    }
                  ],
                  "name": "config",
                  "type": "Object",
                  "desc": "运行配置项",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "config",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>在新的脚本环境中运行录制文件path. 返回一个<a href=\"#ScriptExecution\">ScriptExecution</a>对象.</p>\n<pre><code>engines.execAutoFile(&quot;/sdcard/脚本/1.auto&quot;);\n</code></pre>"
        },
        {
          "textRaw": "engines.stopAll()",
          "type": "method",
          "name": "stopAll",
          "desc": "<p>停止所有正在运行的脚本. 包括当前脚本自身.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "engines.stopAllAndToast()",
          "type": "method",
          "name": "stopAllAndToast",
          "desc": "<p>停止所有正在运行的脚本并显示停止的脚本数量. 包括当前脚本自身.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "engines.myEngine()",
          "type": "method",
          "name": "myEngine",
          "desc": "<p>返回当前脚本的脚本引擎对象(<a href=\"#engines_scriptengine\">ScriptEngine</a>)</p>\n<p><strong>[v4.1.0新增]</strong>\n特别的, 该对象可以通过<code>execArgv</code>来获取他的运行参数, 包括外部参数、intent等. 例如：</p>\n<pre><code>log(engines.myEngine().execArgv);\n</code></pre><p>普通脚本的运行参数通常为空, 通过定时任务的广播启动的则可以获取到启动的intent.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "engines.all()",
          "type": "method",
          "name": "all",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Array} ",
                  "name": "返回",
                  "type": "Array"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前所有正在运行的脚本的脚本引擎<a href=\"#engines_scriptengine\">ScriptEngine</a>的数组.</p>\n<pre><code>log(engines.all());\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "引擎 (Engines)"
    },
    {
      "textRaw": "ScriptExecution",
      "name": "scriptexecution",
      "desc": "<p>执行脚本时返回的对象, 可以通过他获取执行的引擎、配置等, 也可以停止这个执行.</p>\n<p>要停止这个脚本的执行, 使用<code>exectuion.getEngine().forceStop()</code>.</p>\n",
      "methods": [
        {
          "textRaw": "ScriptExecution.getEngine()",
          "type": "method",
          "name": "getEngine",
          "desc": "<p>返回执行该脚本的脚本引擎对象(<a href=\"#engines_scriptengine\">ScriptEngine</a>)</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "ScriptExecution.getConfig()",
          "type": "method",
          "name": "getConfig",
          "desc": "<p>返回该脚本的运行配置(<a href=\"#engines_scriptconfig\">ScriptConfig</a>)</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "ScriptExecution"
    },
    {
      "textRaw": "ScriptEngine",
      "name": "scriptengine",
      "desc": "<p>脚本引擎对象.</p>\n",
      "methods": [
        {
          "textRaw": "ScriptEngine.forceStop()",
          "type": "method",
          "name": "forceStop",
          "desc": "<p>停止脚本引擎的执行.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "ScriptEngine.cwd()",
          "type": "method",
          "name": "cwd",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回脚本执行的路径. 对于一个脚本文件而言为这个脚本所在的文件夹；对于其他脚本, 例如字符串脚本, 则为<code>null</code>或者执行时的设置值.</p>\n"
        },
        {
          "textRaw": "ScriptEngine.getSource()",
          "type": "method",
          "name": "getSource",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 [ScriptSource](#engines_scriptsource) ",
                  "name": "返回",
                  "desc": "[ScriptSource](#engines_scriptsource)"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前脚本引擎正在执行的脚本对象.</p>\n<pre><code>log(engines.myEngine().getSource());\n</code></pre>"
        },
        {
          "textRaw": "ScriptEngine.emit(eventName[, ...args])",
          "type": "method",
          "name": "emit",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {string} 事件名称 ",
                  "name": "eventName",
                  "type": "string",
                  "desc": "事件名称"
                },
                {
                  "textRaw": "`...args` {any} 事件参数 ",
                  "name": "...args",
                  "type": "any",
                  "desc": "事件参数",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>向该脚本引擎发送一个事件, 该事件可以在该脚本引擎对应的脚本的events模块监听到并在脚本主线程执行事件处理.</p>\n<p>例如脚本receiver.js的内容如下：</p>\n<pre><code>//监听say事件\nevents.on(&quot;say&quot;, function(words){\n    toastLog(words);\n});\n//保持脚本运行\nsetInterval(()=&gt;{}, 1000);\n</code></pre><p>同一目录另一脚本可以启动他并发送该事件：</p>\n<pre><code>//运行脚本\nvar e = engines.execScriptFile(&quot;./receiver.js&quot;);\n//等待脚本启动\nsleep(2000);\n//向该脚本发送事件\ne.getEngine().emit(&quot;say&quot;, &quot;你好&quot;);\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "ScriptEngine"
    },
    {
      "textRaw": "ScriptConfig",
      "name": "scriptconfig",
      "desc": "<p>脚本执行时的配置.</p>\n",
      "modules": [
        {
          "textRaw": "delay",
          "name": "delay",
          "desc": "<ul>\n<li>{number}</li>\n</ul>\n<p>延迟执行的毫秒数</p>\n",
          "type": "module",
          "displayName": "delay"
        },
        {
          "textRaw": "interval",
          "name": "interval",
          "desc": "<ul>\n<li>{number}</li>\n</ul>\n<p>循环运行时两次运行之间的时间间隔</p>\n",
          "type": "module",
          "displayName": "interval"
        },
        {
          "textRaw": "loopTimes",
          "name": "looptimes",
          "desc": "<ul>\n<li>{number}</li>\n</ul>\n<p>循环运行次数</p>\n",
          "type": "module",
          "displayName": "loopTimes"
        }
      ],
      "methods": [
        {
          "textRaw": "getPath()",
          "type": "method",
          "name": "getPath",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {Array} ",
                  "name": "返回",
                  "type": "Array"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回一个字符串数组表示脚本运行时模块寻找的路径.</p>\n<!-- [end-include:engines.md] -->\n<!-- [start-include:tasks.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "ScriptConfig"
    },
    {
      "textRaw": "任务 (Tasks)",
      "name": "任务_(tasks)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<!-- [end-include:tasks.md] -->\n<!-- [start-include:modules.md] -->\n",
      "type": "module",
      "displayName": "任务 (Tasks)"
    },
    {
      "textRaw": "模块 (Module)",
      "name": "模块_(module)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>Auto.js 有一个简单的模块加载系统.  在 Auto.js 中, 文件和模块是一一对应的（每个文件被视为一个独立的模块）.</p>\n<p>例子, 假设有一个名为 foo.js 的文件：</p>\n<pre><code>var circle = require(&#39;circle.js&#39;);\nconsole.log(&quot;半径为 4 的圆的面积是 %d&quot;, circle.area(4));\n</code></pre><p>在第一行中, foo.js 加载了同一目录下的 circle.js 模块.</p>\n<p>circle.js 文件的内容为：</p>\n<pre><code>const PI = Math.PI;\n\nvar circle = {};\n\ncircle.area = function (r) {\n  return PI * r * r;\n};\n\ncircle.circumference = (r) =&gt; 2 * PI * r;\n\nmodule.exports = circle;\n</code></pre><p>circle.js 模块导出了 area() 和 circumference() 两个函数.  通过在特殊的 exports 对象上指定额外的属性, 函数和对象可以被添加到模块的根部.</p>\n<p>模块内的本地变量是私有的.  在这个例子中, 变量 PI 是 circle.js 私有的, 不会影响到加载他的脚本的变量环境.</p>\n<p>module.exports属性可以被赋予一个新的值（例如函数或对象）.</p>\n<p>如下, bar.js 会用到 square 模块, square 导出一个构造函数：</p>\n<pre><code>const square = require(&#39;square.js&#39;);\nconst mySquare = square(2);\nconsole.log(&quot;正方形的面积是 %d&quot;, mySquare.area());\nsquare 模块定义在 square.js 中：\n\n// 赋值给 `exports` 不会修改模块, 必须使用 `module.exports`\nmodule.exports = function(width) {\n  return {\n    area: () =&gt; width ** 2\n  };\n};\n</code></pre><!-- [end-include:modules.md] -->\n<!-- [start-include:plugins.md] -->\n",
      "type": "module",
      "displayName": "模块 (Module)"
    },
    {
      "textRaw": "插件 (Plugins)",
      "name": "插件_(plugins)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<!-- [end-include:plugins.md] -->\n<!-- [start-include:continuation.md] -->\n",
      "type": "module",
      "displayName": "插件 (Plugins)"
    },
    {
      "textRaw": "协程 (Continuation)",
      "name": "协程_(continuation)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<!-- [end-include:continuation.md] -->\n<!-- [start-include:console.md] -->\n",
      "type": "module",
      "displayName": "协程 (Continuation)"
    },
    {
      "textRaw": "控制台 (Console)",
      "name": "控制台_(console)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>控制台模块提供了一个和Web浏览器中相似的用于调试的控制台. 用于输出一些调试信息、中间结果等.\nconsole模块中的一些函数也可以直接作为全局函数使用, 例如log, print等.</p>\n",
      "methods": [
        {
          "textRaw": "console.show()",
          "type": "method",
          "name": "show",
          "desc": "<p>显示控制台. 这会显示一个控制台的悬浮窗(需要悬浮窗权限).</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "console.hide()",
          "type": "method",
          "name": "hide",
          "desc": "<p>隐藏控制台悬浮窗.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "console.clear()",
          "type": "method",
          "name": "clear",
          "desc": "<p>清空控制台.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "console.log([data][, ...args])",
          "type": "method",
          "name": "log",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`data` {any} ",
                  "name": "data",
                  "type": "any",
                  "optional": true
                },
                {
                  "textRaw": "`...args` {any} ",
                  "name": "...args",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>打印到控制台, 并带上换行符.  可以传入多个参数, 第一个参数作为主要信息, 其他参数作为类似于 <a href=\"http://man7.org/linux/man-pages/man3/printf.3.html/\">printf(3)</a> 中的代替值（参数都会传给 util.format(/)）.</p>\n<pre><code>const count = 5;\nconsole.log(&#39;count: %d&#39;, count);\n// 打印: count: 5 到 stdout\nconsole.log(&#39;count:&#39;, count);\n// 打印: count: 5 到 stdout\n</code></pre><p>详见 util.format().</p>\n<p>该函数也可以作为全局函数使用.</p>\n"
        },
        {
          "textRaw": "console.verbose([data][, ...args])",
          "type": "method",
          "name": "verbose",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`data` {any} ",
                  "name": "data",
                  "type": "any",
                  "optional": true
                },
                {
                  "textRaw": "`...args` {any} ",
                  "name": "...args",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>与console.log类似, 但输出结果以灰色字体显示. 输出优先级低于log, 用于输出观察性质的信息.</p>\n"
        },
        {
          "textRaw": "console.info([data][, ...args])",
          "type": "method",
          "name": "info",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`data` {any} ",
                  "name": "data",
                  "type": "any",
                  "optional": true
                },
                {
                  "textRaw": "`...args` {any} ",
                  "name": "...args",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>与console.log类似, 但输出结果以绿色字体显示. 输出优先级高于log, 用于输出重要信息.</p>\n"
        },
        {
          "textRaw": "console.warn([data][, ...args])",
          "type": "method",
          "name": "warn",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`data` {any} ",
                  "name": "data",
                  "type": "any",
                  "optional": true
                },
                {
                  "textRaw": "`...args` {any} ",
                  "name": "...args",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>与console.log类似, 但输出结果以蓝色字体显示. 输出优先级高于info, 用于输出警告信息.</p>\n"
        },
        {
          "textRaw": "console.error([data][, ...args])",
          "type": "method",
          "name": "error",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`data` {any} ",
                  "name": "data",
                  "type": "any",
                  "optional": true
                },
                {
                  "textRaw": "`...args` {any} ",
                  "name": "...args",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>与console.log类似, 但输出结果以红色字体显示. 输出优先级高于warn, 用于输出错误信息.</p>\n"
        },
        {
          "textRaw": "console.assert(value, message)",
          "type": "method",
          "name": "assert",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "value {any} 要断言的布尔值 ",
                  "name": "value",
                  "type": "any",
                  "desc": "要断言的布尔值"
                },
                {
                  "textRaw": "message {string} value为false时要输出的信息 ",
                  "name": "message",
                  "type": "string",
                  "desc": "value为false时要输出的信息"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "value"
                },
                {
                  "name": "message"
                }
              ]
            }
          ],
          "desc": "<p>断言. 如果value为false则输出错误信息message并停止脚本运行.</p>\n<pre><code>var a = 1 + 1;\nconsole.assert(a == 2, &quot;加法出错啦&quot;);\n</code></pre>"
        },
        {
          "textRaw": "console.time([label])",
          "type": "method",
          "name": "time",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>label</code> {String} 计时器标签, 可省略</li>\n</ul>\n<p>启动一个定时器, 用以计算一个操作的持续时间.\n定时器由一个唯一的 <code>label</code> 标识.\n当调用 <code>console.timeEnd()</code> 时, 可以使用相同的 <code>label</code> 来停止定时器, 并以毫秒为单位将持续时间输出到控制台.\n重复启动同一个标签的定时器会覆盖之前启动同一标签的定时器.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "label",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.timeEnd(label)",
          "type": "method",
          "name": "timeEnd",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>label</code> {String} 计时器标签</li>\n</ul>\n<p>停止之前通过调用 <code>console.time()</code> 启动的定时器, 并打印结果到控制台.\n调用 <code>console.timeEnd()</code> 后定时器会被删除. 如果不存在标签指定的定时器则会打印 <code>NaNms</code>.</p>\n<pre><code class=\"lang-js\">console.time(&#39;求和&#39;);\nvar sum = 0;\nfor(let i = 0; i &lt; 100000; i++){\n    sum += i;\n}\nconsole.timeEnd(&#39;求和&#39;);\n// 打印 求和: xxx ms\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "label"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.trace([data][, ...args])",
          "type": "method",
          "name": "trace",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>data</code> {any}</li>\n<li><code>...args</code> {any}</li>\n</ul>\n<p>与console.log类似, 同时会打印出调用这个函数所在的调用栈信息（即当前运行的文件、行数等信息）.</p>\n<pre><code class=\"lang-js\">console.trace(&#39;Show me&#39;);\n// 打印: (堆栈跟踪会根据被调用的跟踪的位置而变化)\n// Show me\n//  at &lt;test&gt;:7\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.input(data[, ...args])",
          "type": "method",
          "name": "input",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`data` {any} ",
                  "name": "data",
                  "type": "any"
                },
                {
                  "textRaw": "`...args` {any} ",
                  "name": "...args",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "data"
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>与console.log一样输出信息, 并在控制台显示输入框等待输入. 按控制台的确认按钮后会将输入的字符串用eval计算后返回.</p>\n<p><strong>部分机型可能会有控制台不显示输入框的情况, 属于bug. </strong></p>\n<p>例如：</p>\n<pre><code>var n = console.input(&quot;请输入一个数字:&quot;); \n//输入123之后：\ntoast(n + 1);\n//显示124\n</code></pre>"
        },
        {
          "textRaw": "console.rawInput(data[, ...args])",
          "type": "method",
          "name": "rawInput",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`data` {any} ",
                  "name": "data",
                  "type": "any"
                },
                {
                  "textRaw": "`...args` {any} ",
                  "name": "...args",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "data"
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>与console.log一样输出信息, 并在控制台显示输入框等待输入. 按控制台的确认按钮后会将输入的字符串直接返回.</p>\n<p>部分机型可能会有控制台不显示输入框的情况, 属于bug.</p>\n<p>例如：</p>\n<pre><code>var n = console.rawInput(&quot;请输入一个数字:&quot;); \n//输入123之后：\ntoast(n + 1);\n//显示1231\n</code></pre>"
        },
        {
          "textRaw": "console.setSize(w, h)",
          "type": "method",
          "name": "setSize",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`w` {number} 宽度 ",
                  "name": "w",
                  "type": "number",
                  "desc": "宽度"
                },
                {
                  "textRaw": "`h` {number} 高度 ",
                  "name": "h",
                  "type": "number",
                  "desc": "高度"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "w"
                },
                {
                  "name": "h"
                }
              ]
            }
          ],
          "desc": "<p>设置控制台的大小, 单位像素.</p>\n<pre><code>console.show();\n//设置控制台大小为屏幕的四分之一\nconsole.setSize(device.width / 2, device.height / 2);\n</code></pre>"
        },
        {
          "textRaw": "console.setPosition(x, y)",
          "type": "method",
          "name": "setPosition",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 横坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "横坐标"
                },
                {
                  "textRaw": "`y` {number} 纵坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "纵坐标"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ],
          "desc": "<p>设置控制台的位置, 单位像素.</p>\n<pre><code>console.show();\nconsole.setPosition(100, 100);\n</code></pre>"
        },
        {
          "textRaw": "console.setGlobalLogConfig(config)",
          "type": "method",
          "name": "setGlobalLogConfig",
          "desc": "<p><strong>[v4.1.0新增]</strong></p>\n<ul>\n<li><code>config</code> {Object} 日志配置, 可选的项有：<ul>\n<li><code>file</code> {string} 日志文件路径, 将会把日志写入该文件中</li>\n<li><code>maxFileSize</code> {number} 最大文件大小, 单位字节, 默认为512 * 1024 (512KB)</li>\n<li><code>rootLevel</code> {string} 写入的日志级别, 默认为&quot;ALL&quot;（所有日志）, 可以为&quot;OFF&quot;(关闭), &quot;DEBUG&quot;, &quot;INFO&quot;, &quot;WARN&quot;, &quot;ERROR&quot;, &quot;FATAL&quot;等.</li>\n<li><code>maxBackupSize</code> {number} 日志备份文件最大数量, 默认为5</li>\n<li><code>filePattern</code> {string} 日志写入格式, 参见<a href=\"http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html/\">PatternLayout</a></li>\n</ul>\n</li>\n</ul>\n<p>设置日志保存的路径和配置. 例如把日志保存到&quot;/sdcard/1.txt&quot;:</p>\n<pre><code>console.setGlobalLogConfig({\n    &quot;file&quot;: &quot;/sdcard/1.txt&quot;\n});\n</code></pre><p>注意该函数会影响所有脚本的日志记录.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "config"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "print(text)",
          "type": "method",
          "name": "print",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "text {string} | {Object} 要打印到控制台的信息 ",
                  "name": "text",
                  "type": "string",
                  "desc": "| {Object} 要打印到控制台的信息"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "text"
                }
              ]
            }
          ],
          "desc": "<p>相当于<code>log(text)</code>.</p>\n<!-- [end-include:console.md] -->\n<!-- [start-include:shell.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "控制台 (Console)"
    },
    {
      "textRaw": "Shell",
      "name": "shell",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>shell即Unix Shell, 在类Unix系统提供与操作系统交互的一系列命令.</p>\n<p>很多程序可以用来执行shell命令, 例如终端模拟器.</p>\n<p>在Auto.js大致等同于用adb执行命令&quot;adb shell&quot;. 其实现包括两种方式：</p>\n<ul>\n<li>通过<code>java.lang.Runtime.exec</code>执行(shell, Tap, Home等函数)</li>\n<li>通过内嵌终端模拟器执行(RootAutomator, Shell等对象)</li>\n</ul>\n",
      "type": "module",
      "displayName": "Shell"
    },
    {
      "textRaw": "shell函数",
      "name": "shell函数",
      "methods": [
        {
          "textRaw": "shell(cmd[, root])",
          "type": "method",
          "name": "shell",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "cmd {string} 要执行的命令 ",
                  "name": "cmd",
                  "type": "string",
                  "desc": "要执行的命令"
                },
                {
                  "textRaw": "root {Boolean} 是否以root权限运行, 默认为false. ",
                  "name": "root",
                  "type": "Boolean",
                  "desc": "是否以root权限运行, 默认为false.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "cmd"
                },
                {
                  "name": "root",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>一次性执行命令cmd, 并返回命令的执行结果. 返回对象的其属性如下:</p>\n<ul>\n<li>code {number} 返回码. 执行成功时为0, 失败时为非0的数字.</li>\n<li>result {string} 运行结果(stdout输出结果)</li>\n<li>error {string} 运行的错误信息(stderr输出结果). 例如执行需要root权限的命令但没有授予root权限会返回错误信息&quot;Permission denied&quot;.</li>\n</ul>\n<p>示例(强制停止微信) ：</p>\n<pre><code>var result = shell(&quot;am force-stop com.tencent.mm&quot;, true);\nlog(result);\nconsole.show();\nif(result.code == 0){\n  toast(&quot;执行成功&quot;);\n}else{\n  toast(&quot;执行失败！请到控制台查看错误信息&quot;);\n}\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "shell函数"
    },
    {
      "textRaw": "Shell",
      "name": "shell",
      "desc": "<p>shell函数通过用来一次性执行单条命令并获取结果. 如果有多条命令需要执行, 用Shell对象的效率更高. 这是因为, 每次运行shell函数都会打开一个单独的shell进程并在运行结束后关闭他, 这个过程需要一定的时间；而Shell对象自始至终使用同一个shell进程.</p>\n",
      "ctors": [
        {
          "textRaw": "new Shell(root)",
          "type": "ctor",
          "name": "Shell",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "root {Boolean} 是否以root权限运行一个shell进程, 默认为false. 这将会影响其后使用该Shell对象执行的命令的权限 ",
                  "name": "root",
                  "type": "Boolean",
                  "desc": "是否以root权限运行一个shell进程, 默认为false. 这将会影响其后使用该Shell对象执行的命令的权限"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "root"
                }
              ]
            }
          ],
          "desc": "<p>Shell对象的&quot;构造函数&quot;.</p>\n<pre><code>var sh = new Shell(true);\n//强制停止微信\nsh.exec(&quot;am force-stop com.tencent.mm&quot;);\nsh.exit();\n</code></pre>"
        }
      ],
      "methods": [
        {
          "textRaw": "Shell.exec(cmd)",
          "type": "method",
          "name": "exec",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`cmd` {string} 要执行的命令 ",
                  "name": "cmd",
                  "type": "string",
                  "desc": "要执行的命令"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "cmd"
                }
              ]
            }
          ],
          "desc": "<p>执行命令cmd. 该函数不会返回任何值.</p>\n<p>注意, 命令执行是&quot;异步&quot;的、非阻塞的. 也就是不会等待命令完成后才继续向下执行.</p>\n<p>尽管这样的设计使用起来有很多不便之处, 但受限于终端模拟器, 暂时没有解决方式；如果后续能找到解决方案, 则将提供<code>Shell.execAndWaitFor</code>函数.</p>\n"
        },
        {
          "textRaw": "Shell.exit()",
          "type": "method",
          "name": "exit",
          "desc": "<p>直接退出shell. 正在执行的命令会被强制退出.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Shell.exitAndWaitFor()",
          "type": "method",
          "name": "exitAndWaitFor",
          "desc": "<p>执行&quot;exit&quot;命令并等待执行命令执行完成、退出shell.</p>\n<p>此函数会执行exit命令来正常退出shell.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Shell.setCallback(callback)",
          "type": "method",
          "name": "setCallback",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "callback {Object} 回调函数 ",
                  "name": "callback",
                  "type": "Object",
                  "desc": "回调函数"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>设置该Shell的回调函数, 以便监听Shell的输出. 可以包括以下属性：</p>\n<ul>\n<li>onOutput {Function} 每当shell有新的输出时便会调用该函数. 其参数是一个字符串.</li>\n<li>onNewLine {Function} 每当shell有新的一行输出时便会调用该函数. 其参数是一个字符串(不包括最后的换行符).</li>\n</ul>\n<p>例如:</p>\n<pre><code>var sh = new Shell();\nsh.setCallback({\n    onNewLine: function(line){\n        //有新的一行输出时打印到控制台\n        log(line);\n    }\n})\nwhile(true){\n    //循环输入命令\n    var cmd = dialogs.rawInput(&quot;请输入要执行的命令, 输入exit退出&quot;);\n    if(cmd == &quot;exit&quot;){\n        break;\n    }\n    //执行命令\n    sh.exec(cmd);\n}\nsh.exit();\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "Shell"
    },
    {
      "textRaw": "附录: shell命令简介",
      "name": "附录:_shell命令简介",
      "desc": "<p>以下关于shell命令的资料来自<a href=\"https://developer.android.com/studio/command-line/adb.html#shellcommands/\">AndroidStudio用户指南：Shell命令</a>.</p>\n",
      "modules": [
        {
          "textRaw": "am命令",
          "name": "am命令",
          "desc": "<p>am命令即Activity Manager命令, 用于管理应用程序活动、服务等.</p>\n<p><strong>以下命令均以&quot;am &quot;开头, 例如<code>shell(&#39;am start -p com.tencent.mm&#39;);</code>(启动微信)</strong></p>\n",
          "modules": [
            {
              "textRaw": "start [options] intent",
              "name": "start_[options]_intent",
              "desc": "<p>启动 intent 指定的 Activity(应用程序活动).<br>请参阅 <a href=\"#shell_intent\">intent 参数的规范</a>.</p>\n<p>选项包括：</p>\n<ul>\n<li>-D：启用调试.</li>\n<li>-W：等待启动完成.</li>\n<li>--start-profiler file：启动分析器并将结果发送到 file.</li>\n<li>-P file：类似于 --start-profiler, 但当应用进入空闲状态时分析停止.</li>\n<li>-R count：重复 Activity 启动 count 次数. 在每次重复前, 将完成顶部 Activity.</li>\n<li>-S：启动 Activity 前强行停止目标应用.</li>\n<li>--opengl-trace：启用 OpenGL 函数的跟踪.</li>\n<li>--user user_id | current：指定要作为哪个用户运行；如果未指定, 则作为当前用户运行.</li>\n</ul>\n",
              "type": "module",
              "displayName": "start [options] intent"
            },
            {
              "textRaw": "startservice [options] intent",
              "name": "startservice_[options]_intent",
              "desc": "<p>启动 intent 指定的 Service(服务).<br>请参阅 <a href=\"#shell_intent\">intent 参数的规范</a>.<br>选项包括：</p>\n<ul>\n<li>--user user_id | current：指定要作为哪个用户运行；如果未指定, 则作为当前用户运行.</li>\n</ul>\n",
              "type": "module",
              "displayName": "startservice [options] intent"
            },
            {
              "textRaw": "force-stop package",
              "name": "force-stop_package",
              "desc": "<p>强行停止与 package（<a href=\"#应用包名\">应用包名</a>）关联的所有应用.</p>\n",
              "type": "module",
              "displayName": "force-stop package"
            },
            {
              "textRaw": "kill [options] package",
              "name": "kill_[options]_package",
              "desc": "<p>终止与 package（<a href=\"#应用包名\">应用包名</a>）关联的所有进程. 此命令仅终止可安全终止且不会影响用户体验的进程.<br>选项包括：</p>\n<ul>\n<li>--user user_id | all | current：指定将终止其进程的用户；如果未指定, 则终止所有用户的进程.</li>\n</ul>\n",
              "type": "module",
              "displayName": "kill [options] package"
            },
            {
              "textRaw": "kill-all",
              "name": "kill-all",
              "desc": "<p>终止所有后台进程.</p>\n",
              "type": "module",
              "displayName": "kill-all"
            },
            {
              "textRaw": "broadcast [options] intent",
              "name": "broadcast_[options]_intent",
              "desc": "<p>发出广播 intent.\n请参阅 <a href=\"#shell_intent\">intent 参数的规范</a>.</p>\n<p>选项包括：</p>\n<ul>\n<li>[--user user_id | all | current]：指定要发送到的用户；如果未指定, 则发送到所有用户.</li>\n</ul>\n",
              "type": "module",
              "displayName": "broadcast [options] intent"
            },
            {
              "textRaw": "instrument [options] component",
              "name": "instrument_[options]_component",
              "desc": "<p>使用 Instrumentation 实例启动监控. 通常, 目标 component 是表单 test_package/runner_class.<br>选项包括：</p>\n<ul>\n<li>-r：输出原始结果（否则对 report_key_streamresult 进行解码）. 与 [-e perf true] 结合使用以生成性能测量的原始输出.</li>\n<li>-e name value：将参数 name 设为 value. 对于测试运行器, 通用表单为 -e testrunner_flag value[,value...].</li>\n<li>-p file：将分析数据写入 file.</li>\n<li>-w：先等待仪器完成, 然后再返回. 测试运行器需要使用此选项.</li>\n<li>--no-window-animation：运行时关闭窗口动画.</li>\n<li>--user user_id | current：指定仪器在哪个用户中运行；如果未指定, 则在当前用户中运行.</li>\n<li>profile start process file 启动 process 的分析器, 将结果写入 file.</li>\n<li>profile stop process 停止 process 的分析器.</li>\n</ul>\n",
              "type": "module",
              "displayName": "instrument [options] component"
            },
            {
              "textRaw": "dumpheap [options] process file",
              "name": "dumpheap_[options]_process_file",
              "desc": "<p>转储 process 的堆, 写入 file.</p>\n<p>选项包括：</p>\n<ul>\n<li>--user [user_id|current]：提供进程名称时, 指定要转储的进程用户；如果未指定, 则使用当前用户.</li>\n<li>-n：转储原生堆, 而非托管堆.</li>\n<li>set-debug-app [options] package 将应用 package 设为调试.</li>\n</ul>\n<p>选项包括：</p>\n<ul>\n<li>-w：应用启动时等待调试程序.</li>\n<li>--persistent：保留此值.</li>\n<li>clear-debug-app 使用 set-debug-app 清除以前针对调试用途设置的软件包.</li>\n</ul>\n",
              "type": "module",
              "displayName": "dumpheap [options] process file"
            },
            {
              "textRaw": "monitor [options]    启动对崩溃或 ANR 的监控.",
              "name": "monitor_[options]_启动对崩溃或_anr_的监控.",
              "desc": "<p>选项包括：</p>\n<ul>\n<li>--gdb：在崩溃/ANR 时在给定端口上启动 gdbserv.</li>\n</ul>\n",
              "type": "module",
              "displayName": "monitor [options]    启动对崩溃或 ANR 的监控."
            },
            {
              "textRaw": "screen-compat {on|off} package",
              "name": "screen-compat_{on|off}_package",
              "desc": "<p>控制 package 的屏幕兼容性模式.</p>\n",
              "type": "module",
              "displayName": "screen-compat {on|off} package"
            },
            {
              "textRaw": "display-density dpi",
              "name": "display-density_dpi",
              "desc": "<p>替换模拟器/设备显示密度. 此命令对于在不同密度的屏幕上测试您的应用非常有用, 它支持使用低密度屏幕在高密度环境环境上进行测试（反之亦然）.<br>示例：</p>\n<pre><code>shell(&quot;am display-density 480&quot;, true);\n</code></pre>",
              "type": "module",
              "displayName": "display-density dpi"
            },
            {
              "textRaw": "to-uri intent",
              "name": "to-uri_intent",
              "desc": "<p>将给定的 intent 规范以 URI 的形式输出.\n请参阅  <a href=\"#shell_intent\">intent 参数的规范</a>.</p>\n",
              "type": "module",
              "displayName": "to-uri intent"
            },
            {
              "textRaw": "to-intent-uri intent",
              "name": "to-intent-uri_intent",
              "desc": "<p>将给定的 intent 规范以 intent:URI 的形式输出.\n请参阅 intent 参数的规范.</p>\n",
              "type": "module",
              "displayName": "to-intent-uri intent"
            },
            {
              "textRaw": "intent参数的规范",
              "name": "intent参数的规范",
              "desc": "<p>对于采用 intent 参数的 am 命令, 您可以使用以下选项指定 intent：</p>\n<ul>\n<li>-a action<br>指定 intent 操作, 如“android.intent.action.VIEW”. 此指定只能声明一次.</li>\n<li>-d data_uri<br>指定 intent 数据 URI, 如“content://contacts/people/1”. 此指定只能声明一次.</li>\n<li>-t mime_type<br>指定 intent MIME 类型, 如“image/png”. 此指定只能声明一次.</li>\n<li>-c category<br>指定 intent 类别, 如“android.intent.category.APP_CONTACTS”.</li>\n<li>-n component<br>指定带有软件包名称前缀的组件名称以创建显式 intent, 如“com.example.app/.ExampleActivity”.</li>\n<li>-f flags<br>将标志添加到 setFlags() 支持的 intent.</li>\n<li>--esn extra_key<br>添加一个 null extra. URI intent 不支持此选项.</li>\n<li>-e|--es extra_key extra_string_value<br>添加字符串数据作为键值对.</li>\n<li>--ez extra_key extra_boolean_value<br>添加布尔型数据作为键值对.</li>\n<li>--ei extra_key extra_int_value<br>添加整数型数据作为键值对.</li>\n<li>--el extra_key extra_long_value<br>添加长整型数据作为键值对.</li>\n<li>--ef extra_key extra_float_value<br>添加浮点型数据作为键值对.</li>\n<li>--eu extra_key extra_uri_value<br>添加 URI 数据作为键值对.</li>\n<li>--ecn extra_key extra_component_name_value<br>添加组件名称, 将其作为 ComponentName 对象进行转换和传递.</li>\n<li>--eia extra_key extra_int_value[,extra_int_value...]<br>添加整数数组.</li>\n<li>--ela extra_key extra_long_value[,extra_long_value...]<br>添加长整型数组.</li>\n<li>--efa extra_key extra_float_value[,extra_float_value...]<br>添加浮点型数组.</li>\n<li>--grant-read-uri-permission<br>包含标志 FLAG_GRANT_READ_URI_PERMISSION.</li>\n<li>--grant-write-uri-permission<br>包含标志 FLAG_GRANT_WRITE_URI_PERMISSION.</li>\n<li>--debug-log-resolution<br>包含标志 FLAG_DEBUG_LOG_RESOLUTION.</li>\n<li>--exclude-stopped-packages<br>包含标志 FLAG_EXCLUDE_STOPPED_PACKAGES.</li>\n<li>--include-stopped-packages<br>包含标志 FLAG_INCLUDE_STOPPED_PACKAGES.</li>\n<li>--activity-brought-to-front<br>包含标志 FLAG_ACTIVITY_BROUGHT_TO_FRONT.</li>\n<li>--activity-clear-top<br>包含标志 FLAG_ACTIVITY_CLEAR_TOP.</li>\n<li>--activity-clear-when-task-reset<br>包含标志 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET.</li>\n<li>--activity-exclude-from-recents<br>包含标志 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS.</li>\n<li>--activity-launched-from-history<br>包含标志 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY.</li>\n<li>--activity-multiple-task<br>包含标志 FLAG_ACTIVITY_MULTIPLE_TASK.</li>\n<li>--activity-no-animation<br>包含标志 FLAG_ACTIVITY_NO_ANIMATION.</li>\n<li>--activity-no-history<br>包含标志 FLAG_ACTIVITY_NO_HISTORY.</li>\n<li>--activity-no-user-action<br>包含标志 FLAG_ACTIVITY_NO_USER_ACTION.</li>\n<li>--activity-previous-is-top<br>包含标志 FLAG_ACTIVITY_PREVIOUS_IS_TOP.</li>\n<li>--activity-reorder-to-front<br>包含标志 FLAG_ACTIVITY_REORDER_TO_FRONT.</li>\n<li>--activity-reset-task-if-needed<br>包含标志 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED.</li>\n<li>--activity-single-top<br>包含标志 FLAG_ACTIVITY_SINGLE_TOP.</li>\n<li>--activity-clear-task<br>包含标志 FLAG_ACTIVITY_CLEAR_TASK.</li>\n<li>--activity-task-on-home<br>包含标志 FLAG_ACTIVITY_TASK_ON_HOME.</li>\n<li>--receiver-registered-only<br>包含标志 FLAG_RECEIVER_REGISTERED_ONLY.</li>\n<li>--receiver-replace-pending<br>包含标志 FLAG_RECEIVER_REPLACE_PENDING.</li>\n<li>--selector<br>需要使用 -d 和 -t 选项以设置 intent 数据和类型.</li>\n</ul>\n",
              "modules": [
                {
                  "textRaw": "URI component package",
                  "name": "uri_component_package",
                  "desc": "<p>如果不受上述某一选项的限制, 您可以直接指定 URI、软件包名称和组件名称. 当参数不受限制时, 如果参数包含一个“:”（冒号）, 则此工具假定参数是一个 URI；如果参数包含一个“/”（正斜杠）, 则此工具假定参数是一个组件名称；否则, 此工具假定参数是一个软件包名称.</p>\n",
                  "type": "module",
                  "displayName": "URI component package"
                }
              ],
              "type": "module",
              "displayName": "intent参数的规范"
            }
          ],
          "properties": [
            {
              "textRaw": "display-size [reset|widthxheight]",
              "name": "[reset|widthxheight]",
              "desc": "<p>替换模拟器/设备显示尺寸. 此命令对于在不同尺寸的屏幕上测试您的应用非常有用, 它支持使用大屏设备模仿小屏幕分辨率（反之亦然）.<br>示例：</p>\n<pre><code>shell(&quot;am display-size 1280x800&quot;, true);\n\n</code></pre>"
            }
          ],
          "type": "module",
          "displayName": "am命令"
        },
        {
          "textRaw": "应用包名",
          "name": "应用包名",
          "desc": "<p>所谓应用包名, 是唯一确定应用的标识. 例如微信的包名是&quot;com.tencent.mm&quot;, QQ的包名是&quot;com.tencent.mobileqq&quot;.<br>要获取一个应用的包名, 可以通过函数<code>getPackageName(appName)</code>获取. 参见帮助-&gt;其他一般函数.</p>\n",
          "type": "module",
          "displayName": "应用包名"
        },
        {
          "textRaw": "pm命令",
          "name": "pm命令",
          "desc": "<p>pm命令用于管理应用程序, 例如卸载应用、冻结应用等.<br><strong>以下命令均以&quot;pm &quot;开头, 例如&quot;shell(\\&quot;pm disable com.tencent.mm\\&quot;);&quot;(冻结微信)</strong></p>\n",
          "modules": [
            {
              "textRaw": "list packages [options] filter",
              "name": "list_packages_[options]_filter",
              "desc": "<p>输出所有软件包, 或者, 仅输出包名称包含 filter 中的文本的软件包.<br>选项：</p>\n<ul>\n<li>-f：查看它们的关联文件.</li>\n<li>-d：进行过滤以仅显示已停用的软件包.</li>\n<li>-e：进行过滤以仅显示已启用的软件包.</li>\n<li>-s：进行过滤以仅显示系统软件包.</li>\n<li>-3：进行过滤以仅显示第三方软件包.</li>\n<li>-i：查看软件包的安装程序.</li>\n<li>-u：也包括卸载的软件包.</li>\n<li>--user user_id：要查询的用户空间.</li>\n</ul>\n",
              "type": "module",
              "displayName": "list packages [options] filter"
            },
            {
              "textRaw": "list permission-groups",
              "name": "list_permission-groups",
              "desc": "<p>输出所有已知的权限组.</p>\n",
              "type": "module",
              "displayName": "list permission-groups"
            },
            {
              "textRaw": "list permissions [options] group",
              "name": "list_permissions_[options]_group",
              "desc": "<p>输出所有已知权限, 或者, 仅输出 group 中的权限.<br>选项：</p>\n<ul>\n<li>-g：按组加以组织.</li>\n<li>-f：输出所有信息.</li>\n<li>-s：简短摘要.</li>\n<li>-d：仅列出危险权限.</li>\n<li>-u：仅列出用户将看到的权限.</li>\n</ul>\n",
              "type": "module",
              "displayName": "list permissions [options] group"
            },
            {
              "textRaw": "list features",
              "name": "list_features",
              "desc": "<p>输出系统的所有功能.</p>\n",
              "type": "module",
              "displayName": "list features"
            },
            {
              "textRaw": "list libraries",
              "name": "list_libraries",
              "desc": "<p>输出当前设备支持的所有库.</p>\n",
              "type": "module",
              "displayName": "list libraries"
            },
            {
              "textRaw": "list users",
              "name": "list_users",
              "desc": "<p>输出系统上的所有用户.</p>\n",
              "type": "module",
              "displayName": "list users"
            },
            {
              "textRaw": "path package",
              "name": "path_package",
              "desc": "<p>输出给定 package 的 APK 的路径.</p>\n",
              "type": "module",
              "displayName": "path package"
            },
            {
              "textRaw": "install [options] path",
              "name": "install_[options]_path",
              "desc": "<p>将软件包（通过 path 指定）安装到系统.<br>选项：</p>\n<ul>\n<li>-l：安装具有转发锁定功能的软件包.</li>\n<li>-r：重新安装现有应用, 保留其数据.</li>\n<li>-t：允许安装测试 APK.</li>\n<li>-i installer_package_name：指定安装程序软件包名称.</li>\n<li>-s：在共享的大容量存储（如 sdcard）上安装软件包.</li>\n<li>-f：在内部系统内存上安装软件包.</li>\n<li>-d：允许版本代码降级.</li>\n<li>-g：授予应用清单文件中列出的所有权限.</li>\n</ul>\n",
              "type": "module",
              "displayName": "install [options] path"
            },
            {
              "textRaw": "uninstall [options] package",
              "name": "uninstall_[options]_package",
              "desc": "<p>从系统中卸载软件包.<br>选项：</p>\n<ul>\n<li>-k：移除软件包后保留数据和缓存目录.</li>\n</ul>\n",
              "type": "module",
              "displayName": "uninstall [options] package"
            },
            {
              "textRaw": "clear package",
              "name": "clear_package",
              "desc": "<p>删除与软件包关联的所有数据.</p>\n",
              "type": "module",
              "displayName": "clear package"
            },
            {
              "textRaw": "enable package_or_component",
              "name": "enable_package_or_component",
              "desc": "<p>启用给定软件包或组件（作为“package/class”写入）.</p>\n",
              "type": "module",
              "displayName": "enable package_or_component"
            },
            {
              "textRaw": "disable package_or_component",
              "name": "disable_package_or_component",
              "desc": "<p>停用给定软件包或组件（作为“package/class”写入）.</p>\n",
              "type": "module",
              "displayName": "disable package_or_component"
            },
            {
              "textRaw": "disable-user [options] package_or_component",
              "name": "disable-user_[options]_package_or_component",
              "desc": "<p>选项：</p>\n<ul>\n<li>--user user_id：要停用的用户.</li>\n</ul>\n",
              "type": "module",
              "displayName": "disable-user [options] package_or_component"
            },
            {
              "textRaw": "grant package_name permission",
              "name": "grant_package_name_permission",
              "desc": "<p>向应用授予权限. 在运行 Android 6.0（API 级别 23）及更高版本的设备上, 可以是应用清单中声明的任何权限. 在运行 Android 5.1（API 级别 22）和更低版本的设备上, 必须是应用定义的可选权限.</p>\n",
              "type": "module",
              "displayName": "grant package_name permission"
            },
            {
              "textRaw": "revoke package_name permission",
              "name": "revoke_package_name_permission",
              "desc": "<p>从应用中撤销权限. 在运行 Android 6.0（API 级别 23）及更高版本的设备上, 可以是应用清单中声明的任何权限. 在运行 Android 5.1（API 级别 22）和更低版本的设备上, 必须是应用定义的可选权限.</p>\n",
              "type": "module",
              "displayName": "revoke package_name permission"
            },
            {
              "textRaw": "set-install-location location",
              "name": "set-install-location_location",
              "desc": "<p>更改默认安装位置. 位置值：</p>\n<ul>\n<li>0：自动—让系统决定最佳位置.</li>\n<li>1：内部—安装在内部设备存储上.</li>\n<li>2：外部—安装在外部介质上.</li>\n</ul>\n<blockquote>\n<p>注：此命令仅用于调试目的；使用此命令会导致应用中断和其他意外行为.</p>\n</blockquote>\n",
              "type": "module",
              "displayName": "set-install-location location"
            },
            {
              "textRaw": "get-install-location",
              "name": "get-install-location",
              "desc": "<p>返回当前安装位置. 返回值：</p>\n<ul>\n<li>0 [auto]：让系统决定最佳位置.</li>\n<li>1 [internal]：安装在内部设备存储上</li>\n<li>2 [external]：安装在外部介质上</li>\n</ul>\n",
              "type": "module",
              "displayName": "get-install-location"
            },
            {
              "textRaw": "trim-caches desired_free_space",
              "name": "trim-caches_desired_free_space",
              "desc": "<p>减少缓存文件以达到给定的可用空间.</p>\n",
              "type": "module",
              "displayName": "trim-caches desired_free_space"
            },
            {
              "textRaw": "create-user user_name",
              "name": "create-user_user_name",
              "desc": "<p>使用给定的 user_name 创建新用户, 输出新用户的标识符.</p>\n",
              "type": "module",
              "displayName": "create-user user_name"
            },
            {
              "textRaw": "remove-user user_id",
              "name": "remove-user_user_id",
              "desc": "<p>移除具有给定的 user_id 的用户, 删除与该用户关联的所有数据.</p>\n",
              "type": "module",
              "displayName": "remove-user user_id"
            },
            {
              "textRaw": "get-max-users",
              "name": "get-max-users",
              "desc": "<p>输出设备支持的最大用户数.</p>\n",
              "type": "module",
              "displayName": "get-max-users"
            }
          ],
          "properties": [
            {
              "textRaw": "list instrumentation [options]",
              "name": "[options]",
              "desc": "<p>列出所有测试软件包.<br>选项：</p>\n<ul>\n<li>-f：列出用于测试软件包的 APK 文件.</li>\n<li>target_package：列出仅用于此应用的测试软件包.</li>\n</ul>\n"
            },
            {
              "textRaw": "set-permission-enforced permission [true|false]",
              "name": "[true|false]",
              "desc": "<p>指定是否应强制执行给定的权限.</p>\n"
            }
          ],
          "type": "module",
          "displayName": "pm命令"
        },
        {
          "textRaw": "其他命令",
          "name": "其他命令",
          "modules": [
            {
              "textRaw": "进行屏幕截图",
              "name": "进行屏幕截图",
              "desc": "<p>screencap 命令是一个用于对设备显示屏进行屏幕截图的 shell 实用程序. 在 shell 中, 此语法为：</p>\n<pre><code>screencap filename\n</code></pre><p>例如：</p>\n<pre><code>$ shell(&quot;screencap /sdcard/screen.png&quot;);\n</code></pre>",
              "type": "module",
              "displayName": "进行屏幕截图"
            },
            {
              "textRaw": "列表文件",
              "name": "列表文件",
              "desc": "<pre><code>ls filepath\n</code></pre><p>例如:</p>\n<pre><code>log(shell(&quot;ls /system/bin&quot;).result);\n</code></pre><!-- [end-include:shell.md] -->\n<!-- [start-include:media.md] -->\n",
              "type": "module",
              "displayName": "列表文件"
            }
          ],
          "type": "module",
          "displayName": "其他命令"
        }
      ],
      "type": "module",
      "displayName": "附录: shell命令简介"
    },
    {
      "textRaw": "多媒体 (Media)",
      "name": "多媒体_(media)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>media模块提供多媒体编程的支持. 目前仅支持音乐播放和媒体文件扫描. 后续会结合UI加入视频播放等功能.</p>\n<p>需要注意是, 使用该模块播放音乐时是在后台异步播放的, 在脚本结束后会自动结束播放, 因此可能需要插入诸如<code>sleep()</code>的语句来使脚本保持运行. 例如：</p>\n<pre><code>//播放音乐\nmedia.playMusic(&quot;/sdcard/1.mp3&quot;);\n//让音乐播放完\nsleep(media.getMusicDuration());\n</code></pre>",
      "methods": [
        {
          "textRaw": "media.scanFile(path)",
          "type": "method",
          "name": "scanFile",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 媒体文件路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "媒体文件路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ],
          "desc": "<p>扫描路径path的媒体文件, 将它加入媒体库中；或者如果该文件以及被删除, 则通知媒体库移除该文件.</p>\n<p>媒体库包括相册、音乐库等, 因此该函数可以用于把某个图片文件加入相册.</p>\n<pre><code>//请求截图\nrequestScreenCapture(false);\n//截图\nvar im = captureScreen();\nvar path = &quot;/sdcard/screenshot.png&quot;;\n//保存图片\nim.saveTo(path);\n//把图片加入相册\nmedia.scanFile(path);\n</code></pre>"
        },
        {
          "textRaw": "media.playMusic(path[, volume, looping])",
          "type": "method",
          "name": "playMusic",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`path` {string} 音乐文件路径 ",
                  "name": "path",
                  "type": "string",
                  "desc": "音乐文件路径"
                },
                {
                  "textRaw": "`volume` {number} 播放音量, 为0~1的浮点数, 默认为1 ",
                  "name": "volume",
                  "type": "number",
                  "desc": "播放音量, 为0~1的浮点数, 默认为1",
                  "optional": true
                },
                {
                  "textRaw": "`looping` {boolean} 是否循环播放, 如果looping为`true`则循环播放, 默认为`false` ",
                  "name": "looping",
                  "type": "boolean",
                  "desc": "是否循环播放, 如果looping为`true`则循环播放, 默认为`false`",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "volume",
                  "optional": true
                },
                {
                  "name": "looping",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>播放音乐文件path. 该函数不会显示任何音乐播放界面. 如果文件不存在或者文件不是受支持的音乐格式, 则抛出<code>UncheckedIOException</code>异常.</p>\n<pre><code>//播放音乐\nmedia.playMusic(&quot;/sdcard/1.mp3&quot;);\n//让音乐播放完\nsleep(media.getMusicDuration());\n</code></pre><p>如果要循环播放音乐, 则使用looping参数：</p>\n<pre><code>\n</code></pre><p>//传递第三个参数为true以循环播放音乐\nmedia.playMusic(&quot;/sdcard/1.mp3&quot;, 1, true);\n//等待三次播放的时间\nsleep(media.getMusicDuration() * 3);</p>\n<pre><code>\n</code></pre><p>如果要使用音乐播放器播放音乐, 调用<code>app.viewFile(path)</code>函数.</p>\n"
        },
        {
          "textRaw": "media.musicSeekTo(msec)",
          "type": "method",
          "name": "musicSeekTo",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`msec` {number} 毫秒数, 表示音乐进度 ",
                  "name": "msec",
                  "type": "number",
                  "desc": "毫秒数, 表示音乐进度"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "msec"
                }
              ]
            }
          ],
          "desc": "<p>把当前播放进度调整到时间msec的位置. 如果当前没有在播放音乐, 则调用函数没有任何效果.</p>\n<p>例如, 要把音乐调到1分钟的位置, 为<code>media.musicSeekTo(60 * 1000)</code>.</p>\n<pre><code>//播放音乐\nmedia.playMusic(&quot;/sdcard/1.mp3&quot;);\n//调整到30秒的位置\nmedia.musicSeekTo(30 * 1000);\n//等待音乐播放完成\nsleep(media.getMusicDuration() - 30 * 1000);\n</code></pre>"
        },
        {
          "textRaw": "media.pauseMusic()",
          "type": "method",
          "name": "pauseMusic",
          "desc": "<p>暂停音乐播放. 如果当前没有在播放音乐, 则调用函数没有任何效果.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "media.resumeMusic()",
          "type": "method",
          "name": "resumeMusic",
          "desc": "<p>继续音乐播放. 如果当前没有播放过音乐, 则调用该函数没有任何效果.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "media.stopMusic()",
          "type": "method",
          "name": "stopMusic",
          "desc": "<p>停止音乐播放. 如果当前没有在播放音乐, 则调用函数没有任何效果.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "media.isMusicPlaying()",
          "type": "method",
          "name": "isMusicPlaying",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前是否正在播放音乐.</p>\n"
        },
        {
          "textRaw": "media.getMusicDuration()",
          "type": "method",
          "name": "getMusicDuration",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前音乐的时长. 单位毫秒.</p>\n"
        },
        {
          "textRaw": "media.getMusicCurrentPosition()",
          "type": "method",
          "name": "getMusicCurrentPosition",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前音乐的播放进度(已经播放的时间), 单位毫秒.\n<!-- [end-include:media.md] --></p>\n<!-- [start-include:sensors.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "多媒体 (Media)"
    },
    {
      "textRaw": "传感器 (Sensors)",
      "name": "传感器_(sensors)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>sensors模块提供了获取手机上的传感器的信息的支持, 这些传感器包括距离传感器、光线光感器、重力传感器、方向传感器等. 需要指出的是, 脚本只能获取传感器的数据, <strong>不能模拟或伪造传感器的数据和事件</strong>, 因此诸如模拟摇一摇的功能是无法实现的.</p>\n<p>要监听一个传感器时, 需要使用<code>sensors.register()</code>注册监听器, 之后才能开始监听；不需要监听时则调用<code>sensors.unregister()</code>注销监听器. 在脚本结束时会自动注销所有的监听器. 同时, 这种监听会使脚本保持运行状态, 如果不注销监听器, 脚本会一直保持运行状态.</p>\n<p>例如, 监听光线传感器的代码为：</p>\n<pre><code>//光线传感器监听\nsensors.register(&quot;light&quot;).on(&quot;change&quot;, (event, light)=&gt;{\n    log(&quot;当前光强度为&quot;, light);\n});\n</code></pre><p>要注意的是, 每个传感器的数据并不相同, 所以对他们调用<code>on()</code>监听事件时的回调函数参数也不是相同, 例如光线传感器参数为<code>(event, light)</code>, 加速度传感器参数为<code>(event, ax, ay, az)</code>. 甚至在某些设备上的传感器参数有所增加, 例如华为手机的距离传感器为三个参数, 一般手机只有一个参数.</p>\n<p>常用的传感器及其事件参数如下表：</p>\n<ul>\n<li><p><code>accelerometer</code> 加速度传感器, 参数<code>(event, ax, ay, az)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>ax</code> {number} x轴上的加速度, 单位m/s^2</li>\n<li><code>ay</code> {number} y轴上的加速度, 单位m/s^2</li>\n<li><code>az</code> {number} z轴上的加速度, 单位m/s^2\n这里的x轴, y轴, z轴所属的坐标系统如下图(其中z轴垂直于设备屏幕表面):</li>\n</ul>\n<p>!<img src=\"#images/axis_device.png\" alt=\"axis_device\"></p>\n</li>\n<li><p><code>orientation</code> 方向传感器, 参数<code>(event, azimuth, pitch, roll)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>azimuth</code> {number} 方位角, 从地磁指北方向线起, 依顺时针方向到y轴之间的水平夹角, 单位角度, 范围0~359</li>\n<li><code>pitch</code> {number} 绕x轴旋转的角度, 当设备水平放置时该值为0, 当设备顶部翘起时该值为正数, 当设备尾部翘起时该值为负数, 单位角度, 范围-180~180</li>\n<li><code>roll</code> {number} 绕y轴顺时针旋转的角度, 单位角度, 范围-90~90</li>\n</ul>\n</li>\n<li><p><code>gyroscope</code> 陀螺仪传感器, 参数<code>(event, wx, wy, wz)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>wx</code> {number} 绕x轴的角速度, 单位弧度/s</li>\n<li><code>wy</code> {number} 绕y轴的角速度, 单位弧度/s</li>\n<li><code>wz</code> {number} 绕z轴的角速度, 单位弧度/s</li>\n</ul>\n</li>\n<li><p><code>magnetic_field</code> 磁场传感器, 参数<code>(event, bx, by, bz)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>bx</code> {number} x轴上的磁场强度, 单位uT</li>\n<li><code>by</code> {number} y轴上的磁场强度, 单位uT</li>\n<li><code>bz</code> {number} z轴上的磁场强度, 单位uT</li>\n</ul>\n</li>\n<li><p><code>gravity</code> 重力传感器, 参数<code>(event, gx, gy, gz)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>gx</code> {number} x轴上的重力加速度, 单位m/s^2</li>\n<li><code>gy</code> {number} y轴上的重力加速度, 单位m/s^2</li>\n<li><code>gz</code> {number} z轴上的重力加速度, 单位m/s^2</li>\n</ul>\n</li>\n<li><p><code>linear_acceleration</code> 线性加速度传感器, 参数<code>(event, ax, ay, az)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>ax</code> {number} x轴上的线性加速度, 单位m/s^2</li>\n<li><code>ay</code> {number} y轴上的线性加速度, 单位m/s^2</li>\n<li><code>az</code> {number} z轴上的线性加速度, 单位m/s^2</li>\n</ul>\n</li>\n<li><p><code>ambient_temperature</code> 环境温度传感器, 大部分设备并不支持, 参数<code>(event, t)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>t</code> {number} 环境温度, 单位摄氏度.</li>\n</ul>\n</li>\n<li><p><code>light</code> 光线传感器, 参数<code>(event, light)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>light</code> {number} 环境光强度, 单位lux</li>\n</ul>\n</li>\n<li><p><code>pressure</code> 压力传感器, 参数<code>(event, p)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>p</code> {number} 大气压, 单位hPa</li>\n</ul>\n</li>\n<li><p><code>proximity</code> 距离传感器, 参数<code>(event, distance)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>distance</code> {number} 一般指设备前置摄像头旁边的距离传感器到前方障碍物的距离, 并且很多设备上这个值只有两种情况：当障碍物较近时该值为0, 当障碍物较远或在范围内没有障碍物时该值为5</li>\n</ul>\n</li>\n<li><p><code>relative_humidity</code> 湿度传感器, 大部分设备并不支持, 参数<code>(event, rh)</code>:</p>\n<ul>\n<li><code>event</code> <a href=\"#sensors_sensorevent\">SensorEvent</a> 传感器事件, 用于获取传感器数据变化时的所有信息</li>\n<li><code>rh</code> {number} 相对湿度, 范围为0~100（百分比）</li>\n</ul>\n</li>\n</ul>\n",
      "methods": [
        {
          "textRaw": "sensors.register(sensorName[, delay])",
          "type": "method",
          "name": "register",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`sensorName` {string} 传感器名称, 常用的传感器名称如上面所述 ",
                  "name": "sensorName",
                  "type": "string",
                  "desc": "传感器名称, 常用的传感器名称如上面所述"
                },
                {
                  "textRaw": "`delay` {number} 传感器数据更新频率, 可选, 默认为`sensors.delay.normal`. 可用的值如下： ",
                  "options": [
                    {
                      "textRaw": "`sensors.delay.normal` 正常频率 ",
                      "name": "sensors.delay.normal",
                      "desc": "正常频率"
                    },
                    {
                      "textRaw": "`sensors.delay.ui` 适合于用户界面的更新频率 ",
                      "name": "sensors.delay.ui",
                      "desc": "适合于用户界面的更新频率"
                    },
                    {
                      "textRaw": "`sensors.delay.game` 适合于游戏的更新频率 ",
                      "name": "sensors.delay.game",
                      "desc": "适合于游戏的更新频率"
                    },
                    {
                      "textRaw": "`sensors.delay.fastest` 最快的更新频率】 ",
                      "name": "sensors.delay.fastest",
                      "desc": "最快的更新频率】"
                    }
                  ],
                  "name": "delay",
                  "type": "number",
                  "desc": "传感器数据更新频率, 可选, 默认为`sensors.delay.normal`. 可用的值如下：",
                  "optional": true
                },
                {
                  "textRaw": "返回 [SensorEventEmiiter](#sensors_sensoreventemitter) ",
                  "name": "返回",
                  "desc": "[SensorEventEmiiter](#sensors_sensoreventemitter)"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "sensorName"
                },
                {
                  "name": "delay",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>注册一个传感器监听并返回<a href=\"#sensors_sensoreventemitter\">SensorEventEmitter</a>.</p>\n<p>例如:</p>\n<pre><code>console.show();\n//注册传感器监听\nvar sensor = sensors.register(&quot;gravity&quot;);\nif(sensor == null){\n    toast(&quot;不支持重力传感器&quot;);\n    exit();\n}\n//监听数据\nsensor.on(&quot;change&quot;, (gx, gy, gz)=&gt;{\n    log(&quot;重力加速度: %d, %d, %d&quot;, gx, gy, gz);\n});\n</code></pre><p>可以通过delay参数来指定传感器数据的更新频率, 例如：</p>\n<pre><code>var sensor = sensors.register(&quot;gravity&quot;, sensors.delay.game);\n</code></pre><p>另外, 如果不支持<code>sensorName</code>所指定的传感器, 那么该函数将返回<code>null</code>；但如果<code>sensors.ignoresUnsupportedSensor</code>的值被设置为<code>true</code>, 则该函数会返回一个不会分发任何传感器事件的<a href=\"#sensors_sensoreventemitter\">SensorEventEmitter</a>.</p>\n<p>例如:</p>\n<pre><code>sensors.ignoresUnsupportedSensor = true;\n//无需null判断\nsensors.register(&quot;gravity&quot;).on(&quot;change&quot;, (gx, gy, gz)=&gt;{\n    log(&quot;重力加速度: %d, %d, %d&quot;, gx, gy, gz);\n});\n</code></pre><p>更多信息, 参见<a href=\"#sensors_sensoreventemitter\">SensorEventEmitter</a>和<a href=\"#sensors_sensors_ignoresUnsupportedSensor\">sensors.ignoresUnsupportedSensor</a>.</p>\n"
        },
        {
          "textRaw": "sensors.unregister(emitter)",
          "type": "method",
          "name": "unregister",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`emiiter` [SensorEventEmitter](#sensors_sensoreventemitter) ",
                  "name": "emiiter",
                  "desc": "[SensorEventEmitter](#sensors_sensoreventemitter)"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "emitter"
                }
              ]
            }
          ],
          "desc": "<p>注销该传感器监听器. 被注销的监听器将不再能监听传感器数据.</p>\n<pre><code>//注册一个传感器监听器\nvar sensor = sensors.register(&quot;gravity&quot;);\nif(sensor == null){\n    exit();\n}\n//2秒后注销该监听器\nsetTimeout(()=&gt; {\n    sensors.unregister(sensor);\n}, 2000);\n</code></pre>"
        },
        {
          "textRaw": "sensors.unregisterAll()",
          "type": "method",
          "name": "unregisterAll",
          "desc": "<p>注销所有传感器监听器.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`ignoresUnsupportedSensor` {boolean} ",
          "type": "boolean",
          "name": "ignoresUnsupportedSensor",
          "desc": "<p>表示是否忽略不支持的传感器. 如果该值被设置为<code>true</code>, 则函数<code>sensors.register()</code>即使对不支持的传感器也会返回一个无任何数据的虚拟传感器监听, 也就是<code>sensors.register()</code>不会返回<code>null</code>从而避免非空判断, 并且此时会触发<code>sensors</code>的&quot;unsupported_sensor&quot;事件.</p>\n<pre><code>//忽略不支持的传感器\nsensors.ignoresUnsupportedSensor = true;\n//监听有不支持的传感器时的事件\nsensors.on(&quot;unsupported_sensor&quot;, function(sensorName){\n    toastLog(&quot;不支持的传感器: &quot; + sensorName);\n});\n//随便注册一个不存在的传感器.\nlog(sensors.register(&quot;aaabbb&quot;));\n</code></pre>"
        }
      ],
      "modules": [
        {
          "textRaw": "事件: 'unsupported_sensor'",
          "name": "事件:_'unsupported_sensor'",
          "desc": "<ul>\n<li><code>sensorName</code> {string} 不支持的传感器名称</li>\n</ul>\n<p>当<code>sensors.ignoresUnsupportedSensor</code>被设置为<code>true</code>并且有不支持的传感器被注册时触发该事件. 事件参数的传感器名称.</p>\n",
          "type": "module",
          "displayName": "事件: 'unsupported_sensor'"
        }
      ],
      "type": "module",
      "displayName": "传感器 (Sensors)"
    },
    {
      "textRaw": "SensorEventEmitter",
      "name": "sensoreventemitter",
      "desc": "<p>注册传感器返回的对象, 其本身是一个EventEmmiter, 用于监听传感器事件.</p>\n",
      "modules": [
        {
          "textRaw": "事件: 'change'",
          "name": "事件:_'change'",
          "desc": "<ul>\n<li><code>..args</code> {Any} 传感器参数</li>\n</ul>\n<p>当传感器数据改变时触发该事件；该事件触发的最高频繁由<code>sensors.register()</code>指定的delay参数决定.</p>\n<p>事件参数根据传感器类型不同而不同, 具体参见本章最前面的列表.</p>\n<p>一个监听光线传感器和加速度传感器并且每0.5秒获取一个数据并最终写入一个csv表格文件的例子如下：</p>\n<pre><code>//csv文件路径\ncosnt csvPath = &quot;/sdcard/sensors_data.csv&quot;;\n//记录光线传感器的数据\nvar light = 0;\n//记录加速度传感器的数据\nvar ax = 0;\nvar ay = 0;\nvar az = 0;\n//监听光线传感器\nsensors.register(&quot;light&quot;, sensors.delay.fastest)\n    .on(&quot;change&quot;, l =&gt; {\n        light = l;\n    });\n//监听加速度传感器\nsensors.register(&quot;accelerometer&quot;, sensors.delay.fastest)\n    .on(&quot;change&quot;, (ax0, ay0, az0) =&gt; {\n        ax = ax0;\n        ay = ay0;\n        az = az0;\n    });\n\nvar file = open(csvPath, &quot;w&quot;);\n//写csv表格头\nfile.writeline(&quot;light,ax,ay,az&quot;)\n//每0.5秒获取一次数据并写入文件\nsetInterval(()=&gt;{\n    file.writeline(util.format(&quot;%d,%d,%d,%d&quot;, light, ax, ay, az));\n}, 500);\n//10秒后退出并打开文件\nsetTimeout(()=&gt;{\n    file.close();\n    sensors.unregsiterAll();\n    app.viewFile(csvPath);\n}, 10 * 1000);\n\n</code></pre>",
          "type": "module",
          "displayName": "事件: 'change'"
        },
        {
          "textRaw": "事件: 'accuracy_change'",
          "name": "事件:_'accuracy_change'",
          "desc": "<ul>\n<li><code>accuracy</code> {number} 表示传感器精度. 为以下值之一:<ul>\n<li>-1 传感器未连接</li>\n<li>0 传感器不可读</li>\n<li>1 低精度</li>\n<li>2 中精度</li>\n<li>3 高精度</li>\n</ul>\n</li>\n</ul>\n<p>当传感器精度改变时会触发的事件. 比较少用.</p>\n<!-- [end-include:sensors.md] -->\n<!-- [start-include:recorder.md] -->\n",
          "type": "module",
          "displayName": "事件: 'accuracy_change'"
        }
      ],
      "type": "module",
      "displayName": "SensorEventEmitter"
    },
    {
      "textRaw": "记录器 (Recorder)",
      "name": "记录器_(recorder)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>记录器用于计时.</p>\n<blockquote>\n<p>注: 为避免与 Timers (定时器) 混淆, 本条目不采用 &quot;计时器&quot; 定义.</p>\n</blockquote>\n<hr>\n<p style=\"font: bold 2em sans-serif; color: #FF7043\">recorder</p>\n\n<hr>\n",
      "modules": [
        {
          "textRaw": "[@] recorder",
          "name": "[@]_recorder",
          "methods": [
            {
              "textRaw": "recorder(func)",
              "type": "method",
              "name": "recorder",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "func"
                    },
                    {
                      "name": "thisType"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "func"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "recorder(func, thisType)",
              "type": "method",
              "name": "recorder",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "func"
                    },
                    {
                      "name": "thisType"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[@] recorder"
        },
        {
          "textRaw": "[m] save",
          "name": "[m]_save",
          "methods": [
            {
              "textRaw": "save(key)",
              "type": "method",
              "name": "save",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "key"
                    },
                    {
                      "name": "timestamp"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "save(key, timestamp)",
              "type": "method",
              "name": "save",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "key"
                    },
                    {
                      "name": "timestamp"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] save"
        },
        {
          "textRaw": "[m] load",
          "name": "[m]_load",
          "methods": [
            {
              "textRaw": "load(key)",
              "type": "method",
              "name": "load",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "key"
                    },
                    {
                      "name": "timestamp"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "load(key, timestamp)",
              "type": "method",
              "name": "load",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "key"
                    },
                    {
                      "name": "timestamp"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] load"
        },
        {
          "textRaw": "[m] isLessThan",
          "name": "[m]_islessthan",
          "methods": [
            {
              "textRaw": "isLessThan(key, compare)",
              "type": "method",
              "name": "isLessThan",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "key"
                    },
                    {
                      "name": "compare"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] isLessThan"
        },
        {
          "textRaw": "[m] isGreaterThan",
          "name": "[m]_isgreaterthan",
          "methods": [
            {
              "textRaw": "isGreaterThan(key, compare)",
              "type": "method",
              "name": "isGreaterThan",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "key"
                    },
                    {
                      "name": "compare"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] isGreaterThan"
        },
        {
          "textRaw": "[m] has",
          "name": "[m]_has",
          "methods": [
            {
              "textRaw": "has(key)",
              "type": "method",
              "name": "has",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] has"
        },
        {
          "textRaw": "[m] remove",
          "name": "[m]_remove",
          "methods": [
            {
              "textRaw": "remove(key)",
              "type": "method",
              "name": "remove",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] remove"
        },
        {
          "textRaw": "[m] clear",
          "name": "[m]_clear",
          "methods": [
            {
              "textRaw": "clear()",
              "type": "method",
              "name": "clear",
              "desc": "<!-- [end-include:recorder.md] -->\n<!-- [start-include:timers.md] -->\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "[m] clear"
        }
      ],
      "type": "module",
      "displayName": "记录器 (Recorder)"
    },
    {
      "textRaw": "定时器 (Timers)",
      "name": "定时器_(timers)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>timers 模块暴露了一个全局的 API, 用于在某个未来时间段调用调度函数.  因为定时器函数是全局的, 所以使用该 API 无需调用 timers.***</p>\n<p>Auto.js 中的计时器函数实现了与 Web 浏览器提供的定时器类似的 API, 除了它使用了一个不同的内部实现, 它是基于 Android Looper-Handler消息循环机制构建的. 其实现机制与Node.js比较相似.</p>\n<p>例如, 要在5秒后发出消息&quot;hello&quot;:</p>\n<pre><code>setTimeout(function(){\n    toast(&quot;hello&quot;)\n}, 5000);\n</code></pre><p>需要注意的是, 这些定时器仍然是单线程的. 如果脚本主体有耗时操作或死循环, 则设定的定时器不能被及时执行, 例如：</p>\n<pre><code>setTimeout(function(){\n    //这里的语句会在15秒后执行而不是5秒后\n    toast(&quot;hello&quot;)\n}, 5000);\n//暂停10秒\nsleep(10000);\n</code></pre><p>再如：</p>\n<pre><code>setTimeout(function(){\n    //这里的语句永远不会被执行\n    toast(&quot;hello&quot;)\n}, 5000);\n//死循环\nwhile(true);\n</code></pre>",
      "methods": [
        {
          "textRaw": "setInterval(callback, delay\\[, ...args\\])",
          "type": "method",
          "name": "setInterval",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`callback` {Function} 当定时器到点时要调用的函数. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "当定时器到点时要调用的函数."
                },
                {
                  "textRaw": "`delay` {number} 调用 callback 之前要等待的毫秒数. ",
                  "name": "delay",
                  "type": "number",
                  "desc": "调用 callback 之前要等待的毫秒数."
                },
                {
                  "textRaw": "`...args` {any} 当调用 callback 时要传入的可选参数. ",
                  "name": "...args",
                  "type": "any",
                  "desc": "当调用 callback 时要传入的可选参数.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay\\"
                },
                {
                  "name": "...args\\",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>预定每隔 delay 毫秒重复执行的 callback.  返回一个用于 clearInterval() 的 id.</p>\n<p>当 delay 小于 0 时, delay 会被设为 0.</p>\n"
        },
        {
          "textRaw": "setTimeout(callback, delay\\[, ...args\\])",
          "type": "method",
          "name": "setTimeout",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`callback` {Function} 当定时器到点时要调用的函数. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "当定时器到点时要调用的函数."
                },
                {
                  "textRaw": "`delay` {number} 调用 callback 之前要等待的毫秒数. ",
                  "name": "delay",
                  "type": "number",
                  "desc": "调用 callback 之前要等待的毫秒数."
                },
                {
                  "textRaw": "`...args` {any} 当调用 callback 时要传入的可选参数. ",
                  "name": "...args",
                  "type": "any",
                  "desc": "当调用 callback 时要传入的可选参数.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay\\"
                },
                {
                  "name": "...args\\",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>预定在 delay 毫秒之后执行的单次 callback.  返回一个用于 clearTimeout() 的 id.</p>\n<p>callback 可能不会精确地在 delay 毫秒被调用.  Auto.js 不能保证回调被触发的确切时间, 也不能保证它们的顺序.  回调会在尽可能接近所指定的时间上调用.</p>\n<p>当 delay 小于 0 时, delay 会被设为 0.</p>\n"
        },
        {
          "textRaw": "setImmediate(callback[, ...args])",
          "type": "method",
          "name": "setImmediate",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`callback` {Function} 在Looper循环的当前回合结束时要调用的函数. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "在Looper循环的当前回合结束时要调用的函数."
                },
                {
                  "textRaw": "`...args` {any} 当调用 callback 时要传入的可选参数. ",
                  "name": "...args",
                  "type": "any",
                  "desc": "当调用 callback 时要传入的可选参数.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>预定立即执行的 callback, 它是在 I/O 事件的回调之后被触发.  返回一个用于 clearImmediate() 的 id.</p>\n<p>当多次调用 setImmediate() 时, callback 函数会按照它们被创建的顺序依次执行.  每次事件循环迭代都会处理整个回调队列.  如果一个立即定时器是被一个正在执行的回调排入队列的, 则该定时器直到下一次事件循环迭代才会被触发.</p>\n<p>setImmediate()、setInterval() 和 setTimeout() 方法每次都会返回表示预定的计时器的id.  它们可用于取消定时器并防止触发.</p>\n"
        },
        {
          "textRaw": "clearInterval(id)",
          "type": "method",
          "name": "clearInterval",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`id` {number} 一个 setInterval() 返回的 id. ",
                  "name": "id",
                  "type": "number",
                  "desc": "一个 setInterval() 返回的 id."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ],
          "desc": "<p>取消一个由 setInterval() 创建的循环定时任务.</p>\n<p>例如：</p>\n<pre><code>//每5秒就发出一次hello\nvar id = setInterval(function(){\n    toast(&quot;hello&quot;);\n}, 5000);\n//1分钟后取消循环\nsetTimeout(function(){\n    clearInterval(id);\n}, 60 * 1000);\n</code></pre>"
        },
        {
          "textRaw": "clearTimeout(id)",
          "type": "method",
          "name": "clearTimeout",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`id` {number} 一个 setTimeout() 返回的 id. ",
                  "name": "id",
                  "type": "number",
                  "desc": "一个 setTimeout() 返回的 id."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ],
          "desc": "<p>取消一个由 setTimeout() 创建的定时任务.</p>\n"
        },
        {
          "textRaw": "clearImmediate(id)",
          "type": "method",
          "name": "clearImmediate",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`id` {number} 一个 setImmediate() 返回的 id. ",
                  "name": "id",
                  "type": "number",
                  "desc": "一个 setImmediate() 返回的 id."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ],
          "desc": "<p>取消一个由 setImmediate() 创建的 Immediate 对象.</p>\n<!-- [end-include:timers.md] -->\n<!-- [start-include:threads.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "定时器 (Timers)"
    },
    {
      "textRaw": "线程 (Threads)",
      "name": "线程_(threads)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>threads模块提供了多线程支持, 可以启动新线程来运行脚本.</p>\n<p>脚本主线程会等待所有子线程执行完成后才停止执行, 因此如果子线程中有死循环, 请在必要的时候调用<code>exit()</code>来直接停止脚本或<code>threads.shutDownAll()</code>来停止所有子线程.</p>\n<p>通过<code>threads.start()</code>启动的所有线程会在脚本被强制停止时自动停止.</p>\n<p>由于JavaScript自身没有多线程的支持, 因此您可能会遇到意料之外的问题.</p>\n",
      "methods": [
        {
          "textRaw": "threads.start(action)",
          "type": "method",
          "name": "start",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`action` {Function} 要在新线程执行的函数 ",
                  "name": "action",
                  "type": "Function",
                  "desc": "要在新线程执行的函数"
                },
                {
                  "textRaw": "返回 [Thread](#threads_thread) ",
                  "name": "返回",
                  "desc": "[Thread](#threads_thread)"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "action"
                }
              ]
            }
          ],
          "desc": "<p>启动一个新线程并执行action.</p>\n<p>例如:</p>\n<pre><code>threads.start(function(){\n    //在新线程执行的代码\n    while(true){\n        log(&quot;子线程&quot;);\n    }\n});\nwhile(true){\n    log(&quot;脚本主线程&quot;);\n}\n</code></pre><p>通过该函数返回的<a href=\"#threads_thread\">Thread</a>对象可以获取该线程的状态, 控制该线程的运行中. 例如:</p>\n<pre><code>var thread = threads.start(function(){\n    while(true){\n        log(&quot;子线程&quot;);\n    }\n});\n//停止线程执行\nthread.interrupt();\n</code></pre><p>更多信息参见<a href=\"#threads_thread\">Thread</a>.</p>\n"
        },
        {
          "textRaw": "threads.shutDownAll()",
          "type": "method",
          "name": "shutDownAll",
          "desc": "<p>停止所有通过<code>threads.start()</code>启动的子线程.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "threads.currentThread()",
          "type": "method",
          "name": "currentThread",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 [Thread](#threads_thread) ",
                  "name": "返回",
                  "desc": "[Thread](#threads_thread)"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回当前线程.</p>\n"
        },
        {
          "textRaw": "threads.disposable()",
          "type": "method",
          "name": "disposable",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 [Disposable](#threads_disposable) ",
                  "name": "返回",
                  "desc": "[Disposable](#threads_disposable)"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>新建一个Disposable对象, 用于等待另一个线程的某个一次性结果. 更多信息参见<a href=\"#threads_线程通信\">线程通信</a>以及<a href=\"#threads_disposable\">Disposable</a>.</p>\n"
        },
        {
          "textRaw": "threads.atomic([initialValue])",
          "type": "method",
          "name": "atomic",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`initialValue` {number} 初始整数值, 默认为0 ",
                  "name": "initialValue",
                  "type": "number",
                  "desc": "初始整数值, 默认为0",
                  "optional": true
                },
                {
                  "textRaw": "返回[AtomicLong](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLong.html) ",
                  "name": "返回[AtomicLong](https",
                  "desc": "//docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLong.html)"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "initialValue",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>新建一个整数原子变量. 更多信息参见<a href=\"#threads_线程安全\">线程安全</a>以及<a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLong.html\">AtomicLong</a>.</p>\n"
        },
        {
          "textRaw": "threads.lock()",
          "type": "method",
          "name": "lock",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回[ReentrantLock](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html) ",
                  "name": "返回[ReentrantLock](https",
                  "desc": "//docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html)"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>新建一个可重入锁. 更多信息参见<a href=\"#threads_线程安全\">线程安全</a>以及<a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html\">ReentrantLock</a>.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "线程 (Threads)"
    },
    {
      "textRaw": "Thread",
      "name": "thread",
      "desc": "<p>线程对象, <code>threads.start()</code>返回的对象, 用于获取和控制线程的状态, 与其他线程交互等.</p>\n<p>Thread对象提供了和timers模块一样的API, 例如<code>setTimeout()</code>, <code>setInterval()</code>等, 用于在该线程执行相应的定时回调, 从而使线程之间可以直接交互. 例如：</p>\n<pre><code>var thread = threads.start(function(){\n    //在子线程执行的定时器\n    setInterval(function(){\n        log(&quot;子线程:&quot; + threads.currentThread());\n    }, 1000);\n});\n\nlog(&quot;当前线程为主线程:&quot; + threads.currentThread());\n\n//等待子线程启动\nthread.waitFor();\n//在子线程执行的定时器\nthread.setTimeout(function(){\n    //这段代码会在子线程执行\n    log(&quot;当前线程为子线程:&quot; + threads.currentThread());\n}, 2000);\n\nsleep(30 * 1000);\nthread.interrupt();\n</code></pre>",
      "methods": [
        {
          "textRaw": "Thread.interrupt()",
          "type": "method",
          "name": "interrupt",
          "desc": "<p>中断线程运行.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Thread.join([timeout])",
          "type": "method",
          "name": "join",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`timeout` {number} 等待时间, 单位毫秒 ",
                  "name": "timeout",
                  "type": "number",
                  "desc": "等待时间, 单位毫秒",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "timeout",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>等待线程执行完成. 如果timeout为0, 则会一直等待直至该线程执行完成；否则最多等待timeout毫秒的时间.</p>\n<p>例如:</p>\n<pre><code>var sum = 0;\n//启动子线程计算1加到10000\nvar thread = threads.start(function(){\n    for(var i = 0; i &lt; 10000; i++){\n        sum += i;\n    }\n});\n//等待该线程完成\nthread.join();\ntoast(&quot;sum = &quot; + sum);\n</code></pre>"
        },
        {
          "textRaw": "isAlive()",
          "type": "method",
          "name": "isAlive",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {boolean} ",
                  "name": "返回",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回线程是否存活. 如果线程仍未开始或已经结束, 返回<code>false</code>; 如果线程已经开始或者正在运行中, 返回<code>true</code>.</p>\n"
        },
        {
          "textRaw": "waitFor()",
          "type": "method",
          "name": "waitFor",
          "desc": "<p>等待线程开始执行. 调用<code>threads.start()</code>以后线程仍然需要一定时间才能开始执行, 因此调用此函数会等待线程开始执行；如果线程已经处于执行状态则立即返回.</p>\n<pre><code>var thread = threads.start(function(){\n    //do something\n});\nthread.waitFor();\nthread.setTimeout(function(){\n    //do something\n}, 1000);\n</code></pre>",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Thread.setTimeout(callback, delay\\[, ...args\\])",
          "type": "method",
          "name": "setTimeout",
          "desc": "<p>参见<a href=\"timers.html#timers_settimeout_callback_delay_args\">timers.setTimeout()</a>.</p>\n<p>区别在于, 该定时器会在该线程执行. 如果当前线程仍未开始执行或已经执行结束, 则抛出<code>IllegalStateException</code>.</p>\n<pre><code>log(&quot;当前线程(主线程):&quot; + threads.currentThread());\n\nvar thread = threads.start(function(){\n    //设置一个空的定时来保持线程的运行状态\n    setInterval(function(){}, 1000);\n});\n\nsleep(1000);\nthread.setTimeout(function(){\n    log(&quot;当前线程(子线程):&quot; + threads.currentThread());\n    exit();\n}, 1000);\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay\\"
                },
                {
                  "name": "...args\\",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Thread.setInterval(callback, delay\\[, ...args\\])",
          "type": "method",
          "name": "setInterval",
          "desc": "<p>参见<a href=\"timers.html#timers_setinterval_callback_delay_args\">timers.setInterval()</a>.</p>\n<p>区别在于, 该定时器会在该线程执行. 如果当前线程仍未开始执行或已经执行结束, 则抛出<code>IllegalStateException</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay\\"
                },
                {
                  "name": "...args\\",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Thread.setImmediate(callback[, ...args])",
          "type": "method",
          "name": "setImmediate",
          "desc": "<p>参见<a href=\"timers.html#timers_setimmediate_callback_delay_args\">timers.setImmediate()</a>.</p>\n<p>区别在于, 该定时器会在该线程执行. 如果当前线程仍未开始执行或已经执行结束, 则抛出<code>IllegalStateException</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Thread.clearInterval(id)",
          "type": "method",
          "name": "clearInterval",
          "desc": "<p>参见<a href=\"timers.html#timers_clearinterval_id\">timers.clearInterval()</a>.</p>\n<p>区别在于, 该定时器会在该线程执行. 如果当前线程仍未开始执行或已经执行结束, 则抛出<code>IllegalStateException</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Thread.clearTimeout(id)",
          "type": "method",
          "name": "clearTimeout",
          "desc": "<p>参见<a href=\"timers.html#timers_cleartimeout_id\">timers.clearTimeout()</a>.</p>\n<p>区别在于, 该定时器会在该线程执行. 如果当前线程仍未开始执行或已经执行结束, 则抛出<code>IllegalStateException</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Thread.clearImmediate(id)",
          "type": "method",
          "name": "clearImmediate",
          "desc": "<p>参见<a href=\"timers.html#timers_clearimmediate_id\">timers.clearImmediate()</a>.</p>\n<p>区别在于, 该定时器会在该线程执行. 如果当前线程仍未开始执行或已经执行结束, 则抛出<code>IllegalStateException</code>.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Thread"
    },
    {
      "textRaw": "线程安全",
      "name": "线程安全",
      "desc": "<p>线程安全问题是一个相对专业的编程问题, 本章节只提供给有需要的用户.</p>\n<p>引用维基百科的解释：</p>\n<blockquote>\n<p>线程安全是编程中的术语, 指某个函数、函数库在多线程环境中被调用时, 能够正确地处理多个线程之间的共享变量, 使程序功能正确完成.</p>\n</blockquote>\n<p>在Auto.js中, 线程间变量在符合JavaScript变量作用域规则的前提下是共享的, 例如全局变量在所有线程都能访问, 并且保证他们在所有线程的可见性. 但是, 不保证任何操作的原子性. 例如经典的自增&quot;i++&quot;将不是原子性操作.</p>\n<p>Rhino和Auto.js提供了一些简单的设施来解决简单的线程安全问题, 如锁<code>threads.lock()</code>, 函数同步锁<code>sync()</code>, 整数原子变量<code>threads.atomic()</code>等.</p>\n<p>例如, 对于多线程共享下的整数的自增操作(自增操作会导致问题, 是因为自增操作实际上为<code>i = i + 1</code>, 也就是先读取i的值, 把他加1, 再赋值给i, 如果两个线程同时进行自增操作, 可能出现i的值只增加了1的情况), 应该使用<code>threads.atomic()</code>函数来新建一个整数原子变量, 或者使用锁<code>threads.lock()</code>来保证操作的原子性, 或者用<code>sync()</code>来增加同步锁.</p>\n<p>线程不安全的代码如下：</p>\n<pre><code>var i = 0;\nthreads.start(function(){\n    while(true){\n        log(i++);\n    }\n});\nwhile(true){\n    log(i++);\n}\n</code></pre><p>此段代码运行后打开日志, 可以看到日志中有重复的值出现.</p>\n<p>使用<code>threads.atomic()</code>的线程安全的代码如下:</p>\n<pre><code>//atomic返回的对象保证了自增的原子性\nvar i = threads.atomic();\nthreads.start(function(){\n    while(true){\n        log(i.getAndIncrement());\n    }\n});\nwhile(true){\n    log(i.getAndIncrement());\n}\n</code></pre><p>或者:</p>\n<pre><code>//锁保证了操作的原子性\nvar lock = threads.lock();\nvar i = 0;\nthreads.start(function(){\n    while(true){\n        lock.lock();\n        log(i++);\n        lock.unlock();\n    }\n});\nwhile(true){\n    lock.lock();\n    log(i++);\n    lock.unlock();\n}\n</code></pre><p>或者:</p>\n<pre><code>//sync函数会把里面的函数加上同步锁, 使得在同一时刻最多只能有一个线程执行这个函数\nvar i = 0;\nvar getAndIncrement = sync(function(){\n    return i++;\n});\nthreads.start(function(){\n    while(true){\n        log(getAndIncrement());\n    }\n});\nwhile(true){\n    log(getAndIncrement());\n}\n</code></pre><p>另外, 数组Array不是线程安全的, 如果有这种复杂的需求, 请用Android和Java相关API来实现. 例如<code>CopyOnWriteList</code>, <code>Vector</code>等都是代替数组的线程安全的类, 用于不同的场景. 例如:</p>\n<pre><code>var nums = new java.util.Vector();\nnums.add(123);\nnums.add(456);\ntoast(&quot;长度为&quot; + nums.size());\ntoast(&quot;第一个元素为&quot; + nums.get(0));\n</code></pre><p>但很明显的是, 这些类不像数组那样简便易用, 也不能使用诸如<code>slice()</code>之类的方便的函数. 在未来可能会加入线程安全的数组来解决这个问题. 当然您也可以为每个数组的操作加锁来解决线程安全问题：</p>\n<pre><code>var nums = [];\nvar numsLock = threads.lock();\nthreads.start(function(){\n    //向数组添加元素123\n    numsLock.lock();\n    nums.push(123);\n    log(&quot;线程: %s, 数组: %s&quot;, threads.currentThread(), nums);\n    numsLock.unlock();\n});\n\nthreads.start(function(){\n    //向数组添加元素456\n    numsLock.lock();\n    nums.push(456);\n    log(&quot;线程: %s, 数组: %s&quot;, threads.currentThread(), nums);\n    numsLock.unlock();\n});\n\n//删除数组最后一个元素\nnumsLock.lock();\nnums.pop();\nlog(&quot;线程: %s, 数组: %s&quot;, threads.currentThread(), nums);\nnumsLock.unlock();\n</code></pre>",
      "methods": [
        {
          "textRaw": "sync(func)",
          "type": "method",
          "name": "sync",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`func` {Function} 函数 ",
                  "name": "func",
                  "type": "Function",
                  "desc": "函数"
                },
                {
                  "textRaw": "返回 {Function} ",
                  "name": "返回",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "func"
                }
              ]
            }
          ],
          "desc": "<p>给函数func加上同步锁并作为一个新函数返回.</p>\n<pre><code>var i = 0;\nfunction add(x){\n    i += x;\n}\n\nvar syncAdd = sync(add);\nsyncAdd(10);\ntoast(i);\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "线程安全"
    },
    {
      "textRaw": "线程通信",
      "name": "线程通信",
      "desc": "<p>Auto.js提供了一些简单的设施来支持简单的线程通信. <code>threads.disposable()</code>用于一个线程等待另一个线程的(一次性)结果, 同时<code>Lock.newCondition()</code>提供了Condition对象用于一般的线程通信(await, signal). 另外, <code>events</code>模块也可以用于线程通信, 通过指定<code>EventEmiiter</code>的回调执行的线程来实现.</p>\n<p>使用<code>threads.disposable()</code>可以简单地等待和获取某个线程的执行结果. 例如要等待某个线程计算&quot;1+.....+10000&quot;:</p>\n<pre><code>var sum = threads.disposable();\n//启动子线程计算\nthreads.start(function(){\n    var s = 0;\n    //从1加到10000\n    for(var i = 1; i &lt;= 10000; i++){\n        s += i;\n    }\n    //通知主线程接收结果\n    sum.setAndNotify(s);\n});\n//blockedGet()用于等待结果\ntoast(&quot;sum = &quot; + sum.blockedGet());\n</code></pre><p>如果上述代码用<code>Condition</code>实现：</p>\n<pre><code>//新建一个锁\nvar lock = threads.lock();\n//新建一个条件, 即&quot;计算完成&quot;\nvar complete = lock.newCondition();\nvar sum = 0;\nthreads.start(function(){\n    //从1加到10000\n    for(var i = 1; i &lt;= 10000; i++){\n        sum += i;\n    }\n    //通知主线程接收结果\n    lock.lock();\n    complete.signal();\n    lock.unlock();\n});\n//等待计算完成\nlock.lock();\ncomplete.await();\nlock.unlock();\n//打印结果\ntoast(&quot;sum = &quot; + sum);\n</code></pre><p>如果上诉代码用<code>events</code>模块实现：</p>\n<pre><code>//新建一个emitter, 并指定回调执行的线程为当前线程\nvar sum = events.emitter(threads.currentThread());\nthreads.start(function(){\n    var s = 0;\n    //从1加到10000\n    for(var i = 1; i &lt;= 10000; i++){\n        s += i;\n    }\n    //发送事件result通知主线程接收结果\n    sum.emit(&#39;result&#39;, s);\n});\nsum.on(&#39;result&#39;, function(s){\n    toastLog(&quot;sum = &quot; + s + &quot;, 当前线程: &quot; + threads.currentThread());\n});\n</code></pre><p>有关线程的其他问题, 例如生产者消费者等问题, 请用Java相关方法解决, 例如<code>java.util.concurrent.BlockingQueue</code>.\n<!-- [end-include:threads.md] --></p>\n<!-- [start-include:events.md] -->\n",
      "type": "module",
      "displayName": "线程通信"
    },
    {
      "textRaw": "事件监听 (Events)",
      "name": "事件监听_(events)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>events模块提供了监听手机通知、按键、触摸的接口. 您可以用他配合自动操作函数完成自动化工作.</p>\n<p>events本身是一个<a href=\"#events_eventemitter\">EventEmiiter</a>, 但内置了一些事件、包括按键事件、通知事件、Toast事件等.</p>\n<p>需要注意的是, 事件的处理是单线程的, 并且仍然在原线程执行, 如果脚本主体或者其他事件处理中有耗时操作、轮询等, 则事件将无法得到及时处理（会进入事件队列等待脚本主体或其他事件处理完成才执行）. 例如:</p>\n<pre><code>auto();\nevents.observeNotification();\nevents.on(&#39;toast&#39;, function(t){\n    //这段代码将得不到执行\n    log(t);\n});\nwhile(true){\n    //死循环\n}\n</code></pre>",
      "methods": [
        {
          "textRaw": "events.emitter()",
          "type": "method",
          "name": "emitter",
          "desc": "<p>返回一个新的<a href=\"#events_eventemitter\">EventEmitter</a>. 这个EventEmitter没有内置任何事件.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "events.observeKey()",
          "type": "method",
          "name": "observeKey",
          "desc": "<p>启用按键监听, 例如音量键、Home键. 按键监听使用无障碍服务实现, 如果无障碍服务未启用会抛出异常并提示开启.</p>\n<p>只有这个函数成功执行后, <code>onKeyDown</code>, <code>onKeyUp</code>等按键事件的监听才有效.</p>\n<p>该函数在安卓4.3以上才能使用.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "events.onKeyDown(keyName, listener)",
          "type": "method",
          "name": "onKeyDown",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`keyName` {string} 要监听的按键名称 ",
                  "name": "keyName",
                  "type": "string",
                  "desc": "要监听的按键名称"
                },
                {
                  "textRaw": "`listener` {Function} 按键监听器. 参数为一个[KeyEvent](#events_keyevent). ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "按键监听器. 参数为一个[KeyEvent](#events_keyevent)."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "keyName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>注册一个按键监听函数, 当有keyName对应的按键被按下会调用该函数. 可用的按键名称参见<a href=\"#events_keys\">Keys</a>.</p>\n<p>例如:</p>\n<pre><code>//启用按键监听\nevents.observeKey();\n//监听音量上键按下\nevents.onKeyDown(&quot;volume_up&quot;, function(event){\n    toast(&quot;音量上键被按下了&quot;);\n});\n//监听菜单键按下\nevents.onKeyDown(&quot;menu&quot;, function(event){\n    toast(&quot;菜单键被按下了&quot;);\n    exit();\n});\n</code></pre>"
        },
        {
          "textRaw": "events.onKeyUp(keyName, listener)",
          "type": "method",
          "name": "onKeyUp",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`keyName` {string} 要监听的按键名称 ",
                  "name": "keyName",
                  "type": "string",
                  "desc": "要监听的按键名称"
                },
                {
                  "textRaw": "`listener` {Function} 按键监听器. 参数为一个[KeyEvent](#events_keyevent). ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "按键监听器. 参数为一个[KeyEvent](#events_keyevent)."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "keyName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>注册一个按键监听函数, 当有keyName对应的按键弹起会调用该函数. 可用的按键名称参见<a href=\"#events_keys\">Keys</a>.</p>\n<p>一次完整的按键动作包括了按键按下和弹起. 按下事件会在手指按下一个按键的&quot;瞬间&quot;触发, 弹起事件则在手指放开这个按键时触发.</p>\n<p>例如:</p>\n<pre><code>//启用按键监听\nevents.observeKey();\n//监听音量下键弹起\nevents.onKeyDown(&quot;volume_down&quot;, function(event){\n    toast(&quot;音量上键弹起&quot;);\n});\n//监听Home键弹起\nevents.onKeyDown(&quot;home&quot;, function(event){\n    toast(&quot;Home键弹起&quot;);\n    exit();\n});\n</code></pre>"
        },
        {
          "textRaw": "events.onceKeyDown(keyName, listener)",
          "type": "method",
          "name": "onceKeyDown",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`keyName` {string} 要监听的按键名称 ",
                  "name": "keyName",
                  "type": "string",
                  "desc": "要监听的按键名称"
                },
                {
                  "textRaw": "`listener` {Function} 按键监听器. 参数为一个[KeyEvent](#events_keyevent) ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "按键监听器. 参数为一个[KeyEvent](#events_keyevent)"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "keyName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>注册一个按键监听函数, 当有keyName对应的按键被按下时会调用该函数, 之后会注销该按键监听器.</p>\n<p>也就是listener只有在onceKeyDown调用后的第一次按键事件被调用一次.</p>\n"
        },
        {
          "textRaw": "events.onceKeyUp(keyName, listener)",
          "type": "method",
          "name": "onceKeyUp",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`keyName` {string} 要监听的按键名称 ",
                  "name": "keyName",
                  "type": "string",
                  "desc": "要监听的按键名称"
                },
                {
                  "textRaw": "`listener` {Function} 按键监听器. 参数为一个[KeyEvent](#events_keyevent) ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "按键监听器. 参数为一个[KeyEvent](#events_keyevent)"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "keyName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>注册一个按键监听函数, 当有keyName对应的按键弹起时会调用该函数, 之后会注销该按键监听器.</p>\n<p>也就是listener只有在onceKeyUp调用后的第一次按键事件被调用一次.</p>\n"
        },
        {
          "textRaw": "events.removeAllKeyDownListeners(keyName)",
          "type": "method",
          "name": "removeAllKeyDownListeners",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`keyName` {string} 按键名称 ",
                  "name": "keyName",
                  "type": "string",
                  "desc": "按键名称"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "keyName"
                }
              ]
            }
          ],
          "desc": "<p>删除该按键的KeyDown(按下)事件的所有监听.</p>\n"
        },
        {
          "textRaw": "events.removeAllKeyUpListeners(keyName)",
          "type": "method",
          "name": "removeAllKeyUpListeners",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`keyName` {string} 按键名称 ",
                  "name": "keyName",
                  "type": "string",
                  "desc": "按键名称"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "keyName"
                }
              ]
            }
          ],
          "desc": "<p>删除该按键的KeyUp(弹起)事件的所有监听.</p>\n"
        },
        {
          "textRaw": "events.setKeyInterceptionEnabled([key, ]enabled)",
          "type": "method",
          "name": "setKeyInterceptionEnabled",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`enabled` {boolean} ",
                  "name": "enabled",
                  "type": "boolean",
                  "optional": true
                },
                {
                  "textRaw": "`key` {string} 要屏蔽的按键 ",
                  "name": "key",
                  "type": "string",
                  "desc": "要屏蔽的按键"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "key",
                  "optional": true
                },
                {
                  "name": "enabled"
                }
              ]
            }
          ],
          "desc": "<p>设置按键屏蔽是否启用. 所谓按键屏蔽指的是, 屏蔽原有按键的功能, 例如使得音量键不再能调节音量, 但此时仍然能通过按键事件监听按键.</p>\n<p>如果不加参数key则会屏蔽所有按键.</p>\n<p>例如, 调用<code>events.setKeyInterceptionEnabled(true)</code>会使系统的音量、Home、返回等键不再具有调节音量、回到主页、返回的作用, 但此时仍然能通过按键事件监听按键.</p>\n<p>该函数通常于按键监听结合, 例如想监听音量键并使音量键按下时不弹出音量调节框则为：</p>\n<pre><code>events.setKeyInterceptionEnabled(&quot;volume_up&quot;, true);\nevents.observeKey();\nevents.onKeyDown(&quot;volume_up&quot;, ()=&gt;{\n    log(&quot;音量上键被按下&quot;);\n});\n</code></pre><p>只要有一个脚本屏蔽了某个按键, 该按键便会被屏蔽；当脚本退出时, 会自动解除所有按键屏蔽.</p>\n"
        },
        {
          "textRaw": "events.observeTouch()",
          "type": "method",
          "name": "observeTouch",
          "desc": "<p>启用屏幕触摸监听. （需要root权限）</p>\n<p>只有这个函数被成功执行后, 触摸事件的监听才有效.</p>\n<p>没有root权限调用该函数则什么也不会发生.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "events.setTouchEventTimeout(timeout)",
          "type": "method",
          "name": "setTouchEventTimeout",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`timeout` {number} 两个触摸事件的最小间隔. 单位毫秒. 默认为10毫秒. 如果number小于0, 视为0处理. ",
                  "name": "timeout",
                  "type": "number",
                  "desc": "两个触摸事件的最小间隔. 单位毫秒. 默认为10毫秒. 如果number小于0, 视为0处理."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "timeout"
                }
              ]
            }
          ],
          "desc": "<p>设置两个触摸事件分发的最小时间间隔.</p>\n<p>例如间隔为10毫秒的话, 前一个触摸事件发生并被注册的监听器处理后, 至少要过10毫秒才能分发和处理下一个触摸事件, 这10毫秒之间的触摸将会被忽略.</p>\n<p>建议在满足需要的情况下尽量提高这个间隔. 一个简单滑动动作可能会连续触发上百个触摸事件, 如果timeout设置过低可能造成事件拥堵. 强烈建议不要设置timeout为0.</p>\n"
        },
        {
          "textRaw": "events.getTouchEventTimeout()",
          "type": "method",
          "name": "getTouchEventTimeout",
          "desc": "<p>返回触摸事件的最小时间间隔.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "events.onTouch(listener)",
          "type": "method",
          "name": "onTouch",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`listener` {Function} 参数为[Point](images#images_point)的函数 ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "参数为[Point](images#images_point)的函数"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>注册一个触摸监听函数. 相当于<code>on(&quot;touch&quot;, listener)</code>.</p>\n<p>例如:</p>\n<pre><code>//启用触摸监听\nevents.observeTouch();\n//注册触摸监听器\nevents.onTouch(function(p){\n    //触摸事件发生时, 打印出触摸的点的坐标\n    log(p.x + &quot;, &quot; + p.y);\n});\n</code></pre>"
        },
        {
          "textRaw": "events.removeAllTouchListeners()",
          "type": "method",
          "name": "removeAllTouchListeners",
          "desc": "<p>删除所有事件监听函数.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "events.observeNotification()",
          "type": "method",
          "name": "observeNotification",
          "desc": "<p>开启通知监听. 例如QQ消息、微信消息、推送等通知.</p>\n<p>通知监听依赖于通知服务, 如果通知服务没有运行, 会抛出异常并跳转到通知权限开启界面. （有时即使通知权限已经开启通知服务也没有运行, 这时需要关闭权限再重新开启一次）</p>\n<p>例如：</p>\n<pre><code>events.observeNotification();\nevents.onNotification(function(notification){\n    log(notification.getText());\n});\n</code></pre>",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "events.observeToast()",
          "type": "method",
          "name": "observeToast",
          "desc": "<p>开启Toast监听.</p>\n<p>Toast监听依赖于无障碍服务, 因此此函数会确保无障碍服务运行.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "事件: 'key'",
          "name": "事件:_'key'",
          "desc": "<ul>\n<li><code>keyCode</code> {number} 键值</li>\n<li><code>event</code> {KeyEvent} 事件</li>\n</ul>\n<p>当有按键被按下或弹起时会触发该事件.\n例如：</p>\n<pre><code>auto();\nevents.observeKey();\nevents.on(&quot;key&quot;, function(keyCode, event){\n    //处理按键事件\n});\n</code></pre><p>其中监听器的参数KeyCode包括：</p>\n<ul>\n<li><code>keys.home</code> 主页键</li>\n<li><code>keys.back</code> 返回键</li>\n<li><code>keys.menu</code> 菜单键</li>\n<li><code>keys.volume_up</code> 音量上键</li>\n<li><code>keys.volume_down</code> 音量下键</li>\n</ul>\n<p>例如：</p>\n<pre><code>auto();\nevents.observeKey();\nevents.on(&quot;key&quot;, function(keyCode, event){\n    if(keyCode == keys.menu &amp;&amp; event.getAction() == event.ACTION_UP){\n        toast(&quot;菜单键按下&quot;);\n    }\n});\n</code></pre>",
          "type": "module",
          "displayName": "事件: 'key'"
        },
        {
          "textRaw": "事件: 'key_down'",
          "name": "事件:_'key_down'",
          "desc": "<ul>\n<li><code>keyCode</code> {number} 键值</li>\n<li><code>event</code> {KeyEvent} 事件</li>\n</ul>\n<p>当有按键被按下时会触发该事件.</p>\n<pre><code>auto();\nevents.observeKey();\nevents.on(&quot;key_down&quot;, function(keyCode, event){\n    //处理按键按下事件\n});\n</code></pre>",
          "type": "module",
          "displayName": "事件: 'key_down'"
        },
        {
          "textRaw": "事件: 'key_up'",
          "name": "事件:_'key_up'",
          "desc": "<ul>\n<li><code>keyCode</code> {number} 键值</li>\n<li><code>event</code> {KeyEvent} 事件</li>\n</ul>\n<p>当有按键弹起时会触发该事件.</p>\n<pre><code>auto();\nevents.observeKey();\nevents.on(&quot;key_up&quot;, function(keyCode, event){\n    //处理按键弹起事件\n});\n</code></pre>",
          "type": "module",
          "displayName": "事件: 'key_up'"
        },
        {
          "textRaw": "事件: 'exit`",
          "name": "事件:_'exit`",
          "desc": "<p>当脚本正常或者异常退出时会触发该事件. 事件处理中如果有异常抛出, 则立即中止exit事件的处理（即使exit事件有多个处理函数）并在控制台和日志中打印该异常.</p>\n<p>一个脚本停止运行时, 会关闭该脚本的所有悬浮窗, 触发exit事件, 之后再回收资源. 如果exit事件的处理中有死循环, 则后续资源无法得到及时回收.\n此时脚本会停留在任务列表, 如果在任务列表中关闭, 则会强制结束exit事件的处理并回收后续资源.</p>\n<pre><code>log(&quot;开始运行&quot;)\nevents.on(&quot;exit&quot;, function(){\n    log(&quot;结束运行&quot;);\n});\nlog(&quot;即将结束运行&quot;);\n</code></pre>",
          "type": "module",
          "displayName": "事件: 'exit`"
        },
        {
          "textRaw": "事件: 'toast'",
          "name": "事件:_'toast'",
          "desc": "<ul>\n<li><code>toast</code> {Object}<ul>\n<li><code>getText()</code> 获取Toast的文本内容</li>\n<li><code>getPackageName()</code> 获取发出Toast的应用包名</li>\n</ul>\n</li>\n</ul>\n<p>当有应用发出toast(气泡消息)时会触发该事件. 但Auto.js软件本身的toast除外.</p>\n<p>例如, 要记录发出所有toast的应用：</p>\n<pre><code>events.observeToast();\nevents.onToast(function(toast){\n    log(&quot;Toast内容: &quot; + toast.getText() + &quot; 包名: &quot; + toast.getPackageName());\n});\n</code></pre>",
          "type": "module",
          "displayName": "事件: 'toast'"
        },
        {
          "textRaw": "事件: 'notification'",
          "name": "事件:_'notification'",
          "desc": "<ul>\n<li><code>notification</code> <a href=\"#events_notification\">Notification</a> 通知对象</li>\n</ul>\n<p>当有应用发出通知时会触发该事件, 参数为<a href=\"#events_notification\">Notification</a>.</p>\n<p>例如：</p>\n<pre><code>events.observeNotification();\nevents.on(&quot;notification&quot;, function(n){\n    log(&quot;收到新通知:\\n 标题: %s, 内容: %s, \\n包名: %s&quot;, n.getTitle(), n.getText(), n.getPackageName());\n});\n</code></pre>",
          "type": "module",
          "displayName": "事件: 'notification'"
        }
      ],
      "type": "module",
      "displayName": "事件监听 (Events)"
    },
    {
      "textRaw": "Notification",
      "name": "notification",
      "desc": "<p>通知对象, 可以获取通知详情, 包括通知标题、内容、发出通知的包名、时间等, 也可以对通知进行操作, 比如点击、删除.</p>\n",
      "properties": [
        {
          "textRaw": "`number` {number} ",
          "type": "number",
          "name": "number",
          "desc": "<p>通知数量. 例如QQ连续收到两条消息时number为2.</p>\n"
        },
        {
          "textRaw": "`when` {number} ",
          "type": "number",
          "name": "when",
          "desc": "<p>通知发出时间的时间戳, 可以用于构造<code>Date</code>对象. 例如：</p>\n<pre><code>events.observeNotification();\nevents.on(&quot;notification&quot;, function(n){\n    log(&quot;通知时间为}&quot; + new Date(n.when));\n});\n</code></pre>"
        }
      ],
      "methods": [
        {
          "textRaw": "Notification.getPackageName()",
          "type": "method",
          "name": "getPackageName",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>获取发出通知的应用包名.</p>\n"
        },
        {
          "textRaw": "Notification.getTitle()",
          "type": "method",
          "name": "getTitle",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>获取通知的标题.</p>\n"
        },
        {
          "textRaw": "Notification.getText()",
          "type": "method",
          "name": "getText",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>获取通知的内容.</p>\n"
        },
        {
          "textRaw": "Notification.click()",
          "type": "method",
          "name": "click",
          "desc": "<p>点击该通知. 例如对于一条QQ消息, 点击会进入具体的聊天界面.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "Notification.delete()",
          "type": "method",
          "name": "delete",
          "desc": "<p>删除该通知. 该通知将从通知栏中消失.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Notification"
    },
    {
      "textRaw": "KeyEvent",
      "name": "keyevent",
      "methods": [
        {
          "textRaw": "KeyEvent.getAction()",
          "type": "method",
          "name": "getAction",
          "desc": "<p>返回事件的动作. 包括：</p>\n<ul>\n<li><code>KeyEvent.ACTION_DOWN</code> 按下事件</li>\n<li><code>KeyEvent.ACTION_UP</code> 弹起事件</li>\n</ul>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "KeyEvent.getKeyCode()",
          "type": "method",
          "name": "getKeyCode",
          "desc": "<p>返回按键的键值. 包括：</p>\n<ul>\n<li><code>KeyEvent.KEYCODE_HOME</code> 主页键</li>\n<li><code>KeyEvent.KEYCODE_BACK</code> 返回键</li>\n<li><code>KeyEvent.KEYCODE_MENU</code> 菜单键</li>\n<li><code>KeyEvent.KEYCODE_VOLUME_UP</code> 音量上键</li>\n<li><code>KeyEvent.KEYCODE_VOLUME_DOWN</code> 音量下键</li>\n</ul>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "KeyEvent.getEventTime()",
          "type": "method",
          "name": "getEventTime",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回事件发生的时间戳.</p>\n"
        },
        {
          "textRaw": "KeyEvent.getDownTime()",
          "type": "method",
          "name": "getDownTime",
          "desc": "<p>返回最近一次按下事件的时间戳. 如果本身是按下事件, 则与<code>getEventTime()</code>相同.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "KeyEvent.keyCodeToString(keyCode)",
          "type": "method",
          "name": "keyCodeToString",
          "desc": "<p>把键值转换为字符串. 例如KEYCODE_HOME转换为&quot;KEYCODE_HOME&quot;.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "keyCode"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "KeyEvent"
    },
    {
      "textRaw": "keys",
      "name": "keys",
      "desc": "<p>按键事件中所有可用的按键名称为：</p>\n<ul>\n<li><code>volume_up</code>  音量上键</li>\n<li><code>volume_down</code> 音量下键</li>\n<li><code>home</code> 主屏幕键</li>\n<li><code>back</code> 返回键</li>\n<li><code>menu</code> 菜单键</li>\n</ul>\n",
      "type": "module",
      "displayName": "keys"
    },
    {
      "textRaw": "EventEmitter",
      "name": "eventemitter",
      "properties": [
        {
          "textRaw": "EventEmitter.defaultMaxListeners",
          "name": "defaultMaxListeners",
          "desc": "<p>每个事件默认可以注册最多 10 个监听器.  单个 EventEmitter 实例的限制可以使用 emitter.setMaxListeners(n) 方法改变.  所有 EventEmitter 实例的默认值可以使用 EventEmitter.defaultMaxListeners 属性改变.</p>\n<p>设置 EventEmitter.defaultMaxListeners 要谨慎, 因为会影响所有 EventEmitter 实例, 包括之前创建的.  因而, 调用 emitter.setMaxListeners(n) 优先于 EventEmitter.defaultMaxListeners.</p>\n<p>注意, 与Node.js不同, <strong>这是一个硬性限制</strong>.  EventEmitter 实例不允许添加更多的监听器, 监听器超过最大数量时会抛出TooManyListenersException.</p>\n<pre><code>emitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once(&#39;event&#39;, () =&gt; {\n  // 做些操作\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n</code></pre>"
        }
      ],
      "methods": [
        {
          "textRaw": "EventEmitter.addListener(eventName, listener)",
          "type": "method",
          "name": "addListener",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {any} ",
                  "name": "eventName",
                  "type": "any"
                },
                {
                  "textRaw": "`listener` {Function} ",
                  "name": "listener",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>emitter.on(eventName, listener) 的别名.</p>\n"
        },
        {
          "textRaw": "EventEmitter.emit(eventName[, ...args])",
          "type": "method",
          "name": "emit",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {any} ",
                  "name": "eventName",
                  "type": "any"
                },
                {
                  "textRaw": "`args` {any} ",
                  "name": "args",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                },
                {
                  "name": "...args",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>按监听器的注册顺序, 同步地调用每个注册到名为 eventName 事件的监听器, 并传入提供的参数.</p>\n<p>如果事件有监听器, 则返回 true , 否则返回 false.</p>\n"
        },
        {
          "textRaw": "EventEmitter.eventNames()",
          "type": "method",
          "name": "eventNames",
          "desc": "<p>返回一个列出触发器已注册监听器的事件的数组.  数组中的值为字符串或符号.</p>\n<pre><code>const myEE = events.emitter();\nmyEE.on(&#39;foo&#39;, () =&gt; {});\nmyEE.on(&#39;bar&#39;, () =&gt; {});\n\nconst sym = Symbol(&#39;symbol&#39;);\nmyEE.on(sym, () =&gt; {});\n\nconsole.log(myEE.eventNames());\n// 打印: [ &#39;foo&#39;, &#39;bar&#39;, Symbol(symbol) ]\n</code></pre>",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "EventEmitter.getMaxListeners()",
          "type": "method",
          "name": "getMaxListeners",
          "desc": "<p>返回 EventEmitter 当前的最大监听器限制值, 该值可以通过 emitter.setMaxListeners(n) 设置或默认为 EventEmitter.defaultMaxListeners.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "EventEmitter.listenerCount(eventName)",
          "type": "method",
          "name": "listenerCount",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {string} 正在被监听的事件名 ",
                  "name": "eventName",
                  "type": "string",
                  "desc": "正在被监听的事件名"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                }
              ]
            }
          ],
          "desc": "<p>返回正在监听名为 eventName 的事件的监听器的数量.</p>\n"
        },
        {
          "textRaw": "EventEmitter.listeners(eventName)",
          "type": "method",
          "name": "listeners",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {string} ",
                  "name": "eventName",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                }
              ]
            }
          ],
          "desc": "<p>返回名为 eventName 的事件的监听器数组的副本.</p>\n<pre><code>server.on(&#39;connection&#39;, (stream) =&gt; {\n  console.log(&#39;someone connected!&#39;);\n});\nconsole.log(util.inspect(server.listeners(&#39;connection&#39;)));\n// 打印: [ [Function] ]\n</code></pre>"
        },
        {
          "textRaw": "EventEmitter.on(eventName, listener)",
          "type": "method",
          "name": "on",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {any} 事件名 ",
                  "name": "eventName",
                  "type": "any",
                  "desc": "事件名"
                },
                {
                  "textRaw": "`listener` {Function} 回调函数 ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "回调函数"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>添加 listener 函数到名为 eventName 的事件的监听器数组的末尾.  不会检查 listener 是否已被添加.  多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次.</p>\n<pre><code>server.on(&#39;connection&#39;, (stream) =&gt; {\n  console.log(&#39;有连接！&#39;);\n});\n</code></pre><p>返回一个 EventEmitter 引用, 可以链式调用.</p>\n<p>默认情况下, 事件监听器会按照添加的顺序依次调用.  emitter.prependListener() 方法可用于将事件监听器添加到监听器数组的开头.</p>\n<pre><code>const myEE = events.emitter();\nmyEE.on(&#39;foo&#39;, () =&gt; console.log(&#39;a&#39;));\nmyEE.prependListener(&#39;foo&#39;, () =&gt; console.log(&#39;b&#39;));\nmyEE.emit(&#39;foo&#39;);\n// 打印:\n//   b\n//   a\n</code></pre>"
        },
        {
          "textRaw": "EventEmitter.once(eventName, listener)",
          "type": "method",
          "name": "once",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {any} 事件名 ",
                  "name": "eventName",
                  "type": "any",
                  "desc": "事件名"
                },
                {
                  "textRaw": "`listener` {Function} 回调函数 ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "回调函数"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>添加一个单次 listener 函数到名为 eventName 的事件.  下次触发 eventName 事件时, 监听器会被移除, 然后调用.</p>\n<pre><code>server.once(&#39;connection&#39;, (stream) =&gt; {\n  console.log(&#39;首次调用！&#39;);\n});\n</code></pre><p>返回一个 EventEmitter 引用, 可以链式调用.</p>\n<p>默认情况下, 事件监听器会按照添加的顺序依次调用.  emitter.prependOnceListener() 方法可用于将事件监听器添加到监听器数组的开头.</p>\n<pre><code>const myEE = events.emitter();\nmyEE.once(&#39;foo&#39;, () =&gt; console.log(&#39;a&#39;));\nmyEE.prependOnceListener(&#39;foo&#39;, () =&gt; console.log(&#39;b&#39;));\nmyEE.emit(&#39;foo&#39;);\n// 打印:\n//   b\n//   a\n</code></pre>"
        },
        {
          "textRaw": "EventEmitter.prependListener(eventName, listener)",
          "type": "method",
          "name": "prependListener",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {any} 事件名 ",
                  "name": "eventName",
                  "type": "any",
                  "desc": "事件名"
                },
                {
                  "textRaw": "`listener` {Function} 回调函数 ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "回调函数"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>添加 listener 函数到名为 eventName 的事件的监听器数组的开头.  不会检查 listener 是否已被添加.  多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次.</p>\n<pre><code>server.prependListener(&#39;connection&#39;, (stream) =&gt; {\n  console.log(&#39;有连接！&#39;);\n});\n</code></pre><p>返回一个 EventEmitter 引用, 可以链式调用.</p>\n"
        },
        {
          "textRaw": "EventEmitter.prependOnceListener(eventName, listener)",
          "type": "method",
          "name": "prependOnceListener",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {any} 事件名 ",
                  "name": "eventName",
                  "type": "any",
                  "desc": "事件名"
                },
                {
                  "textRaw": "`listener` {Function} 回调函数 ",
                  "name": "listener",
                  "type": "Function",
                  "desc": "回调函数"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头.  下次触发 eventName 事件时, 监听器会被移除, 然后调用.</p>\n<pre><code>server.prependOnceListener(&#39;connection&#39;, (stream) =&gt; {\n  console.log(&#39;首次调用！&#39;);\n});\n</code></pre><p>返回一个 EventEmitter 引用, 可以链式调用.</p>\n"
        },
        {
          "textRaw": "EventEmitter.removeAllListeners(\\[eventName\\])",
          "type": "method",
          "name": "removeAllListeners",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {any} ",
                  "name": "eventName",
                  "type": "any"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "\\[eventName\\"
                }
              ]
            }
          ],
          "desc": "<p>移除全部或指定 eventName 的监听器.</p>\n<p>注意, 在代码中移除其他地方添加的监听器是一个不好的做法, 尤其是当 EventEmitter 实例是其他组件或模块创建的.</p>\n<p>返回一个 EventEmitter 引用, 可以链式调用.</p>\n"
        },
        {
          "textRaw": "EventEmitter.removeListener(eventName, listener)",
          "type": "method",
          "name": "removeListener",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`eventName` {any} ",
                  "name": "eventName",
                  "type": "any"
                },
                {
                  "textRaw": "`listener` {Function} ",
                  "name": "listener",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "eventName"
                },
                {
                  "name": "listener"
                }
              ]
            }
          ],
          "desc": "<p>从名为 eventName 的事件的监听器数组中移除指定的 listener.</p>\n<pre><code>const callback = (stream) =&gt; {\n  console.log(&#39;有连接！&#39;);\n};\nserver.on(&#39;connection&#39;, callback);\n// ...\nserver.removeListener(&#39;connection&#39;, callback);\n</code></pre><p>removeListener 最多只会从监听器数组里移除一个监听器实例.  如果任何单一的监听器被多次添加到指定 eventName 的监听器数组中, 则必须多次调用 removeListener 才能移除每个实例.</p>\n<p>注意, 一旦一个事件被触发, 所有绑定到它的监听器都会按顺序依次触发.  这意味着, 在事件触发后、最后一个监听器完成执行前, 任何 removeListener() 或 removeAllListeners() 调用都不会从 emit() 中移除它们.  随后的事件会像预期的那样发生.</p>\n<pre><code>const myEmitter = events.emitter();\n\nconst callbackA = () =&gt; {\n  console.log(&#39;A&#39;);\n  myEmitter.removeListener(&#39;event&#39;, callbackB);\n};\n\nconst callbackB = () =&gt; {\n  console.log(&#39;B&#39;);\n};\n\nmyEmitter.on(&#39;event&#39;, callbackA);\n\nmyEmitter.on(&#39;event&#39;, callbackB);\n\n// callbackA 移除了监听器 callbackB, 但它依然会被调用.\n// 触发是内部的监听器数组为 [callbackA, callbackB]\nmyEmitter.emit(&#39;event&#39;);\n// 打印:\n//   A\n//   B\n\n// callbackB 被移除了.\n// 内部监听器数组为 [callbackA]\nmyEmitter.emit(&#39;event&#39;);\n// 打印:\n//   A\n</code></pre><p>因为监听器是使用内部数组进行管理的, 所以调用它会改变在监听器被移除后注册的任何监听器的位置索引.  虽然这不会影响监听器的调用顺序, 但意味着由 emitter.listeners() 方法返回的监听器数组副本需要被重新创建.</p>\n<p>返回一个 EventEmitter 引用, 可以链式调用.</p>\n"
        },
        {
          "textRaw": "EventEmitter.setMaxListeners(n)",
          "type": "method",
          "name": "setMaxListeners",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`n` {number} ",
                  "name": "n",
                  "type": "number"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "n"
                }
              ]
            }
          ],
          "desc": "<p>默认情况下, 如果为特定事件添加了超过 10 个监听器, 则 EventEmitter 会打印一个警告.  此限制有助于寻找内存泄露.  但是, 并不是所有的事件都要被限为 10 个.  emitter.setMaxListeners() 方法允许修改指定的 EventEmitter 实例的限制.  值设为 Infinity（或 0）表明不限制监听器的数量.</p>\n<p>返回一个 EventEmitter 引用, 可以链式调用.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "EventEmitter"
    },
    {
      "textRaw": "events.broadcast: 脚本间广播",
      "name": "events.broadcast:_脚本间广播",
      "desc": "<p>脚本间通信除了使用engines模块提供的<code>ScriptEngine.emit()</code>方法以外, 也可以使用events模块提供的broadcast广播.</p>\n<p>events.broadcast本身是一个EventEmitter, 但它的事件是在脚本间共享的, 所有脚本都能发送和监听这些事件；事件处理会在脚本主线程执行（后续可能加入函数<code>onThisThread(eventName, ...args)</code>来提供在其他线程执行的能力）.</p>\n<p>例如在一个脚本发送一个广播hello:</p>\n<pre><code>events.broadcast.emit(&quot;hello&quot;, &quot;小明&quot;);\n</code></pre><p>在其他脚本中监听并处理：</p>\n<pre><code>events.broadcast.on(&quot;hello&quot;, function(name){\n    toast(&quot;你好, &quot; + name);\n});\n//保持脚本运行\nsetInterval(()=&gt;{}, 1000);\n</code></pre><!-- [end-include:events.md] -->\n<!-- [start-include:dialogs.md] -->\n",
      "type": "module",
      "displayName": "events.broadcast: 脚本间广播"
    },
    {
      "textRaw": "对话框 (Dialogs)",
      "name": "对话框_(dialogs)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>dialogs 模块提供了简单的对话框支持, 可以通过对话框和用户进行交互. 最简单的例子如下：</p>\n<pre><code>alert(&quot;您好&quot;);\n</code></pre><p>这段代码会弹出一个消息提示框显示&quot;您好&quot;, 并在用户点击&quot;确定&quot;后继续运行. 稍微复杂一点的例子如下：</p>\n<pre><code>var clear = confirm(&quot;要清除所有缓存吗?&quot;);\nif(clear){\n    alert(&quot;清除成功!&quot;);\n}\n</code></pre><p><code>confirm()</code>会弹出一个对话框并让用户选择&quot;是&quot;或&quot;否&quot;, 如果选择&quot;是&quot;则返回true.</p>\n<p>需要特别注意的是, 对话框在ui模式下不能像通常那样使用, 应该使用回调函数或者<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/\">Promise</a>的形式. 理解这一点可能稍有困难. 举个例子:</p>\n<pre><code>&quot;ui&quot;;\n//回调形式\n confirm(&quot;要清除所有缓存吗?&quot;, function(clear){\n     if(clear){\n          alert(&quot;清除成功!&quot;);\n     }\n });\n//Promise形式\nconfirm(&quot;要清除所有缓存吗?&quot;)\n    .then(clear =&gt; {\n        if(clear){\n          alert(&quot;清除成功!&quot;);\n        }\n    });\n</code></pre>",
      "methods": [
        {
          "textRaw": "dialogs.alert(title[, content, callback])",
          "type": "method",
          "name": "alert",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`title` {string} 对话框的标题. ",
                  "name": "title",
                  "type": "string",
                  "desc": "对话框的标题."
                },
                {
                  "textRaw": "`content` {string} 可选, 对话框的内容. 默认为空. ",
                  "name": "content",
                  "type": "string",
                  "desc": "可选, 对话框的内容. 默认为空.",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "title"
                },
                {
                  "name": "content",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>显示一个只包含“确定”按钮的提示对话框. 直至用户点击确定脚本才继续运行.</p>\n<p>该函数也可以作为全局函数使用.</p>\n<pre><code>alert(&quot;出现错误~&quot;, &quot;出现未知错误, 请联系脚本作者”);\n</code></pre><p>在ui模式下该函数返回一个<code>Promise</code>. 例如:</p>\n<pre><code>&quot;ui&quot;;\nalert(&quot;嘿嘿嘿&quot;).then(()=&gt;{\n    //当点击确定后会执行这里\n});\n</code></pre>"
        },
        {
          "textRaw": "dialogs.confirm(title[, content, callback])",
          "type": "method",
          "name": "confirm",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`title` {string} 对话框的标题. ",
                  "name": "title",
                  "type": "string",
                  "desc": "对话框的标题."
                },
                {
                  "textRaw": "`content` {string} 可选, 对话框的内容. 默认为空. ",
                  "name": "content",
                  "type": "string",
                  "desc": "可选, 对话框的内容. 默认为空.",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "title"
                },
                {
                  "name": "content",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>显示一个包含“确定”和“取消”按钮的提示对话框. 如果用户点击“确定”则返回 <code>true</code> , 否则返回 <code>false</code> .</p>\n<p>该函数也可以作为全局函数使用.</p>\n<p>在ui模式下该函数返回一个<code>Promise</code>. 例如:</p>\n<pre><code>&quot;ui&quot;;\nconfirm(&quot;确定吗&quot;).then(value=&gt;{\n    //当点击确定后会执行这里, value为true或false, 表示点击&quot;确定&quot;或&quot;取消&quot;\n});\n</code></pre>"
        },
        {
          "textRaw": "dialogs.rawInput(title[, prefill, callback])",
          "type": "method",
          "name": "rawInput",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`title` {string} 对话框的标题. ",
                  "name": "title",
                  "type": "string",
                  "desc": "对话框的标题."
                },
                {
                  "textRaw": "`prefill` {string} 输入框的初始内容, 可选, 默认为空. ",
                  "name": "prefill",
                  "type": "string",
                  "desc": "输入框的初始内容, 可选, 默认为空.",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "title"
                },
                {
                  "name": "prefill",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>显示一个包含输入框的对话框, 等待用户输入内容, 并在用户点击确定时将输入的字符串返回. 如果用户取消了输入, 返回null.</p>\n<p>该函数也可以作为全局函数使用.</p>\n<pre><code>var name = rawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;);\nalert(&quot;您的名字是&quot; + name);\n</code></pre><p>在ui模式下该函数返回一个<code>Promise</code>. 例如:</p>\n<pre><code>&quot;ui&quot;;\nrawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;).then(name =&gt; {\n    alert(&quot;您的名字是&quot; + name);\n});\n</code></pre><p>当然也可以使用回调函数, 例如:</p>\n<pre><code>rawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;, name =&gt; {\n     alert(&quot;您的名字是&quot; + name);\n});\n</code></pre>"
        },
        {
          "textRaw": "dialogs.input(title[, prefill, callback])",
          "type": "method",
          "name": "input",
          "desc": "<p>等效于 <code>eval(dialogs.rawInput(title, prefill, callback))</code>, 该函数和rawInput的区别在于, 会把输入的字符串用eval计算一遍再返回, 返回的可能不是字符串.</p>\n<p>可以用该函数输入数字、数组等. 例如：</p>\n<pre><code>var age = dialogs.input(&quot;请输入您的年龄&quot;, &quot;18&quot;);\n// new Date().getYear() + 1900 可获取当前年份\nvar year = new Date().getYear() + 1900 - age;\nalert(&quot;您的出生年份是&quot; + year);\n</code></pre><p>在ui模式下该函数返回一个<code>Promise</code>. 例如:</p>\n<pre><code>&quot;ui&quot;;\ndialogs.input(&quot;请输入您的年龄&quot;, &quot;18&quot;).then(age =&gt; {\n    var year = new Date().getYear() + 1900 - age;\n    alert(&quot;您的出生年份是&quot; + year);\n});\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "title"
                },
                {
                  "name": "prefill",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dialogs.prompt(title[, prefill, callback])",
          "type": "method",
          "name": "prompt",
          "desc": "<p>相当于 <code>dialogs.rawInput()</code>;</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "title"
                },
                {
                  "name": "prefill",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dialogs.select(title, items, callback)",
          "type": "method",
          "name": "select",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`title` {string} 对话框的标题. ",
                  "name": "title",
                  "type": "string",
                  "desc": "对话框的标题."
                },
                {
                  "textRaw": "`items` {Array} 对话框的选项列表, 是一个字符串数组. ",
                  "name": "items",
                  "type": "Array",
                  "desc": "对话框的选项列表, 是一个字符串数组."
                },
                {
                  "textRaw": "`callback` {Function} 回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "title"
                },
                {
                  "name": "items"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>显示一个带有选项列表的对话框, 等待用户选择, 返回用户选择的选项索引(0 ~ item.length - 1). 如果用户取消了选择, 返回-1.</p>\n<pre><code>var options = [&quot;选项A&quot;, &quot;选项B&quot;, &quot;选项C&quot;, &quot;选项D&quot;]\nvar i = dialogs.select(&quot;请选择一个选项&quot;, options);\nif(i &gt;= 0){\n    toast(&quot;您选择的是&quot; + options[i]);\n}else{\n    toast(&quot;您取消了选择&quot;);\n}\n</code></pre><p>在ui模式下该函数返回一个<code>Promise</code>. 例如:</p>\n<pre><code>&quot;ui&quot;;\ndialogs.select(&quot;请选择一个选项&quot;, [&quot;选项A&quot;, &quot;选项B&quot;, &quot;选项C&quot;, &quot;选项D&quot;])\n    .then(i =&gt; {\n        toast(i);\n    });\n</code></pre>"
        },
        {
          "textRaw": "dialogs.singleChoice(title, items[, index, callback])",
          "type": "method",
          "name": "singleChoice",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`title` {string} 对话框的标题. ",
                  "name": "title",
                  "type": "string",
                  "desc": "对话框的标题."
                },
                {
                  "textRaw": "`items` {Array} 对话框的选项列表, 是一个字符串数组. ",
                  "name": "items",
                  "type": "Array",
                  "desc": "对话框的选项列表, 是一个字符串数组."
                },
                {
                  "textRaw": "`index` {number} 对话框的初始选项的位置, 默认为0. ",
                  "name": "index",
                  "type": "number",
                  "desc": "对话框的初始选项的位置, 默认为0.",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "title"
                },
                {
                  "name": "items"
                },
                {
                  "name": "index",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>显示一个单选列表对话框, 等待用户选择, 返回用户选择的选项索引(0 ~ item.length - 1). 如果用户取消了选择, 返回-1.</p>\n<p>在ui模式下该函数返回一个<code>Promise</code>.</p>\n"
        },
        {
          "textRaw": "dialogs.multiChoice(title, items[, indices, callback])",
          "type": "method",
          "name": "multiChoice",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`title` {string} 对话框的标题. ",
                  "name": "title",
                  "type": "string",
                  "desc": "对话框的标题."
                },
                {
                  "textRaw": "`items` {Array} 对话框的选项列表, 是一个字符串数组. ",
                  "name": "items",
                  "type": "Array",
                  "desc": "对话框的选项列表, 是一个字符串数组."
                },
                {
                  "textRaw": "`indices` {Array} 选项列表中初始选中的项目索引的数组, 默认为空数组. ",
                  "name": "indices",
                  "type": "Array",
                  "desc": "选项列表中初始选中的项目索引的数组, 默认为空数组.",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数, 可选. 当用户点击确定时被调用,一般用于ui模式.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "title"
                },
                {
                  "name": "items"
                },
                {
                  "name": "indices",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>显示一个多选列表对话框, 等待用户选择, 返回用户选择的选项索引的数组. 如果用户取消了选择, 返回<code>[]</code>.</p>\n<p>在ui模式下该函数返回一个<code>Promise</code>.</p>\n"
        },
        {
          "textRaw": "dialogs.build(properties)",
          "type": "method",
          "name": "build",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`properties` {Object} 对话框属性, 用于配置对话框. ",
                  "name": "properties",
                  "type": "Object",
                  "desc": "对话框属性, 用于配置对话框."
                },
                {
                  "textRaw": "返回 {Dialog} ",
                  "name": "返回",
                  "type": "Dialog"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "properties"
                }
              ]
            }
          ],
          "desc": "<p>创建一个可自定义的对话框, 例如：</p>\n<pre><code>dialogs.build({\n    //对话框标题\n    title: &quot;发现新版本&quot;,\n    //对话框内容\n    content: &quot;更新日志: 新增了若干了BUG&quot;,\n    //确定键内容\n    positive: &quot;下载&quot;,\n    //取消键内容\n    negative: &quot;取消&quot;,\n    //中性键内容\n    neutral: &quot;到浏览器下载&quot;,\n    //勾选框内容\n    checkBoxPrompt: &quot;不再提示&quot;\n}).on(&quot;positive&quot;, ()=&gt;{\n    //监听确定键\n    toast(&quot;开始下载....&quot;);\n}).on(&quot;neutral&quot;, ()=&gt;{\n    //监听中性键\n    app.openUrl(&quot;https://www.autojs.org&quot;);\n}).on(&quot;check&quot;, (checked)=&gt;{\n    //监听勾选框\n    log(checked);\n}).show();\n</code></pre><p>选项properties可供配置的项目为:</p>\n<ul>\n<li><code>title</code> {string} 对话框标题</li>\n<li><code>titleColor</code> {string} | {number} 对话框标题的颜色</li>\n<li><code>buttonRippleColor</code> {string} | {number} 对话框按钮的波纹效果颜色</li>\n<li><code>icon</code> {string} | {Image} 对话框的图标, 是一个URL或者图片对象</li>\n<li><code>content</code> {string} 对话框文字内容</li>\n<li><code>contentColor</code>{string} | {number} 对话框文字内容的颜色</li>\n<li><code>contentLineSpacing</code>{number} 对话框文字内容的行高倍数, 1.0为一倍行高</li>\n<li><code>items</code> {Array} 对话框列表的选项</li>\n<li><code>itemsColor</code> {string} | {number} 对话框列表的选项的文字颜色</li>\n<li><code>itemsSelectMode</code> {string} 对话框列表的选项选择模式, 可以为:<ul>\n<li><code>select</code> 普通选择模式</li>\n<li><code>single</code> 单选模式</li>\n<li><code>multi</code> 多选模式</li>\n</ul>\n</li>\n<li><code>itemsSelectedIndex</code> {number} | {Array} 对话框列表中预先选中的项目索引, 如果是单选模式为一个索引；多选模式则为数组</li>\n<li><code>positive</code> {string} 对话框确定按钮的文字内容(最右边按钮)</li>\n<li><code>positiveColor</code> {string} | {number} 对话框确定按钮的文字颜色(最右边按钮)</li>\n<li><code>neutral</code> {string} 对话框中立按钮的文字内容(最左边按钮)</li>\n<li><code>neutralColor</code> {string} | {number} 对话框中立按钮的文字颜色(最左边按钮)</li>\n<li><code>negative</code> {string} 对话框取消按钮的文字内容(确定按钮左边的按钮)</li>\n<li><code>negativeColor</code> {string} | {number} 对话框取消按钮的文字颜色(确定按钮左边的按钮)</li>\n<li><code>checkBoxPrompt</code> {string} 勾选框文字内容</li>\n<li><code>checkBoxChecked</code> {boolean} 勾选框是否勾选</li>\n<li><code>progress</code> {Object} 配置对话框进度条的对象：<ul>\n<li><code>max</code> {number} 进度条的最大值, 如果为-1则为无限循环的进度条</li>\n<li><code>horizontal</code> {boolean} 如果为true, 则对话框无限循环的进度条为水平进度条</li>\n<li><code>showMinMax</code> {boolean} 是否显示进度条的最大值和最小值</li>\n</ul>\n</li>\n<li><code>cancelable</code> {boolean} 对话框是否可取消, 如果为false, 则对话框只能用代码手动取消</li>\n<li><code>canceledOnTouchOutside</code> {boolean} 对话框是否在点击对话框以外区域时自动取消, 默认为true</li>\n<li><code>inputHint</code> {string} 对话框的输入框的输入提示</li>\n<li><code>inputPrefill</code> {string} 对话框输入框的默认输入内容</li>\n</ul>\n<p>通过这些选项可以自定义一个对话框, 并通过监听返回的Dialog对象的按键、输入事件来实现交互. 下面是一些例子.</p>\n<p>模拟alert对话框：</p>\n<pre><code>dialogs.build({\n    title: &quot;你好&quot;,\n    content: &quot;今天也要元气满满哦&quot;,\n    positive: &quot;好的&quot;\n}).show();\n</code></pre><p>模拟confirm对话框:</p>\n<pre><code>dialogs.build({\n    title: &quot;你好&quot;,\n    content: &quot;请问你是笨蛋吗?&quot;,\n    positive: &quot;是的&quot;,\n    negative: &quot;我是大笨蛋&quot;\n}).on(&quot;positive&quot;, ()=&gt;{\n    alert(&quot;哈哈哈笨蛋&quot;);\n}).on(&quot;negative&quot;, ()=&gt;{\n    alert(&quot;哈哈哈大笨蛋&quot;);\n}).show();\n</code></pre><p>模拟单选框:</p>\n<pre><code>dialogs.build({\n    title: &quot;单选&quot;,\n    items: [&quot;选项1&quot;, &quot;选项2&quot;, &quot;选项3&quot;, &quot;选项4&quot;],\n    itemsSelectMode: &quot;single&quot;,\n    itemsSelectedIndex: 3\n}).on(&quot;single_choice&quot;, (index, item)=&gt;{\n    toast(&quot;您选择的是&quot; + item);\n}).show();\n</code></pre><p>&quot;处理中&quot;对话框:</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;下载中...&quot;,\n    progress: {\n        max: -1\n    },\n    cancelable: false\n}).show();\n\nsetTimeout(()=&gt;{\n    d.dismiss();\n}, 3000);\n</code></pre><p>输入对话框:</p>\n<pre><code>dialogs.build({\n    title: &quot;请输入您的年龄&quot;,\n    inputPrefill: &quot;18&quot;\n}).on(&quot;input&quot;, (input)=&gt;{\n    var age = parseInt(input);\n    toastLog(age);\n}).show();\n</code></pre><p>使用这个函数来构造对话框, 一个明显的不同是需要使用回调函数而不能像dialogs其他函数一样同步地返回结果；但也可以通过threads模块的方法来实现. 例如显示一个输入框并获取输入结果为：</p>\n<pre><code>var input = threads.disposable();\ndialogas.build({\n    title: &quot;请输入您的年龄&quot;,\n    inputPrefill: &quot;18&quot;\n}).on(&quot;input&quot;, text =&gt; {\n    input.setAndNotify(text);\n}).show();\nvar age = parseInt(input.blockedGet());\ntosatLog(age);\n</code></pre>"
        }
      ],
      "type": "module",
      "displayName": "对话框 (Dialogs)"
    },
    {
      "textRaw": "Dialog",
      "name": "dialog",
      "desc": "<p><code>dialogs.build()</code>返回的对话框对象, 内置一些事件用于响应用户的交互, 也可以获取对话框的状态和信息.</p>\n",
      "modules": [
        {
          "textRaw": "事件: `show`",
          "name": "事件:_`show`",
          "desc": "<ul>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>对话框显示时会触发的事件. 例如：</p>\n<pre><code>dialogs.build({\n    title: &quot;标题&quot;\n}).on(&quot;show&quot;, (dialog)=&gt;{\n    toast(&quot;对话框显示了&quot;);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `show`"
        },
        {
          "textRaw": "事件: `cancel`",
          "name": "事件:_`cancel`",
          "desc": "<ul>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>对话框被取消时会触发的事件. 一个对话框可能按取消按钮、返回键取消或者点击对话框以外区域取消. 例如：</p>\n<pre><code>dialogs.build({\n    title: &quot;标题&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;\n}).on(&quot;cancel&quot;, (dialog)=&gt;{\n    toast(&quot;对话框取消了&quot;);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `cancel`"
        },
        {
          "textRaw": "事件: `dismiss`",
          "name": "事件:_`dismiss`",
          "desc": "<ul>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>对话框消失时会触发的事件. 对话框被取消或者手动调用<code>dialog.dismiss()</code>函数都会触发该事件. 例如：</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;标题&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;\n}).on(&quot;dismiss&quot;, (dialog)=&gt;{\n    toast(&quot;对话框消失了&quot;);\n}).show();\n\nsetTimeout(()=&gt;{\n    d.dismiss();\n}, 5000);\n</code></pre>",
          "type": "module",
          "displayName": "事件: `dismiss`"
        },
        {
          "textRaw": "事件: `positive`",
          "name": "事件:_`positive`",
          "desc": "<ul>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>确定按钮按下时触发的事件. 例如：</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;标题&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;\n}).on(&quot;positive&quot;, (dialog)=&gt;{\n    toast(&quot;你点击了确定&quot;);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `positive`"
        },
        {
          "textRaw": "事件: `negative`",
          "name": "事件:_`negative`",
          "desc": "<ul>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>取消按钮按下时触发的事件. 例如：</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;标题&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;\n}).on(&quot;negative&quot;, (dialog)=&gt;{\n    toast(&quot;你点击了取消&quot;);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `negative`"
        },
        {
          "textRaw": "事件: `neutral`",
          "name": "事件:_`neutral`",
          "desc": "<ul>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>中性按钮按下时触发的事件. 例如：</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;标题&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;,\n    neutral: &quot;稍后提示&quot;\n}).on(&quot;positive&quot;, (dialog)=&gt;{\n    toast(&quot;你点击了稍后提示&quot;);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `neutral`"
        },
        {
          "textRaw": "事件: `any`",
          "name": "事件:_`any`",
          "desc": "<ul>\n<li><code>dialog</code> {Dialog} 对话框</li>\n<li><code>action</code> {string} 被点击的按钮, 可能的值为:<ul>\n<li><code>positive</code> 确定按钮</li>\n<li><code>negative</code> 取消按钮</li>\n<li><code>neutral</code> 中性按钮</li>\n</ul>\n</li>\n</ul>\n<p>任意按钮按下时触发的事件. 例如:</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;标题&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;,\n    neutral: &quot;稍后提示&quot;\n}).on(&quot;any&quot;, (action, dialog)=&gt;{\n    if(action == &quot;positive&quot;){\n        toast(&quot;你点击了确定&quot;);\n    }else if(action == &quot;negative&quot;){\n        toast(&quot;你点击了取消&quot;);\n    }\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `any`"
        },
        {
          "textRaw": "事件: `item_select`",
          "name": "事件:_`item_select`",
          "desc": "<ul>\n<li><code>index</code> {number} 被选中的项目索引, 从0开始</li>\n<li><code>item</code> {Object} 被选中的项目</li>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>对话框列表(itemsSelectMode为&quot;select&quot;)的项目被点击选中时触发的事件. 例如：</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;请选择&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;,\n    items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;],\n    itemsSelectMode: &quot;select&quot;\n}).on(&quot;item_select&quot;, (index, item, dialog)=&gt;{\n    toast(&quot;您选择的是第&quot; + (index + 1) + &quot;项, 选项为&quot; + item);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `item_select`"
        },
        {
          "textRaw": "事件: `single_choice`",
          "name": "事件:_`single_choice`",
          "desc": "<ul>\n<li><code>index</code> {number} 被选中的项目索引, 从0开始</li>\n<li><code>item</code> {Object} 被选中的项目</li>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>对话框单选列表(itemsSelectMode为&quot;singleChoice&quot;)的项目被选中并点击确定时触发的事件. 例如：</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;请选择&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;,\n    items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;],\n    itemsSelectMode: &quot;singleChoice&quot;\n}).on(&quot;item_select&quot;, (index, item, dialog)=&gt;{\n    toast(&quot;您选择的是第&quot; + (index + 1) + &quot;项, 选项为&quot; + item);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `single_choice`"
        },
        {
          "textRaw": "事件: `multi_choice`",
          "name": "事件:_`multi_choice`",
          "desc": "<ul>\n<li><code>indices</code> {Array} 被选中的项目的索引的数组</li>\n<li><code>items</code> {Array} 被选中的项目的数组</li>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>对话框多选列表(itemsSelectMode为&quot;multiChoice&quot;)的项目被选中并点击确定时触发的事件. 例如：</p>\n<pre><code>var d = dialogs.build({\n    title: &quot;请选择&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;,\n    items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;],\n    itemsSelectMode: &quot;multiChoice&quot;\n}).on(&quot;item_select&quot;, (indices, items, dialog)=&gt;{\n    toast(util.format(&quot;您选择的项目为%o, 选项为%o&quot;, indices, items);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `multi_choice`"
        },
        {
          "textRaw": "事件: `input`",
          "name": "事件:_`input`",
          "desc": "<ul>\n<li><code>text</code> {string} 输入框的内容</li>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>带有输入框的对话框当点击确定时会触发的事件. 例如：</p>\n<pre><code>dialogs.build({\n    title: &quot;请输入&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;,\n    inputPrefill: &quot;&quot;\n}).on(&quot;input&quot;, (text, dialog)=&gt;{\n    toast(&quot;你输入的是&quot; + text);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `input`"
        },
        {
          "textRaw": "事件: `input_change`",
          "name": "事件:_`input_change`",
          "desc": "<ul>\n<li><code>text</code> {string} 输入框的内容</li>\n<li><code>dialog</code> {Dialog} 对话框</li>\n</ul>\n<p>对话框的输入框的文本发生变化时会触发的事件. 例如：</p>\n<pre><code>dialogs.build({\n    title: &quot;请输入&quot;,\n    positive: &quot;确定&quot;,\n    negative: &quot;取消&quot;,\n    inputPrefill: &quot;&quot;\n}).on(&quot;input_change&quot;, (text, dialog)=&gt;{\n    toast(&quot;你输入的是&quot; + text);\n}).show();\n</code></pre>",
          "type": "module",
          "displayName": "事件: `input_change`"
        }
      ],
      "methods": [
        {
          "textRaw": "dialog.getProgress()",
          "type": "method",
          "name": "getProgress",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>获取当前进度条的进度值, 是一个整数</p>\n"
        },
        {
          "textRaw": "dialog.getMaxProgress()",
          "type": "method",
          "name": "getMaxProgress",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>获取当前进度条的最大进度值, 是一个整数</p>\n"
        },
        {
          "textRaw": "dialog.getActionButton(action)",
          "type": "method",
          "name": "getActionButton",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`action` {string} 动作, 包括: ",
                  "options": [
                    {
                      "textRaw": "`positive` ",
                      "name": "positive"
                    },
                    {
                      "textRaw": "`negative` ",
                      "name": "negative"
                    },
                    {
                      "textRaw": "`neutral` ",
                      "name": "neutral"
                    }
                  ],
                  "name": "action",
                  "type": "string",
                  "desc": "动作, 包括:"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "action"
                }
              ]
            }
          ],
          "desc": "<!-- [end-include:dialogs.md] -->\n<!-- [start-include:floaty.md] -->\n"
        }
      ],
      "type": "module",
      "displayName": "Dialog"
    },
    {
      "textRaw": "悬浮窗 (Floaty)",
      "name": "悬浮窗_(floaty)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>floaty模块提供了悬浮窗的相关函数, 可以在屏幕上显示自定义悬浮窗, 控制悬浮窗大小、位置等.</p>\n<p>悬浮窗在脚本停止运行时会自动关闭, 因此, 要保持悬浮窗不被关闭, 可以用一个空的setInterval来实现, 例如：</p>\n<pre><code>setInterval(()=&gt;{}, 1000);\n</code></pre>",
      "methods": [
        {
          "textRaw": "floaty.window(layout)",
          "type": "method",
          "name": "window",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`layout` {xml} | {View} 悬浮窗界面的XML或者View ",
                  "name": "layout",
                  "type": "xml",
                  "desc": "| {View} 悬浮窗界面的XML或者View"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "layout"
                }
              ]
            }
          ],
          "desc": "<p>指定悬浮窗的布局, 创建并<strong>显示</strong>一个悬浮窗, 返回一个<code>FloatyWindow</code>对象.</p>\n<p>该悬浮窗自带关闭、调整大小、调整位置按键, 可根据需要调用<code>setAdjustEnabled()</code>函数来显示或隐藏.</p>\n<p>其中layout参数可以是xml布局或者一个View, 更多信息参见ui模块的说明.</p>\n<p>例子：</p>\n<pre><code>var w = floaty.window(\n    &lt;frame gravity=&quot;center&quot;&gt;\n        &lt;text id=&quot;text&quot;&gt;悬浮文字&lt;/text&gt;\n    &lt;/frame&gt;\n);\nsetTimeout(()=&gt;{\n    w.close();\n}, 2000);\n</code></pre><p>这段代码运行后将会在屏幕上显示悬浮文字, 并在两秒后消失.</p>\n<p>另外, 因为脚本运行的线程不是UI线程, 而所有对控件的修改操作需要在UI线程执行, 此时需要用<code>ui.run</code>, 例如:</p>\n<pre><code>ui.run(function(){\n    w.text.setText(&quot;文本&quot;);\n});\n</code></pre><p>有关返回的<code>FloatyWindow</code>对象的说明, 参见下面的<code>FloatyWindow</code>章节.</p>\n"
        },
        {
          "textRaw": "floaty.rawWindow(layout)",
          "type": "method",
          "name": "rawWindow",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`layout` {xml} | {View} 悬浮窗界面的XML或者View ",
                  "name": "layout",
                  "type": "xml",
                  "desc": "| {View} 悬浮窗界面的XML或者View"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "layout"
                }
              ]
            }
          ],
          "desc": "<p>指定悬浮窗的布局, 创建并<strong>显示</strong>一个原始悬浮窗, 返回一个<code>FloatyRawWindow</code>对象.</p>\n<p>与<code>floaty.window()</code>函数不同的是, 该悬浮窗不会增加任何额外设施（例如调整大小、位置按钮）, 您可以根据自己需要编写任何布局.</p>\n<p>而且, 该悬浮窗支持完全全屏, 可以覆盖状态栏, 因此可以做护眼模式之类的应用.</p>\n<pre><code>var w = floaty.rawWindow(\n    &lt;frame gravity=&quot;center&quot;&gt;\n        &lt;text id=&quot;text&quot;&gt;悬浮文字&lt;/text&gt;\n    &lt;/frame&gt;\n);\n\nw.setPosition(500, 500);\n\nsetTimeout(()=&gt;{\n    w.close();\n}, 2000);\n</code></pre><p>这段代码运行后将会在屏幕上显示悬浮文字, 并在两秒后消失.</p>\n<p>有关返回的<code>FloatyRawWindow</code>对象的说明, 参见下面的<code>FloatyRawWindow</code>章节.</p>\n"
        },
        {
          "textRaw": "floaty.closeAll()",
          "type": "method",
          "name": "closeAll",
          "desc": "<p>关闭所有本脚本的悬浮窗.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "悬浮窗 (Floaty)"
    },
    {
      "textRaw": "FloatyWindow",
      "name": "floatywindow",
      "desc": "<p>悬浮窗对象, 可通过<code>FloatyWindow.{id}</code>获取悬浮窗界面上的元素. 例如, 悬浮窗window上一个控件的id为aaa, 那么<code>window.aaa</code>即可获取到该控件, 类似于ui.</p>\n",
      "methods": [
        {
          "textRaw": "window.setAdjustEnabled(enabled)",
          "type": "method",
          "name": "setAdjustEnabled",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`enabled` {boolean} 是否启用悬浮窗调整(大小、位置) ",
                  "name": "enabled",
                  "type": "boolean",
                  "desc": "是否启用悬浮窗调整(大小、位置)"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "enabled"
                }
              ]
            }
          ],
          "desc": "<p>如果enabled为true, 则在悬浮窗左上角、右上角显示可供位置、大小调整的标示, 就像控制台一样；\n如果enabled为false, 则隐藏上述标示.</p>\n"
        },
        {
          "textRaw": "window.setPosition(x, y)",
          "type": "method",
          "name": "setPosition",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} x ",
                  "name": "x",
                  "type": "number",
                  "desc": "x"
                },
                {
                  "textRaw": "`x` {number} y ",
                  "name": "x",
                  "type": "number",
                  "desc": "y"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ],
          "desc": "<p>设置悬浮窗位置.</p>\n"
        },
        {
          "textRaw": "window.getX()",
          "type": "method",
          "name": "getX",
          "desc": "<p>返回悬浮窗位置的X坐标.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.getY()",
          "type": "method",
          "name": "getY",
          "desc": "<p>返回悬浮窗位置的Y坐标.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.setSize(width, height)",
          "type": "method",
          "name": "setSize",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`width` {number} 宽度 ",
                  "name": "width",
                  "type": "number",
                  "desc": "宽度"
                },
                {
                  "textRaw": "`height` {number} 高度 ",
                  "name": "height",
                  "type": "number",
                  "desc": "高度"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "width"
                },
                {
                  "name": "height"
                }
              ]
            }
          ],
          "desc": "<p>设置悬浮窗宽高.</p>\n"
        },
        {
          "textRaw": "window.getWidht()",
          "type": "method",
          "name": "getWidht",
          "desc": "<p>返回悬浮窗宽度.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.getHeight()",
          "type": "method",
          "name": "getHeight",
          "desc": "<p>返回悬浮窗高度.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.close()",
          "type": "method",
          "name": "close",
          "desc": "<p>关闭悬浮窗. 如果悬浮窗已经是关闭状态, 则此函数将不执行任何操作.</p>\n<p>被关闭后的悬浮窗不能再显示.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.exitOnClose()",
          "type": "method",
          "name": "exitOnClose",
          "desc": "<p>使悬浮窗被关闭时自动结束脚本运行.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "FloatyWindow"
    },
    {
      "textRaw": "FloatyRawWindow",
      "name": "floatyrawwindow",
      "desc": "<p>原始悬浮窗对象, 可通过<code>window.{id}</code>获取悬浮窗界面上的元素. 例如, 悬浮窗window上一个控件的id为aaa, 那么<code>window.aaa</code>即可获取到该控件, 类似于ui.</p>\n",
      "methods": [
        {
          "textRaw": "window.setTouchable(touchable)",
          "type": "method",
          "name": "setTouchable",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`touchable` {Boolean} 是否可触摸 ",
                  "name": "touchable",
                  "type": "Boolean",
                  "desc": "是否可触摸"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "touchable"
                }
              ]
            }
          ],
          "desc": "<p>设置悬浮窗是否可触摸, 如果为true, 则悬浮窗将接收到触摸、点击等事件并且无法继续传递到悬浮窗下面；如果为false, 悬浮窗上的触摸、点击等事件将被直接传递到悬浮窗下面. 处于安全考虑, 被悬浮窗接收的触摸事情无法再继续传递到下层.</p>\n<p>可以用此特性来制作护眼模式脚本.</p>\n<pre><code>var w = floaty.rawWindow(\n    &lt;frame gravity=&quot;center&quot; bg=&quot;#44ffcc00&quot;/&gt;\n);\n\nw.setSize(-1, -1);\nw.setTouchable(false);\n\nsetTimeout(()=&gt;{\n    w.close();\n}, 4000);\n\n</code></pre>"
        },
        {
          "textRaw": "window.setPosition(x, y)",
          "type": "method",
          "name": "setPosition",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} x ",
                  "name": "x",
                  "type": "number",
                  "desc": "x"
                },
                {
                  "textRaw": "`x` {number} y ",
                  "name": "x",
                  "type": "number",
                  "desc": "y"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ],
          "desc": "<p>设置悬浮窗位置.</p>\n"
        },
        {
          "textRaw": "window.getX()",
          "type": "method",
          "name": "getX",
          "desc": "<p>返回悬浮窗位置的X坐标.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.getY()",
          "type": "method",
          "name": "getY",
          "desc": "<p>返回悬浮窗位置的Y坐标.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.setSize(width, height)",
          "type": "method",
          "name": "setSize",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`width` {number} 宽度 ",
                  "name": "width",
                  "type": "number",
                  "desc": "宽度"
                },
                {
                  "textRaw": "`height` {number} 高度 ",
                  "name": "height",
                  "type": "number",
                  "desc": "高度"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "width"
                },
                {
                  "name": "height"
                }
              ]
            }
          ],
          "desc": "<p>设置悬浮窗宽高.</p>\n<p>特别地, 如果设置为-1, 则为占满全屏；设置为-2则为根据悬浮窗内容大小而定. 例如：</p>\n<pre><code>var w = floaty.rawWindow(\n    &lt;frame gravity=&quot;center&quot; bg=&quot;#77ff0000&quot;&gt;\n        &lt;text id=&quot;text&quot;&gt;悬浮文字&lt;/text&gt;\n    &lt;/frame&gt;\n);\n\nw.setSize(-1, -1);\n\nsetTimeout(()=&gt;{\n    w.close();\n}, 2000);\n\n</code></pre>"
        },
        {
          "textRaw": "window.getWidht()",
          "type": "method",
          "name": "getWidht",
          "desc": "<p>返回悬浮窗宽度.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.getHeight()",
          "type": "method",
          "name": "getHeight",
          "desc": "<p>返回悬浮窗高度.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.close()",
          "type": "method",
          "name": "close",
          "desc": "<p>关闭悬浮窗. 如果悬浮窗已经是关闭状态, 则此函数将不执行任何操作.</p>\n<p>被关闭后的悬浮窗不能再显示.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "window.exitOnClose()",
          "type": "method",
          "name": "exitOnClose",
          "desc": "<p>使悬浮窗被关闭时自动结束脚本运行.</p>\n<!-- [end-include:floaty.md] -->\n<!-- [start-include:canvas.md] -->\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "FloatyRawWindow"
    },
    {
      "textRaw": "画布 (Canvas)",
      "name": "画布_(canvas)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>canvas提供了使用画布进行2D画图的支持, 可用于简单的小游戏开发或者图片编辑. 使用canvas可以轻松地在一张图片或一个界面上绘制各种线与图形.</p>\n<p>canvas的坐标系为平面直角坐标系, 以控件左上角为原点, 控件上边沿为x轴正方向, 控件左边沿为y轴正方向. 例如分辨率为1920*1080的屏幕上, canvas控件覆盖全屏, 画一条从屏幕左上角到屏幕右下角的线段为:</p>\n<pre><code>canvas.drawLine(0, 0, 1080, 1920, paint);\n</code></pre><p>canvas的绘制依赖于画笔Paint, 通过设置画笔的粗细、颜色、填充等可以改变绘制出来的图形. 例如绘制一个红色实心正方形为：</p>\n<pre><code>var paint = new Paint();\n//设置画笔为填充, 则绘制出来的图形都是实心的\npaint.setStyle(Paint.STYLE.FILL);\n//设置画笔颜色为红色\npaint.setColor(colors.RED);\n//绘制一个从坐标(0, 0)到坐标(100, 100)的正方形\ncanvas.drawRect(0, 0, 100, 100, paint);\n</code></pre><p>如果要绘制正方形的边框, 则通过设置画笔的Style来实现：</p>\n<pre><code>var paint = new Paint();\n//设置画笔为描边, 则绘制出来的图形都是轮廓\npaint.setStyle(Paint.STYLE.STROKE);\n//设置画笔颜色为红色\npaint.setColor(colors.RED);\n//绘制一个从坐标(0, 0)到坐标(100, 100)的正方形\ncanvas.drawRect(0, 0, 100, 100, paint);\n</code></pre><p>结合画笔, canvas可以绘制基本图形、图片等.</p>\n",
      "methods": [
        {
          "textRaw": "canvas.getWidth()",
          "type": "method",
          "name": "getWidth",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回画布当前图层的宽度.</p>\n"
        },
        {
          "textRaw": "canvas.getHeight()",
          "type": "method",
          "name": "getHeight",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "返回 {number} ",
                  "name": "返回",
                  "type": "number"
                }
              ]
            },
            {
              "params": []
            }
          ],
          "desc": "<p>返回画布当前图层的高度.</p>\n"
        },
        {
          "textRaw": "canvas.drawRGB(r, int g, int b)",
          "type": "method",
          "name": "drawRGB",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`r` {number} 红色通道值 ",
                  "name": "r",
                  "type": "number",
                  "desc": "红色通道值"
                },
                {
                  "textRaw": "`g` {number} 绿色通道值 ",
                  "name": "g",
                  "type": "number",
                  "desc": "绿色通道值"
                },
                {
                  "textRaw": "`b` {number} 蓝色通道值 ",
                  "name": "b",
                  "type": "number",
                  "desc": "蓝色通道值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "r"
                },
                {
                  "name": "int g"
                },
                {
                  "name": "int b"
                }
              ]
            }
          ],
          "desc": "<p>将整个可绘制区域填充为r、g、b指定的颜色. 相当于 <code>canvas.drawColor(colors.rgb(r, g, b))</code>.</p>\n"
        },
        {
          "textRaw": "canvas.drawARGB(a, r, g, b)",
          "type": "method",
          "name": "drawARGB",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`a` {number} 透明通道值 ",
                  "name": "a",
                  "type": "number",
                  "desc": "透明通道值"
                },
                {
                  "textRaw": "`r` {number} 红色通道值 ",
                  "name": "r",
                  "type": "number",
                  "desc": "红色通道值"
                },
                {
                  "textRaw": "`g` {number} 绿色通道值 ",
                  "name": "g",
                  "type": "number",
                  "desc": "绿色通道值"
                },
                {
                  "textRaw": "`b` {number} 蓝色通道值 ",
                  "name": "b",
                  "type": "number",
                  "desc": "蓝色通道值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "a"
                },
                {
                  "name": "r"
                },
                {
                  "name": "g"
                },
                {
                  "name": "b"
                }
              ]
            }
          ],
          "desc": "<p>将整个可绘制区域填充为a、r、g、b指定的颜色. 相当于 <code>canvas.drawColor(colors.argb(a, r, g, b))</code>.</p>\n"
        },
        {
          "textRaw": "canvas.drawColor(color)",
          "type": "method",
          "name": "drawColor",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color` {number} 颜色值 ",
                  "name": "color",
                  "type": "number",
                  "desc": "颜色值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color"
                }
              ]
            }
          ],
          "desc": "<p>将整个可绘制区域填充为color指定的颜色.</p>\n"
        },
        {
          "textRaw": "canvas.drawColor(color, mode)",
          "type": "method",
          "name": "drawColor",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`color` {number} 颜色值 ",
                  "name": "color",
                  "type": "number",
                  "desc": "颜色值"
                },
                {
                  "textRaw": "`mode` {PorterDuff.Mode} Porter-Duff操作 ",
                  "name": "mode",
                  "type": "PorterDuff.Mode",
                  "desc": "Porter-Duff操作"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ],
          "desc": "<p>将整个可绘制区域填充为color指定的颜色.</p>\n"
        },
        {
          "textRaw": "canvas.drawPaint(paint)",
          "type": "method",
          "name": "drawPaint",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`paint` {Paint} 画笔 ",
                  "name": "paint",
                  "type": "Paint",
                  "desc": "画笔"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "paint"
                }
              ]
            }
          ],
          "desc": "<p>将整个可绘制区域用paint指定的画笔填充. 相当于绘制一个无限大的矩形, 但是更快.\n通过该方法可以绘制一个指定的着色器的图案.</p>\n"
        },
        {
          "textRaw": "canvas.drawPoint(x, y, paint)",
          "type": "method",
          "name": "drawPoint",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} x坐标 ",
                  "name": "x",
                  "type": "number",
                  "desc": "x坐标"
                },
                {
                  "textRaw": "`y` {number} y坐标 ",
                  "name": "y",
                  "type": "number",
                  "desc": "y坐标"
                },
                {
                  "textRaw": "`paint` {Paint} 画笔 ",
                  "name": "paint",
                  "type": "Paint",
                  "desc": "画笔"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "paint"
                }
              ]
            }
          ],
          "desc": "<p>在可绘制区域绘制由坐标(x, y)指定的点.\n点的形状由画笔的线帽决定（参见paint.setStrokeCap(cap)）.\n点的大小由画笔的宽度决定（参见paint.setStrokeWidth(width)）.</p>\n<blockquote>\n<p>如果画笔宽度为0, 则也会绘制1个像素至4个（若抗锯齿启用）.</p>\n</blockquote>\n<p>相当于 <code>canvas.drawPoints([x, y], paint)</code>.</p>\n"
        },
        {
          "textRaw": "canvas.drawPoints(pts, paint)",
          "type": "method",
          "name": "drawPoints",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`pts` {Array<number>} 点坐标数组 [x0, y0, x1, y1, x2, y2, ...] ",
                  "name": "pts",
                  "type": "Array<number>",
                  "desc": "点坐标数组 [x0, y0, x1, y1, x2, y2, ...]"
                },
                {
                  "textRaw": "`paint` {Paint} 画笔 ",
                  "name": "paint",
                  "type": "Paint",
                  "desc": "画笔"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "pts"
                },
                {
                  "name": "paint"
                }
              ]
            }
          ],
          "desc": "<p>在可绘制区域绘制由坐标数组指定的多个点.</p>\n"
        },
        {
          "textRaw": "canvas.drawLine(startX, startY, stopX, stopY, paint)",
          "type": "method",
          "name": "drawLine",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`startX` {number} 起点x坐标 ",
                  "name": "startX",
                  "type": "number",
                  "desc": "起点x坐标"
                },
                {
                  "textRaw": "`startY` {number} 起点y坐标 ",
                  "name": "startY",
                  "type": "number",
                  "desc": "起点y坐标"
                },
                {
                  "textRaw": "`endX` {number} 终点x坐标 ",
                  "name": "endX",
                  "type": "number",
                  "desc": "终点x坐标"
                },
                {
                  "textRaw": "`endY` {number} 终点y坐标 ",
                  "name": "endY",
                  "type": "number",
                  "desc": "终点y坐标"
                },
                {
                  "textRaw": "`paint` {Paint} 画笔 ",
                  "name": "paint",
                  "type": "Paint",
                  "desc": "画笔"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "startX"
                },
                {
                  "name": "startY"
                },
                {
                  "name": "stopX"
                },
                {
                  "name": "stopY"
                },
                {
                  "name": "paint"
                }
              ]
            }
          ],
          "desc": "<p>在可绘制区域绘制由起点坐标(startX, startY)和终点坐标(endX, endY)指定的线.\n绘制时会忽略画笔的样式(Style). 也就是说, 即使样式设为“仅填充(FILL)”也会绘制.\n退化为点的线（长度为0）不会被绘制.</p>\n"
        },
        {
          "textRaw": "canvas.drawRect(r, paint)",
          "type": "method",
          "name": "drawRect",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`r` {Rect} 矩形边界 ",
                  "name": "r",
                  "type": "Rect",
                  "desc": "矩形边界"
                },
                {
                  "textRaw": "`paint` {Paint} 画笔 ",
                  "name": "paint",
                  "type": "Paint",
                  "desc": "画笔"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "r"
                },
                {
                  "name": "paint"
                }
              ]
            }
          ],
          "desc": "<p>在可绘制区域绘制由矩形边界r指定的矩形.\n绘制时画笔的样式(Style)决定了是否绘制矩形界线和填充矩形.</p>\n"
        },
        {
          "textRaw": "canvas.drawRect(left, top, right, bottom, android.graphics.Paint paint)",
          "type": "method",
          "name": "drawRect",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`left` {number} 矩形左边界x坐标 ",
                  "name": "left",
                  "type": "number",
                  "desc": "矩形左边界x坐标"
                },
                {
                  "textRaw": "`top` {number} 矩形上边界y坐标 ",
                  "name": "top",
                  "type": "number",
                  "desc": "矩形上边界y坐标"
                },
                {
                  "textRaw": "`right` {number} 矩形右边界x坐标 ",
                  "name": "right",
                  "type": "number",
                  "desc": "矩形右边界x坐标"
                },
                {
                  "textRaw": "`bottom` {number} 矩形下边界y坐标 ",
                  "name": "bottom",
                  "type": "number",
                  "desc": "矩形下边界y坐标"
                },
                {
                  "textRaw": "`paint` {Paint} 画笔 ",
                  "name": "paint",
                  "type": "Paint",
                  "desc": "画笔"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "left"
                },
                {
                  "name": "top"
                },
                {
                  "name": "right"
                },
                {
                  "name": "bottom"
                },
                {
                  "name": "android.graphics.Paint paint"
                }
              ]
            }
          ],
          "desc": "<p>在可绘制区域绘制由矩形边界(left, top, right, bottom)指定的矩形.\n绘制时画笔的样式(Style)决定了是否绘制矩形界线和填充矩形.</p>\n"
        },
        {
          "textRaw": "canvas.drawTextOnPath(java.lang.String text, android.graphics.Path path, float hOffset, float vOffset, android.graphics.Paint paint)",
          "type": "method",
          "name": "drawTextOnPath",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`dx` {number} 向x轴正方向平移的距离, 负数表示反方向平移 ",
                  "name": "dx",
                  "type": "number",
                  "desc": "向x轴正方向平移的距离, 负数表示反方向平移"
                },
                {
                  "textRaw": "`dy` {number} 向y轴正方向平移的距离, 负数表示反方向平移 ",
                  "name": "dy",
                  "type": "number",
                  "desc": "向y轴正方向平移的距离, 负数表示反方向平移"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "dx"
                },
                {
                  "name": "dy"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "java.lang.String text"
                },
                {
                  "name": "android.graphics.Path path"
                },
                {
                  "name": "float hOffset"
                },
                {
                  "name": "float vOffset"
                },
                {
                  "name": "android.graphics.Paint paint"
                }
              ]
            }
          ],
          "desc": "<p>平移指定距离.</p>\n"
        },
        {
          "textRaw": "canvas.translate(dx, dy)",
          "type": "method",
          "name": "translate",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`dx` {number} 向x轴正方向平移的距离, 负数表示反方向平移 ",
                  "name": "dx",
                  "type": "number",
                  "desc": "向x轴正方向平移的距离, 负数表示反方向平移"
                },
                {
                  "textRaw": "`dy` {number} 向y轴正方向平移的距离, 负数表示反方向平移 ",
                  "name": "dy",
                  "type": "number",
                  "desc": "向y轴正方向平移的距离, 负数表示反方向平移"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "dx"
                },
                {
                  "name": "dy"
                }
              ]
            }
          ],
          "desc": "<p>平移指定距离.</p>\n"
        },
        {
          "textRaw": "canvas.scale(sx, sy)",
          "type": "method",
          "name": "scale",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`sx` {number} 向x轴正方向平移的距离, 负数表示反方向平移 ",
                  "name": "sx",
                  "type": "number",
                  "desc": "向x轴正方向平移的距离, 负数表示反方向平移"
                },
                {
                  "textRaw": "`sy` {number} 向y轴正方向平移的距离, 负数表示反方向平移 ",
                  "name": "sy",
                  "type": "number",
                  "desc": "向y轴正方向平移的距离, 负数表示反方向平移"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "sx"
                },
                {
                  "name": "sy"
                }
              ]
            }
          ],
          "desc": "<p>以原点为中心, 将坐标系平移缩放指定倍数.</p>\n"
        },
        {
          "textRaw": "canvas.rotate(float degrees, float px, float py)",
          "type": "method",
          "name": "rotate",
          "signatures": [
            {
              "params": [
                {
                  "name": "float sx"
                },
                {
                  "name": "float sy"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "float degrees"
                },
                {
                  "name": "float px"
                },
                {
                  "name": "float py"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "canvas.skew(float sx, float sy)",
          "type": "method",
          "name": "skew",
          "signatures": [
            {
              "params": [
                {
                  "name": "float sx"
                },
                {
                  "name": "float sy"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "画布 (Canvas)"
    },
    {
      "textRaw": "路径特效",
      "name": "路径特效",
      "desc": "<!-- [end-include:canvas.md] -->\n<!-- [start-include:ui.md] -->\n",
      "type": "module",
      "displayName": "区域"
    },
    {
      "textRaw": "区域",
      "name": "区域",
      "desc": "<!-- [end-include:canvas.md] -->\n<!-- [start-include:ui.md] -->\n",
      "type": "module",
      "displayName": "区域"
    },
    {
      "textRaw": "用户界面 (UI)",
      "name": "用户界面_(ui)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>ui模块提供了编写用户界面的支持.</p>\n<pre><code>给Android开发者或者高阶用户的提醒, Auto.js的UI系统来自于Android, 所有属性和方法都能在Android源码中找到. 如果某些代码或属性没有出现在Auto.js的文档中, 可以参考Android的文档.\nView: https://developer.android.google.cn/reference/android/view/View?hl=cn\nWidget: https://developer.android.google.cn/reference/android/widget/package-summary?hl=cn\n</code></pre><p>带有ui的脚本的的最前面必须使用<code>&quot;ui&quot;;</code>指定ui模式, 否则脚本将不会以ui模式运行. 正确示范:s</p>\n<pre><code>&quot;ui&quot;;\n\n//脚本的其他代码\n</code></pre><p>字符串&quot;ui&quot;的前面可以有注释、空行和空格<strong>[v4.1.0新增]</strong>, 但是不能有其他代码.</p>\n<p>界面是由视图(View)组成的. View分成两种, 控件(Widget)和布局(Layout). 控件(Widget)用来具体显示文字、图片、网页等, 比如文本控件(text)用来显示文字, 按钮控件(button)则可以显示一个按钮并提供点击效果, 图片控件(img)则用来显示来自网络或者文件的图片, 除此之外还有输入框控件(input)、进度条控件(progressbar)、单选复选框控件(checkbox)等；布局(Layout)则是装着一个或多个控件的&quot;容器&quot;, 用于控制在他里面的控件的位置, 比如垂直布局(vertical)会把他里面的控件从上往下依次显示(即纵向排列), 水平布局(horizontal)则会把他里面的控件从左往右依次显示(即横向排列), 以及帧布局(frame), 他会把他里面的控件直接在左上角显示, 如果有多个控件, 后面的控件会重叠在前面的控件上.</p>\n<p>我们使用xml来编写界面, 并通过<code>ui.layout()</code>函数指定界面的布局xml. 举个例子：</p>\n<pre><code>&quot;ui&quot;;\n$ui.layout(\n    &lt;vertical&gt;\n        &lt;button text=&quot;第一个按钮&quot;/&gt;\n        &lt;button text=&quot;第二个按钮&quot;/&gt;\n    &lt;/vertical&gt;\n);\n</code></pre><p>在这个例子中, 第3~6行的部分就是xml, 指定了界面的具体内容. 代码的第3行的标签<code>&lt;vertical&gt; ... &lt;/vertical&gt;</code>表示垂直布局, 布局的标签通常以<code>&lt;...&gt;</code>开始, 以<code>&lt;/...&gt;</code>结束, 两个标签之间的内容就是布局里面的内容, 例如<code>&lt;frame&gt; ... &lt;/frame&gt;</code>. 在这个例子中第4, 5行的内容就是垂直布局(vertical)里面的内容. 代码的第4行是一个按钮控件(button), 控件的标签通常以<code>&lt;...</code>开始, 以<code>/&gt;</code>结束, 他们之间是控件的具体属性, 例如<code>&lt;text ... /&gt;</code>. 在这个例子中<code>text=&quot;第一个按钮&quot;</code>的部分就是按钮控件(button)的属性, 这个属性指定了这个按钮控件的文本内容(text)为&quot;第一个按钮&quot;.</p>\n<p>代码的第5行和第4行一样, 也是一个按钮控件, 只不过他的文本内容为&quot;第二个按钮&quot;. 这两个控件在垂直布局中, 因此会纵向排列, 效果如图：</p>\n<p><img src=\"images/ex1.png\" alt=\"ex1\"></p>\n<p>如果我们把这个例子的垂直布局(vertical)改成水平布局(horizontal), 也即：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;horizontal&gt;\n        &lt;button text=&quot;第一个按钮&quot;/&gt;\n        &lt;button text=&quot;第二个按钮&quot;/&gt;\n    &lt;/horizontal&gt;\n);\n</code></pre><p>则这两个按钮会横向排列, 效果如图：</p>\n<p><img src=\"images/ex1-horizontal.png\" alt=\"ex1-horizontal\"></p>\n<p>一个控件可以指定多个属性(甚至可以不指定任何属性), 用空格隔开即可；布局同样也可以指定属性, 例如:</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical bg=&quot;#ff0000&quot;&gt;\n        &lt;button text=&quot;第一个按钮&quot; textSize=&quot;20sp&quot;/&gt;\n        &lt;button text=&quot;第二个按钮&quot;/&gt;\n    &lt;/vertical&gt;\n);\n</code></pre><p>第三行<code>bg=&quot;#ff0000&quot;</code>指定了垂直布局的背景色(bg)为&quot;#ff0000&quot;, 这是一个RGB颜色, 表示红色(有关RGB的相关知识参见<a href=\"http://tool.oschina.net/commons?type=3\">RGB颜色对照表</a>). 第四行的<code>textSize=&quot;20sp&quot;</code>则指定了按钮控件的字体大小(textSize)为&quot;20sp&quot;, sp是一个字体单位, 暂时不用深入理会. 上述代码的效果如图：</p>\n<p><img src=\"images/ex1-properties.png\" alt=\"ex-properties\"></p>\n<p>一个界面便由一些布局和控件组成. 为了便于文档阅读, 我们再说明一下以下术语：</p>\n<ul>\n<li>子视图, 子控件: 布局里面的控件是这个布局的子控件/子视图. 实际上布局里面不仅仅只能有控件, 还可以是嵌套的布局. 因此用子视图(Child View)更准确一些. 在上面的例子中, 按钮便是垂直布局的子控件.</li>\n<li>父视图, 父布局：直接包含一个控件的布局是这个控件的父布局/父视图(Parent View). 在上面的例子中, 垂直布局便是按钮的父布局.</li>\n</ul>\n",
      "type": "module",
      "displayName": "用户界面 (UI)"
    },
    {
      "textRaw": "视图: View",
      "name": "视图:_view",
      "desc": "<p>控件和布局都属于视图(View). 在这个章节中将介绍所有控件和布局的共有的属性和函数. 例如属性背景, 宽高等(所有控件和布局都能设置背景和宽高), 函数<code>click()</code>设置视图(View)被点击时执行的动作.</p>\n",
      "methods": [
        {
          "textRaw": "attr(name, value)",
          "type": "method",
          "name": "attr",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`name` {string} 属性名称 ",
                  "name": "name",
                  "type": "string",
                  "desc": "属性名称"
                },
                {
                  "textRaw": "`value` {string} 属性的值 ",
                  "name": "value",
                  "type": "string",
                  "desc": "属性的值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "name"
                },
                {
                  "name": "value"
                }
              ]
            }
          ],
          "desc": "<p>设置属性的值. 属性指定是View在xml中的属性. 例如可以通过语句<code>attr(&quot;text&quot;, &quot;文本&quot;)</code>来设置文本控件的文本值.</p>\n<pre><code class=\"lang-javascript\">&quot;ui&quot;;\n\n$ui.layout(\n    &lt;frame&gt;\n        &lt;text id=&quot;example&quot; text=&quot;Hello&quot;/&gt;\n    &lt;/frame&gt;\n);\n\n// 5秒后执行\n$ui.post(() =&gt; {\n    // 修改文本\n    $ui.example.attr(&quot;text&quot;, &quot;Hello, Auto.js UI&quot;);\n    // 修改背景\n    $ui.example.attr(&quot;bg&quot;, &quot;#ff00ff&quot;);\n    // 修改高度\n    $ui.example.attr(&quot;h&quot;, &quot;500dp&quot;);\n}, 5000);\n</code></pre>\n<p><strong>注意：</strong>并不是所有属性都能在js代码设置, 有一些属性只能在布局创建时设置, 例如style属性；还有一些属性虽然能在代码中设置, 但是还没支持；对于这些情况, 在Auto.js Pro 8.1.0+会抛出异常, 其他版本则不会抛出异常.</p>\n"
        },
        {
          "textRaw": "attr(name)",
          "type": "method",
          "name": "attr",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`name` {string} 属性名称 ",
                  "name": "name",
                  "type": "string",
                  "desc": "属性名称"
                },
                {
                  "textRaw": "返回 {string} ",
                  "name": "返回",
                  "type": "string"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "name"
                }
              ]
            }
          ],
          "desc": "<p>获取属性的值.</p>\n<pre><code class=\"lang-javascript\">&quot;ui&quot;;\n\n$ui.layout(\n    &lt;frame&gt;\n        &lt;text id=&quot;example&quot; text=&quot;1&quot;/&gt;\n    &lt;/frame&gt;\n);\n\nplusOne();\n\nfunction plusOne() {\n    // 获取文本\n    let text = $ui.example.attr(&quot;text&quot;);\n    // 解析为数字\n    let num = parseInt(text);\n    // 数字加1\n    num++;\n    // 设置文本\n    $ui.example.attr(&quot;text&quot;, String(num));\n    // 1秒后继续\n    $ui.post(plusOne, 1000);\n}\n\n</code></pre>\n"
        }
      ],
      "modules": [
        {
          "textRaw": "w",
          "name": "w",
          "desc": "<p>View的宽度, 是属性<code>width</code>的缩写形式. 可以设置的值为<code>*</code>, <code>auto</code>和具体数值. 其中<code>*</code>表示宽度<strong>尽量</strong>填满父布局, 而<code>auto</code>表示宽度将根据View的内容自动调整(自适应宽度). 例如：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;horizontal&gt;\n        &lt;button w=&quot;auto&quot; text=&quot;自适应宽度&quot;/&gt;\n        &lt;button w=&quot;*&quot; text=&quot;填满父布局&quot;/&gt;\n    &lt;/horizontal&gt;\n);\n</code></pre><p>在这个例子中, 第一个按钮为自适应宽度, 第二个按钮为填满父布局, 显示效果为：</p>\n<p><img src=\"images/ex-w.png\" alt=\"ex-w\"></p>\n<p>如果不设置该属性, 则不同的控件和布局有不同的默认宽度, 大多数为<code>auto</code>.</p>\n<p>宽度属性也可以指定一个具体数值. 例如<code>w=&quot;20&quot;</code>, <code>w=&quot;20px&quot;</code>等. 不加单位的情况下默认单位为dp, 其他单位包括px(像素), mm(毫米), in(英寸). 有关尺寸单位的更多内容, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;horizontal&gt;\n        &lt;button w=&quot;200&quot; text=&quot;宽度200dp&quot;/&gt;\n        &lt;button w=&quot;100&quot; text=&quot;宽度100dp&quot;/&gt;\n    &lt;/horizontal&gt;\n);\n</code></pre>",
          "type": "module",
          "displayName": "w"
        },
        {
          "textRaw": "h",
          "name": "h",
          "desc": "<p>View的高度, 是属性<code>height</code>的缩写形式. 可以设置的值为<code>*</code>, <code>auto</code>和具体数值. 其中<code>*</code>表示宽度<strong>尽量</strong>填满父布局, 而<code>auto</code>表示宽度将根据View的内容自动调整(自适应宽度).</p>\n<p>如果不设置该属性, 则不同的控件和布局有不同的默认高度, 大多数为<code>auto</code>.</p>\n<p>宽度属性也可以指定一个具体数值. 例如<code>h=&quot;20&quot;</code>, <code>h=&quot;20px&quot;</code>等. 不加单位的情况下默认单位为dp, 其他单位包括px(像素), mm(毫米), in(英寸). 有关尺寸单位的更多内容, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "h"
        },
        {
          "textRaw": "id",
          "name": "id",
          "desc": "<p>View的id, 用来区分一个界面下的不同控件和布局, 一个界面的id在同一个界面下通常是唯一的, 也就是一般不存在两个View有相同的id. id属性也是连接xml布局和JavaScript代码的桥梁, 在代码中可以通过一个View的id来获取到这个View, 并对他进行操作(设置点击动作、设置属性、获取属性等). 例如：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;frame&gt;\n        &lt;button id=&quot;ok&quot; text=&quot;确定&quot;/&gt;\n    &lt;/frame&gt;\n);\n//通过ui.ok获取到按钮控件\ntoast(ui.ok.getText());\n</code></pre><p>这个例子中有一个按钮控件&quot;确定&quot;, id属性为&quot;ok&quot;, 那么我们可以在代码中使用<code>ui.ok</code>来获取他, 再通过<code>getText()</code>函数获取到这个按钮控件的文本内容.\n另外这个例子中使用帧布局(frame)是因为, 我们只有一个控件, 因此用于最简单的布局帧布局.</p>\n",
          "type": "module",
          "displayName": "id"
        },
        {
          "textRaw": "gravity",
          "name": "gravity",
          "desc": "<p>View的&quot;重力&quot;. 用于决定View的内容相对于View的位置, 可以设置的值为:</p>\n<ul>\n<li><code>left</code> 靠左</li>\n<li><code>right</code> 靠右</li>\n<li><code>top</code> 靠顶部</li>\n<li><code>bottom</code> 靠底部</li>\n<li><code>center</code> 居中</li>\n<li><code>center_vertical</code> 垂直居中</li>\n<li><code>center_horizontal</code> 水平居中</li>\n</ul>\n<p>例如对于一个按钮控件, <code>gravity=&quot;right&quot;</code>会使其中的文本内容靠右显示. 例如：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;frame&gt;\n        &lt;button gravity=&quot;right&quot; w=&quot;*&quot; h=&quot;auto&quot; text=&quot;靠右的文字&quot;/&gt;\n    &lt;/frame&gt;\n);\n</code></pre><p>显示效果为:</p>\n<p><img src=\"images/ex-gravity.png\" alt=\"ex-gravity\"></p>\n<p>这些属性是可以组合的, 例如<code>gravity=&quot;right|bottom&quot;</code>的View他的内容会在右下角.</p>\n",
          "type": "module",
          "displayName": "gravity"
        },
        {
          "textRaw": "layout_gravity",
          "name": "layout_gravity",
          "desc": "<p>View在布局中的&quot;重力&quot;, 用于决定View本身在他的<strong>父布局</strong>的位置, 可以设置的值和gravity属性相同. 注意把这个属性和gravity属性区分开来.</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;frame w=&quot;*&quot; h=&quot;*&quot;&gt;\n        &lt;button layout_gravity=&quot;center&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;居中的按钮&quot;/&gt;\n        &lt;button layout_gravity=&quot;right|bottom&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;右下角的按钮&quot;/&gt;\n    &lt;/frame&gt;\n);\n</code></pre><p>在这个例子中, 我们让帧布局(frame)的大小占满整个屏幕, 通过给第一个按钮设置属性<code>layout_gravity=&quot;center&quot;</code>来使得按钮在帧布局中居中, 通过给第二个按钮设置属性<code>layout_gravity=&quot;right|bottom&quot;</code>使得他在帧布局中位于右下角. 效果如图：</p>\n<p><img src=\"images/ex-layout-gravity.png\" alt=\"ex-layout-gravity\"></p>\n<p>要注意的是, layout_gravity的属性不一定总是生效的, 具体取决于布局的类别. 例如不能让水平布局中的第一个子控件靠底部显示(否则和水平布局本身相违背).</p>\n",
          "type": "module",
          "displayName": "layout_gravity"
        },
        {
          "textRaw": "margin",
          "name": "margin",
          "desc": "<p>margin为View和其他View的间距, 即外边距. margin属性包括四个值:</p>\n<ul>\n<li><code>marginLeft</code> 左外边距</li>\n<li><code>marginRight</code> 右外边距</li>\n<li><code>marginTop</code> 上外边距</li>\n<li><code>marginBottom</code> 下外边距</li>\n</ul>\n<p>而margin属性本身的值可以有三种格式:</p>\n<ul>\n<li><code>margin=&quot;marginAll&quot;</code> 指定各个外边距都是该值. 例如<code>margin=&quot;10&quot;</code>表示左右上下边距都是10dp.</li>\n<li><code>margin=&quot;marginLeft marginTop marginRight marginBottom&quot;</code> 分别指定各个外边距. 例如<code>margin=&quot;10 20 30 40&quot;</code>表示左边距为10dp, 上边距为20dp, 右边距为30dp, 下边距为40dp</li>\n<li><code>margin=&quot;marginHorizontal marginVertical&quot;</code> 指定水平外边距和垂直外边距. 例如<code>margin=&quot;10 20&quot;</code>表示左右边距为10dp, 上下边距为20dp.</li>\n</ul>\n<p>用一个例子来具体理解外边距的含义：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;horizontal&gt;\n        &lt;button margin=&quot;30&quot; text=&quot;距离四周30&quot;/&gt;\n        &lt;button text=&quot;普通的按钮&quot;/&gt;\n    &lt;/horizontal&gt;\n);\n</code></pre><p>第一个按钮的margin属性指定了他的边距为30dp, 也就是他与水平布局以及第二个按钮的间距都是30dp, 其显示效果如图:</p>\n<p><img src=\"images/ex1-margin.png\" alt=\"ex1-margin\"></p>\n<p>如果把<code>margin=&quot;30&quot;</code>改成<code>margin=&quot;10 40&quot;</code>那么第一个按钮的左右间距为10dp, 上下间距为40dp, 效果如图:</p>\n<p><img src=\"images/ex2-margin.png\" alt=\"ex2-margin\"></p>\n<p>有关margin属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "margin"
        },
        {
          "textRaw": "marginLeft",
          "name": "marginleft",
          "desc": "<p>View的左外边距. 如果该属性和margin属性指定的值冲突, 则在后面的属性生效, 前面的属性无效, 例如<code>margin=&quot;20&quot; marginLeft=&quot;10&quot;</code>的左外边距为10dp, 其他外边距为20dp.</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;horizontal&gt;\n        &lt;button marginLeft=&quot;50&quot; text=&quot;距离左边50&quot;/&gt;\n        &lt;button text=&quot;普通的按钮&quot;/&gt;\n    &lt;/horizontal&gt;\n);\n</code></pre><p>第一个按钮指定了左外边距为50dp, 则他和他的父布局水平布局(horizontal)的左边的间距为50dp, 效果如图：</p>\n<p><img src=\"images/ex-marginLeft.png\" alt=\"ex-marginLeft\"></p>\n",
          "type": "module",
          "displayName": "marginLeft"
        },
        {
          "textRaw": "marginRight",
          "name": "marginright",
          "desc": "<p>View的右外边距. 如果该属性和margin属性指定的值冲突, 则在后面的属性生效, 前面的属性无效.</p>\n",
          "type": "module",
          "displayName": "marginRight"
        },
        {
          "textRaw": "marginTop",
          "name": "margintop",
          "desc": "<p>View的上外边距. 如果该属性和margin属性指定的值冲突, 则在后面的属性生效, 前面的属性无效.</p>\n",
          "type": "module",
          "displayName": "marginTop"
        },
        {
          "textRaw": "marginBottom",
          "name": "marginbottom",
          "desc": "<p>View的下外边距. 如果该属性和margin属性指定的值冲突, 则在后面的属性生效, 前面的属性无效.</p>\n",
          "type": "module",
          "displayName": "marginBottom"
        },
        {
          "textRaw": "padding",
          "name": "padding",
          "desc": "<p>View和他的自身内容的间距, 也就是内边距. 注意和margin属性区分开来, margin属性是View之间的间距, 而padding是View和他自身内容的间距. 举个例子, 一个文本控件的padding也即文本控件的边缘和他的文本内容的间距, paddingLeft即文本控件的左边和他的文本内容的间距.</p>\n<p>paddding属性的值同样有三种格式：</p>\n<ul>\n<li><code>padding=&quot;paddingAll&quot;</code> 指定各个内边距都是该值. 例如<code>padding=&quot;10&quot;</code>表示左右上下内边距都是10dp.</li>\n<li><code>padding=&quot;paddingLeft paddingTop paddingRight paddingBottom&quot;</code> 分别指定各个内边距. 例如<code>padding=&quot;10 20 30 40&quot;</code>表示左内边距为10dp, 上内边距为20dp, 右内边距为30dp, 下内边距为40dp</li>\n<li><code>padding=&quot;paddingHorizontal paddingVertical&quot;</code> 指定水平内边距和垂直内边距. 例如<code>padding=&quot;10 20&quot;</code>表示左右内边距为10dp, 上下内边距为20dp.</li>\n</ul>\n<p>用一个例子来具体理解内边距的含义：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;frame w=&quot;*&quot; h=&quot;*&quot; gravity=&quot;center&quot;&gt;\n        &lt;text padding=&quot;10 20 30 40&quot; bg=&quot;#ff0000&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;HelloWorld&quot;/&gt;\n    &lt;/frame&gt;\n);\n</code></pre><p>这个例子是一个居中的按钮(通过父布局的<code>gravity=&quot;center&quot;</code>属性设置), 背景色为红色(<code>bg=&quot;#ff0000&quot;</code>), 文本内容为&quot;HelloWorld&quot;, 左边距为10dp, 上边距为20dp, 下边距为30dp, 右边距为40dp, 其显示效果如图：</p>\n<p><img src=\"images/ex-padding.png\" alt=\"ex-padding\"></p>\n",
          "type": "module",
          "displayName": "padding"
        },
        {
          "textRaw": "paddingLeft",
          "name": "paddingleft",
          "desc": "<p>View的左内边距. 如果该属性和padding属性指定的值冲突, 则在后面的属性生效, 前面的属性无效.</p>\n",
          "type": "module",
          "displayName": "paddingLeft"
        },
        {
          "textRaw": "paddingRight",
          "name": "paddingright",
          "desc": "<p>View的右内边距. 如果该属性和padding属性指定的值冲突, 则在后面的属性生效, 前面的属性无效.</p>\n",
          "type": "module",
          "displayName": "paddingRight"
        },
        {
          "textRaw": "paddingTop",
          "name": "paddingtop",
          "desc": "<p>View的上内边距. 如果该属性和padding属性指定的值冲突, 则在后面的属性生效, 前面的属性无效.</p>\n",
          "type": "module",
          "displayName": "paddingTop"
        },
        {
          "textRaw": "paddingBottom",
          "name": "paddingbottom",
          "desc": "<p>View的下内边距. 如果该属性和padding属性指定的值冲突, 则在后面的属性生效, 前面的属性无效.</p>\n",
          "type": "module",
          "displayName": "paddingBottom"
        },
        {
          "textRaw": "bg",
          "name": "bg",
          "desc": "<p>View的背景. 其值可以是一个链接或路径指向的图片, 或者RGB格式的颜色, 或者其他背景. 具体参见<a href=\"#draw\">Drawables</a>.</p>\n<p>例如, <code>bg=&quot;#00ff00&quot;</code>设置背景为绿色, <code>bg=&quot;file:///sdcard/1.png&quot;</code>设置背景为图片&quot;1.png&quot;, <code>bg=&quot;?attr/selectableItemBackground&quot;</code>设置背景为点击时出现的波纹效果(可能需要同时设置<code>clickable=&quot;true&quot;</code>才生效).</p>\n",
          "type": "module",
          "displayName": "bg"
        },
        {
          "textRaw": "alpha",
          "name": "alpha",
          "desc": "<p>View的透明度, 其值是一个0~1之间的小数, 0表示完全透明, 1表示完全不透明. 例如<code>alpha=&quot;0.5&quot;</code>表示半透明.</p>\n",
          "type": "module",
          "displayName": "alpha"
        },
        {
          "textRaw": "foreground",
          "name": "foreground",
          "desc": "<p>View的前景. 前景即在一个View的内容上显示的内容, 可能会覆盖掉View本身的内容. 其值和属性bg的值类似.</p>\n",
          "type": "module",
          "displayName": "foreground"
        },
        {
          "textRaw": "minHeight",
          "name": "minheight",
          "desc": "<p>View的最小高度. 该值不总是生效的, 取决于其父布局是否有足够的空间容纳.</p>\n<p>例：<code>&lt;text height=&quot;auto&quot; minHeight=&quot;50&quot;/&gt;</code></p>\n<p>有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "minHeight"
        },
        {
          "textRaw": "minWidth",
          "name": "minwidth",
          "desc": "<p>View的最小宽度. 该值不总是生效的, 取决于其父布局是否有足够的空间容纳.</p>\n<p>例：<code>&lt;input width=&quot;auto&quot; minWidth=&quot;50&quot;/&gt;</code></p>\n<p>有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "minWidth"
        },
        {
          "textRaw": "visibility",
          "name": "visibility",
          "desc": "<p>View的可见性, 该属性可以决定View是否显示出来. 其值可以为：</p>\n<ul>\n<li><code>gone</code> 不可见.</li>\n<li><code>visible</code> 可见. 默认情况下View都是可见的.</li>\n<li><code>invisible</code> 不可见, 但仍然占用位置.</li>\n</ul>\n",
          "type": "module",
          "displayName": "visibility"
        },
        {
          "textRaw": "rotation",
          "name": "rotation",
          "desc": "<p>View的旋转角度. 通过该属性可以让这个View顺时针旋转一定的角度. 例如<code>rotation=&quot;90&quot;</code>可以让他顺时针旋转90度.</p>\n<p>如果要设置旋转中心, 可以通过<code>transformPivotX</code>, <code>transformPivotY</code>属性设置. 默认的旋转中心为View的中心.</p>\n",
          "type": "module",
          "displayName": "rotation"
        },
        {
          "textRaw": "transformPivotX",
          "name": "transformpivotx",
          "desc": "<p>View的变换中心坐标x. 用于View的旋转、放缩等变换的中心坐标. 例如<code>transformPivotX=&quot;10&quot;</code>.</p>\n<p>该坐标的坐标系以View的左上角为原点. 也就是x值为变换中心到View的左边的距离.</p>\n<p>有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "transformPivotX"
        },
        {
          "textRaw": "transformPivotY",
          "name": "transformpivoty",
          "desc": "<p>View的变换中心坐标y. 用于View的旋转、放缩等变换的中心坐标. 例如<code>transformPivotY=&quot;10&quot;</code>.</p>\n<p>该坐标的坐标系以View的左上角为原点. 也就是y值为变换中心到View的上边的距离.</p>\n<p>有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "transformPivotY"
        },
        {
          "textRaw": "style",
          "name": "style",
          "desc": "<p>设置View的样式. 不同控件有不同的可选的内置样式. 具体参见各个控件的说明.</p>\n<p>需要注意的是, style属性只支持安卓5.1及其以上.</p>\n",
          "type": "module",
          "displayName": "style"
        }
      ],
      "type": "module",
      "displayName": "视图: View"
    },
    {
      "textRaw": "文本控件: text",
      "name": "文本控件:_text",
      "desc": "<p>文本控件用于显示文本, 可以控制文本的字体大小, 字体颜色, 字体等.</p>\n<p>以下介绍该控件的主要属性和方法, 如果要查看他的所有属性和方法, 请阅读<a href=\"http://www.zhdoc.net/android/reference/android/widget/TextView.html\">TextView</a>.</p>\n",
      "modules": [
        {
          "textRaw": "text",
          "name": "text",
          "desc": "<p>设置文本的内容. 例如<code>text=&quot;一段文本&quot;</code>.</p>\n",
          "type": "module",
          "displayName": "text"
        },
        {
          "textRaw": "textColor",
          "name": "textcolor",
          "desc": "<p>设置字体的颜色, 可以是RGB格式的颜色(例如#ff00ff), 或者颜色名称(例如red, green等), 具体参见<a href=\"#ui_颜色\">颜色</a>.</p>\n<p>示例, 红色字体：<code>&lt;text text=&quot;红色字体&quot; textColor=&quot;red&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "textColor"
        },
        {
          "textRaw": "textSize",
          "name": "textsize",
          "desc": "<p>设置字体的大小, 单位一般是sp. 按照Material Design的规范, 正文字体大小为14sp, 标题字体大小为18sp, 次标题为16sp.</p>\n<p>示例, 超大字体: <code>&lt;text text=&quot;超大字体&quot; textSize=&quot;40sp&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "textSize"
        },
        {
          "textRaw": "textStyle",
          "name": "textstyle",
          "desc": "<p>设置字体的样式, 比如斜体、粗体等. 可选的值为：</p>\n<ul>\n<li>bold 加粗字体</li>\n<li>italic 斜体</li>\n<li>normal 正常字体</li>\n</ul>\n<p>可以用或(&quot;|&quot;)把他们组合起来, 比如粗斜体为&quot;bold|italic&quot;.</p>\n<p>例如, 粗体：`<text textStyle=\"bold\" textSize=\"18sp\" text=\"这是粗体\"/></p>\n",
          "type": "module",
          "displayName": "textStyle"
        },
        {
          "textRaw": "lines",
          "name": "lines",
          "desc": "<p>设置文本控件的行数. 即使文本内容没有达到设置的行数, 控件也会留出相应的宽度来显示空白行；如果文本内容超出了设置的行数, 则超出的部分不会显示.</p>\n<p>另外在xml中是不能设置多行文本的, 要在代码中设置. 例如:</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical&gt;\n        &lt;text id=&quot;myText&quot; line=&quot;3&quot;&gt;\n    &lt;/vertical&gt;\n)\n//通过\\n换行\nui.myText.setText(&quot;第一行\\n第二行\\n第三行\\n第四行&quot;);\n</code></pre>",
          "type": "module",
          "displayName": "lines"
        },
        {
          "textRaw": "maxLines",
          "name": "maxlines",
          "desc": "<p>设置文本控件的最大行数.</p>\n",
          "type": "module",
          "displayName": "maxLines"
        },
        {
          "textRaw": "typeface",
          "name": "typeface",
          "desc": "<p>设置字体. 可选的值为：</p>\n<ul>\n<li><code>normal</code> 正常字体</li>\n<li><code>sans</code> 衬线字体</li>\n<li><code>serif</code> 非衬线字体</li>\n<li><code>monospace</code> 等宽字体</li>\n</ul>\n<p>示例, 等宽字体: <code>&lt;text text=&quot;等宽字体&quot; typeface=&quot;monospace&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "typeface"
        },
        {
          "textRaw": "ellipsize",
          "name": "ellipsize",
          "desc": "<p>设置文本的省略号位置. 文本的省略号会在文本内容超出文本控件时显示. 可选的值为：</p>\n<ul>\n<li><code>end</code>   在文本末尾显示省略号</li>\n<li><code>marquee</code>   跑马灯效果, 文本将滚动显示</li>\n<li><code>middle</code>    在文本中间显示省略号</li>\n<li><code>none</code>    不显示省略号</li>\n<li><code>start</code>    在文本开头显示省略号</li>\n</ul>\n",
          "type": "module",
          "displayName": "ellipsize"
        },
        {
          "textRaw": "ems",
          "name": "ems",
          "desc": "<p>当设置该属性后,TextView显示的字符长度（单位是em）,超出的部分将不显示, 或者根据ellipsize属性的设置显示省略号.</p>\n<p>例如, 限制文本最长为5em: `<text ems=\"5\" ellipsize=\"end\" text=\"很长很长很长很长很长很长很长的文本\"/></p>\n",
          "type": "module",
          "displayName": "ems"
        },
        {
          "textRaw": "autoLink",
          "name": "autolink",
          "desc": "<p>控制是否自动找到url和电子邮件地址等链接, 并转换为可点击的链接. 默认值为“none”.</p>\n<p>设置该值可以让文本中的链接、电话等变成可点击状态.</p>\n<p>可选的值为以下的值以其通过或(&quot;|&quot;)的组合：</p>\n<ul>\n<li><code>all</code>    匹配所有连接、邮件、地址、电话</li>\n<li><code>email</code>    匹配电子邮件地址</li>\n<li><code>map</code>    匹配地图地址</li>\n<li><code>none</code>    不匹配 (默认)</li>\n<li><code>phone</code>    匹配电话号码</li>\n<li><code>web</code>    匹配URL地址</li>\n</ul>\n<p>示例：<code>&lt;text autoLink=&quot;web|phone&quot; text=&quot;百度: http://www.baidu.com 电信电话: 10000&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "autoLink"
        }
      ],
      "type": "module",
      "displayName": "文本控件: text"
    },
    {
      "textRaw": "按钮控件: button",
      "name": "按钮控件:_button",
      "desc": "<p>按钮控件是一个特殊的文本控件, 因此所有文本控件的函数的属性都适用于按钮控件.</p>\n<p>除此之外, 按钮控件有一些内置的样式, 通过<code>style</code>属性设置, 包括：</p>\n<ul>\n<li>Widget.AppCompat.Button.Colored 带颜色的按钮</li>\n<li>Widget.AppCompat.Button.Borderless 无边框按钮</li>\n<li>Widget.AppCompat.Button.Borderless.Colored 带颜色的无边框按钮</li>\n</ul>\n<p>这些样式的具体效果参见&quot;示例/界面控件/按钮控件.js&quot;.</p>\n<p>例如：<code>&lt;button style=&quot;Widget.AppCompat.Button.Colored&quot; text=&quot;漂亮的按钮&quot;/&gt;</code></p>\n",
      "type": "module",
      "displayName": "按钮控件: button"
    },
    {
      "textRaw": "输入框控件: input",
      "name": "输入框控件:_input",
      "desc": "<p>输入框控件也是一个特殊的文本控件, 因此所有文本控件的函数的属性和函数都适用于按钮控件. 输入框控件有自己的属性和函数, 要查看所有这些内容, 阅读<a href=\"http://www.zhdoc.net/android/reference/android/widget/EditText.html\">EditText</a>.</p>\n<p>对于一个输入框控件, 我们可以通过text属性设置他的内容, 通过lines属性指定输入框的行数；在代码中通过<code>getText()</code>函数获取输入的内容. 例如：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical padding=&quot;16&quot;&gt;\n        &lt;text textSize=&quot;16sp&quot; textColor=&quot;black&quot; text=&quot;请输入姓名&quot;/&gt;\n        &lt;input id=&quot;name&quot; text=&quot;小明&quot;/&gt;\n        &lt;button id=&quot;ok&quot; text=&quot;确定&quot;/&gt;\n    &lt;/vertical&gt;\n);\n//指定确定按钮点击时要执行的动作\nui.ok.click(function(){\n    //通过getText()获取输入的内容\n    var name = ui.name.getText();\n    toast(name + &quot;您好!&quot;);\n});\n</code></pre><p>效果如图：</p>\n<p><img src=\"ex-input.png\" alt=\"ex-input\"></p>\n<p>除此之外, 输入框控件有另外一些主要属性(虽然这些属性对于文本控件也是可用的但一般只用于输入框控件)：</p>\n",
      "modules": [
        {
          "textRaw": "hint",
          "name": "hint",
          "desc": "<p>输入提示. 这个提示会在输入框为空的时候显示出来. 如图所示:</p>\n<p><img src=\"images/ex-hint.png\" alt=\"ex-hint\"></p>\n<p>上面图片效果的代码为：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical&gt;\n        &lt;input hint=&quot;请输入姓名&quot;/&gt;\n    &lt;/vertical&gt;\n)\n</code></pre>",
          "type": "module",
          "displayName": "hint"
        },
        {
          "textRaw": "textColorHint",
          "name": "textcolorhint",
          "desc": "<p>指定输入提示的字体颜色.</p>\n",
          "type": "module",
          "displayName": "textColorHint"
        },
        {
          "textRaw": "textSizeHint",
          "name": "textsizehint",
          "desc": "<p>指定输入提示的字体大小.</p>\n",
          "type": "module",
          "displayName": "textSizeHint"
        },
        {
          "textRaw": "inputType",
          "name": "inputtype",
          "desc": "<p>指定输入框可以输入的文本类型. 可选的值为以下值及其用&quot;|&quot;的组合:</p>\n<ul>\n<li><code>date</code>    用于输入日期.</li>\n<li><code>datetime</code>    用于输入日期和时间.</li>\n<li><code>none</code>    没有内容类型. 此输入框不可编辑.</li>\n<li><code>number</code>    仅可输入数字.</li>\n<li><code>numberDecimal</code>    可以与number和它的其他选项组合, 以允许输入十进制数(包括小数).</li>\n<li><code>numberPassword</code>    仅可输入数字密码.</li>\n<li><code>numberSigned</code>    可以与number和它的其他选项组合, 以允许输入有符号的数.</li>\n<li><code>phone</code>    用于输入一个电话号码.</li>\n<li><code>text</code>    只是普通文本.</li>\n<li><code>textAutoComplete</code>    可以与text和它的其他选项结合, 以指定此字段将做自己的自动完成, 并适当地与输入法交互.</li>\n<li><code>textAutoCorrect</code>    可以与text和它的其他选项结合, 以请求自动文本输入纠错.</li>\n<li><code>textCapCharacters</code>    可以与text和它的其他选项结合, 以请求大写所有字符.</li>\n<li><code>textCapSentences</code>    可以与text和它的其他选项结合, 以请求大写每个句子里面的第一个字符.</li>\n<li><code>textCapWords</code>    可以与text和它的其他选项结合, 以请求大写每个单词里面的第一个字符.</li>\n<li><code>textEmailAddress</code>    用于输入一个电子邮件地址.</li>\n<li><code>textEmailSubject</code>    用于输入电子邮件的主题.</li>\n<li><code>textImeMultiLine</code>    可以与text和它的其他选项结合, 以指示虽然常规文本视图不应为多行, 但如果可以, 则IME应提供多行支持.</li>\n<li><code>textLongMessage</code>    用于输入长消息的内容.</li>\n<li><code>textMultiLine</code>    可以与text和它的其他选项结合, 以便在该字段中允许多行文本. 如果未设置此标志, 则文本字段将被限制为单行.</li>\n<li><code>textNoSuggestions</code>    可以与text及它的其他选项结合, 以指示输入法不应显示任何基于字典的单词建议.</li>\n<li><code>textPassword</code>    用于输入密码.</li>\n<li><code>textPersonName</code>    用于输入人名.</li>\n<li><code>textPhonetic</code>    用于输入拼音发音的文本, 如联系人条目中的拼音名称字段.</li>\n<li><code>textPostalAddress</code>    用于输入邮寄地址.</li>\n<li><code>textShortMessage</code>    用于输入短的消息内容.</li>\n<li><code>textUri</code>    用于输入一个URI.</li>\n<li><code>textVisiblePassword</code>    用于输入可见的密码.</li>\n<li><code>textWebEditText</code>    用于输入在web表单中的文本.</li>\n<li><code>textWebEmailAddress</code>    用于在web表单里输入一个电子邮件地址.</li>\n<li><code>textWebPassword</code>    用于在web表单里输入一个密码.</li>\n<li><code>time</code>    用于输入时间.</li>\n</ul>\n<p>例如, 想指定一个输入框的输入类型为小数数字, 为: <code>&lt;input inputType=&quot;number|numberDecimal&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "inputType"
        },
        {
          "textRaw": "password",
          "name": "password",
          "desc": "<p>指定输入框输入框是否为密码输入框. 默认为<code>false</code>.</p>\n<p>例如：<code>&lt;input password=&quot;true&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "password"
        },
        {
          "textRaw": "numeric",
          "name": "numeric",
          "desc": "<p>指定输入框输入框是否为数字输入框. 默认为<code>false</code>.</p>\n<p>例如：<code>&lt;input numeric=&quot;true&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "numeric"
        },
        {
          "textRaw": "phoneNumber",
          "name": "phonenumber",
          "desc": "<p>指定输入框输入框是否为电话号码输入框. 默认为<code>false</code>.</p>\n<p>例如：<code>&lt;input phoneNumber=&quot;true&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "phoneNumber"
        },
        {
          "textRaw": "digits",
          "name": "digits",
          "desc": "<p>指定输入框可以输入的字符. 例如, 要指定输入框只能输入&quot;1234567890+-&quot;, 为<code>&lt;input digits=&quot;1234567890+-&quot;/&gt;</code>.</p>\n",
          "type": "module",
          "displayName": "digits"
        },
        {
          "textRaw": "singleLine",
          "name": "singleline",
          "desc": "<p>指定输入框是否为单行输入框. 默认为<code>false</code>. 您也可以通过<code>lines=&quot;1&quot;</code>来指定单行输入框.</p>\n<p>例如：<code>&lt;input singleLine=&quot;true&quot;/&gt;</code></p>\n",
          "type": "module",
          "displayName": "singleLine"
        }
      ],
      "type": "module",
      "displayName": "输入框控件: input"
    },
    {
      "textRaw": "图片控件: img",
      "name": "图片控件:_img",
      "desc": "<p>图片控件用于显示来自网络、本地或者内嵌数据的图片, 并可以指定图片以圆角矩形、圆形等显示. 但是不能用于显示gif动态图.</p>\n<p>这里只介绍他的主要方法和属性, 如果要查看他的所有方法和属性, 阅读<a href=\"http://www.zhdoc.net/android/reference/android/widget/ImageView.html\">ImageView</a>.</p>\n",
      "modules": [
        {
          "textRaw": "src",
          "name": "src",
          "desc": "<p>使用一个Uri指定图片的来源. 可以是图片的地址(http://....), 本地路径(file://....)或者base64数据(&quot;data:image/png;base64,...&quot;).</p>\n<p>如果使用图片地址或本地路径, Auto.js会自动使用适当的缓存来储存这些图片, 减少下次加载的时间.</p>\n<p>例如, 显示百度的logo:</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;frame&gt;\n        &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;\n    &lt;/frame&gt;\n);\n</code></pre><p>再例如, 显示文件/sdcard/1.png的图片为 <code>&lt;img src=&quot;file:///sdcard/1.png&quot;/&gt;</code>.\n再例如, 使base64显示一张钱包小图片为：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;frame&gt;\n        &lt;img w=&quot;40&quot; h=&quot;40&quot; src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAEu0lEQVRoge3bW4iVVRQH8N+ZnDKxvJUGCSWUlXYle/ChiKAkIiu7UXQjonwNIopM8cHoAhkRGQXdfIiE0Ep8KalQoptRTiFFZiRlOo6TPuSk4zk97G9w5vidc77LPjNi84f1MN+391rrf9a+rL32N4xiFMcUjouo5zyciYPYH0FnBadiNiZiD2oR9JbGRdgiOFPDIXRhCWYU0Dcj6duV6BrQuyWxNaLowBcOO1Uv+7EKc4WINUIlabMq6dNI35eJzRHDWOzS2MEB6cd6XI/OQf07k2frkzat9HQnNkcUG7R2dECq2I53EtmePMvaf+MwcWqKu+RzuqhUcfcwcWqKTvmiXFQ2GDodRhQz0aN9ZHsSG0cVrkGf+GT7MG8YeeTCHeKS7sOdMR1stjcWxY2YH0nXh1gdSdf/E+2I8KVYigkl9ewVUsxNpT1qMzaKN4ejJxrtyEt7IuraE1EX2jOkp+JBnFxSzz68KuTqoyiK2BHuxDO4NpK+j/GoOAWF6BiH98Q/SHyCycPIIxMm4FPZCPTj30SynIFr+A7ThotMK4wXopA1Ym9gSiKv5Oj3bdKnFMpuS514E1fm6NMnbF098s3NS4QS0Ik5+hyBsoSXYkGO9jvxy6C/t+IPIYJZcBWW57AXFfMNrSo2kqqw2l4hvSzcIRTw1sm24FVxb5s4NcR0/JXBuUNYJttI6sDjsi1kvTgrGpsMjq3O4FQNa+SbNhWsyKj7I4wpzSYDbpFtKB/EOSn9ZwpRfx5Xp7yfhN0Z9FdxXxxKjTEe2zI4U8NnKf3PNrT2VcWTKe1eyGjjT+Eapm14IqMjNTyd0n9JSrsDwhmaEN2H8GMOO8viUjyMSfJVJh9O0bGoQdt1eFm2oVwve7UpC1ssX568KEXH6fghp54s8lRkrk7CjpxOrGqg6wQ8IKSKWXPpVtIt8ly+v4ATf2t+yqlgDl5SbCjXy8JIXFXweQEHqngxo43JeEw54l+JVLKaJeypRZzoFxavrIWG6cKPW2SO9+PCMkQHsLiA8fpIv5/DmUn4qaCtpWWIEiLzdUHj9XJA2H5uFRbBZriuoI1NSpatpio+nJtFvFvYd2c1sDsGvxfQ3a/knrwgMtm0qD8rPSprCuq8uRmhVqvanBbvm+EQfsNKIcnvTmnTiUdwQcq73oJ2L2v2stXx6vyCRr8RDuk/C8OMUK24J6VtBaekPG81zxuh0TTJhC7FhtUOHF+n61whGalvu8uRWVJFvgPEYOkqQzhLVSPPXLoYa4Xh3Stcls1NaTdb8Xx7ZxnCvSUIfy/kzWno0Pyzx3dL2C0695Hto7NGUhXy5Lzp3kLZKiqNpNTl2+YShgdIvyXbVck44TB/oKTNzWUIv13S+IDsFmpY84QvZAcwTbh4e04o18SwtbIM4dsiOTFYVgzSv7wN+m9vRqjV/PrA0JuCox1bhYNKQ7Qi3CcU1fpiedRG9AkLXhRfbxCnKlET0s21ifwaSWcPbopBdDDOwGtClTD2vCsq+/C68K8HmVDk7DhFyIsvFzKnGThN+689+oU9dptwQb5B+LB8dx4lMb7xqAhkJwo/xljhFFSfSdUc3mPrcbwj15P+pP0/QiR7hYSkGsHnUYziWMF/mXV4JVcZ8G0AAAAASUVORK5CYII=&quot;/&gt;\n    &lt;/frame&gt;\n);\n</code></pre>",
          "type": "module",
          "displayName": "src"
        },
        {
          "textRaw": "tint",
          "name": "tint",
          "desc": "<p>图片着色, 其值是一个颜色名称或RGB颜色值. 使用该属性会将图片中的非透明区域都涂上同一颜色. 可以用于改变图片的颜色.</p>\n<p>例如, 对于上面的base64的图片: <code>&lt;img w=&quot;40&quot; h=&quot;40&quot; tint=&quot;red&quot; src=&quot;data:image/png;base64,...&quot;/&gt;</code>, 则钱包图标颜色会变成红色.</p>\n",
          "type": "module",
          "displayName": "tint"
        },
        {
          "textRaw": "scaleType",
          "name": "scaletype",
          "desc": "<p>控制图片根据图片控件的宽高放缩时的模式. 可选的值为：</p>\n<ul>\n<li><code>center</code>    在控件中居中显示图像, 但不执行缩放.</li>\n<li><code>centerCrop</code>    保持图像的长宽比缩放图片, 使图像的尺寸 (宽度和高度) 等于或大于控件的相应尺寸 (不包括内边距padding)并且使图像在控件中居中显示.</li>\n<li><code>centerInside</code>    保持图像的长宽比缩放图片, 使图像的尺寸 (宽度和高度) 小于视图的相应尺寸 (不包括内边距padding)并且图像在控件中居中显示.</li>\n<li><code>fitCenter</code>    保持图像的长宽比缩放图片, 使图片的宽<strong>或</strong>高和控件的宽高相同并使图片在控件中居中显示</li>\n<li><code>fitEnd</code>    保持图像的长宽比缩放图片, 使图片的宽<strong>或</strong>高和控件的宽高相同并使图片在控件中靠右下角显示</li>\n<li><code>fitStart</code>    保持图像的长宽比缩放图片, 使图片的宽<strong>或</strong>高和控件的宽高相同并使图片在控件靠左上角显示</li>\n<li><code>fitXY</code>    使图片和宽高和控件的宽高完全匹配, 但图片的长宽比可能不能保持一致</li>\n<li><code>matrix</code>    绘制时使用图像矩阵进行缩放. 需要在代码中使用<code>setImageMatrix(Matrix)</code>函数才能生效.</li>\n</ul>\n<p>默认的scaleType为<code>fitCenter</code>；除此之外最常用的是<code>fitXY</code>,  他能使图片放缩到控件一样的大小, 但图片可能会变形.</p>\n",
          "type": "module",
          "displayName": "scaleType"
        },
        {
          "textRaw": "radius",
          "name": "radius",
          "desc": "<p>图片控件的半径. 如果设置为控件宽高的一半并且控件的宽高相同则图片将剪切为圆形显示；否则图片为圆角矩形显示, 半径即为四个圆角的半径, 也可以通过<code>radiusTopLeft</code>, <code>radiusTopRight</code>, <code>radiusBottomLeft</code>, <code>radiusBottomRight</code>等属性分别设置四个圆角的半径.</p>\n<p>例如, 圆角矩形的Auto.js图标：<code>&lt;img w=&quot;100&quot; h=&quot;100&quot; radius=&quot;20&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;</code></p>\n<p>有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "radius"
        },
        {
          "textRaw": "radiusTopLeft",
          "name": "radiustopleft",
          "desc": "<p>图片控件的左上角圆角的半径. 有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "radiusTopLeft"
        },
        {
          "textRaw": "radiusTopRight",
          "name": "radiustopright",
          "desc": "<p>图片控件的右上角圆角的半径. 有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "radiusTopRight"
        },
        {
          "textRaw": "radiusBottomLeft",
          "name": "radiusbottomleft",
          "desc": "<p>图片控件的左下角圆角的半径. 有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "radiusBottomLeft"
        },
        {
          "textRaw": "radiusBottomRight",
          "name": "radiusbottomright",
          "desc": "<p>图片控件的右下角圆角的半径. 有关该属性的单位, 参见<a href=\"#ui_尺寸的单位_Dimension\">尺寸的单位: Dimension</a>.</p>\n",
          "type": "module",
          "displayName": "radiusBottomRight"
        },
        {
          "textRaw": "borderWidth",
          "name": "borderwidth",
          "desc": "<p>图片控件的边框宽度. 用于在图片外面显示一个边框, 边框会随着图片控件的外形(圆角等)改变而相应变化.\n例如, 圆角矩形带灰色边框的Auto.js图标：<code>&lt;img w=&quot;100&quot; h=&quot;100&quot; radius=&quot;20&quot; borderWidth=&quot;5&quot; borderColor=&quot;gray&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;</code></p>\n",
          "type": "module",
          "displayName": "borderWidth"
        },
        {
          "textRaw": "borderColor",
          "name": "bordercolor",
          "desc": "<p>图片控件的边框颜色.</p>\n",
          "type": "module",
          "displayName": "borderColor"
        },
        {
          "textRaw": "circle",
          "name": "circle",
          "desc": "<p>指定该图片控件的图片是否剪切为圆形显示. 如果为<code>true</code>, 则图片控件会使其宽高保持一致(如果宽高不一致, 则保持高度等于宽度)并使圆形的半径为宽度的一半.</p>\n<p>例如, 圆形的Auto.js图标：<code>&lt;img w=&quot;100&quot; h=&quot;100&quot; circle=&quot;true&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;</code></p>\n",
          "type": "module",
          "displayName": "circle"
        }
      ],
      "type": "module",
      "displayName": "图片控件: img"
    },
    {
      "textRaw": "垂直布局: vertical",
      "name": "垂直布局:_vertical",
      "desc": "<p>垂直布局是一种比较简单的布局, 会把在它里面的控件按照垂直方向依次摆放, 如下图所示：</p>\n<p>垂直布局:</p>\n<p>—————</p>\n<p>| 控件1 |</p>\n<p>| 控件2 |</p>\n<p>| 控件3 |</p>\n<p>| ............ |</p>\n<p>——————</p>\n",
      "modules": [
        {
          "textRaw": "layout_weight",
          "name": "layout_weight",
          "desc": "<p>垂直布局中的控件可以通过<code>layout_weight</code>属性来控制控件高度占垂直布局高度的比例. 如果为一个控件指定<code>layout_weight</code>, 则这个控件的高度=垂直布局剩余高度 * layout_weight / weightSum；如果不指定weightSum, 则weightSum为所有子控件的layout_weight之和. 所谓&quot;剩余高度&quot;, 指的是垂直布局中减去没有指定layout_weight的控件的剩余高度.\n例如:</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical h=&quot;100dp&quot;&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;\n    &lt;/vertical&gt;\n);\n</code></pre><p>在这个布局中, 三个控件的layout_weight都是1, 也就是他们的高度都会占垂直布局高度的1/3, 都是33.3dp.\n再例如：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical h=&quot;100dp&quot;&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;\n        &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;\n    &lt;/vertical&gt;\n);\n</code></pre><p>在这个布局中, 第一个控件高度为1/4, 第二个控件为2/4, 第三个控件为1/4.\n再例如：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical h=&quot;100dp&quot; weightSum=&quot;5&quot;&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;\n        &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;\n    &lt;/vertical&gt;\n);\n</code></pre><p>在这个布局中, 因为指定了weightSum为5, 因此第一个控件高度为1/5, 第二个控件为2/5, 第三个控件为1/5.\n再例如：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical h=&quot;100dp&quot;&gt;\n        &lt;text h=&quot;40dp&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;\n        &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;\n    &lt;/vertical&gt;\n);\n</code></pre><p>在这个布局中, 第一个控件并没有指定layout_weight, 而是指定高度为40dp, 因此不加入比例计算, 此时布局剩余高度为60dp. 第二个控件高度为剩余高度的2/3, 也就是40dp, 第三个控件高度为剩余高度的1/3, 也就是20dp.</p>\n<p>垂直布局的layout_weight属性还可以用于控制他的子控件高度占满剩余空间, 例如：</p>\n<pre><code>&quot;ui&quot;;\nui.layout(\n    &lt;vertical h=&quot;100dp&quot;&gt;\n        &lt;text h=&quot;40dp&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;\n        &lt;text h=&quot;40dp&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;\n        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;\n    &lt;/vertical&gt;\n);\n</code></pre><p>在这个布局中, 第三个控件的高度会占满除去控件1和控件2的剩余空间.</p>\n",
          "type": "module",
          "displayName": "layout_weight"
        }
      ],
      "type": "module",
      "displayName": "垂直布局: vertical"
    },
    {
      "textRaw": "水平布局: horizontal",
      "name": "水平布局:_horizontal",
      "desc": "<p>水平布局是一种比较简单的布局, 会把在它里面的控件按照水平方向依次摆放, 如下图所示：\n水平布局:\n————————————————————————————</p>\n<p>| 控件1 | 控件2 | 控件3 | ... |</p>\n<p>————————————————————————————</p>\n",
      "modules": [
        {
          "textRaw": "layout_weight",
          "name": "layout_weight",
          "desc": "<p>水平布局中也可以使用layout_weight属性来控制子控件的<strong>宽度</strong>占父布局的比例. 和垂直布局中类似, 不再赘述.</p>\n",
          "type": "module",
          "displayName": "layout_weight"
        }
      ],
      "type": "module",
      "displayName": "水平布局: horizontal"
    },
    {
      "textRaw": "线性布局: linear",
      "name": "线性布局:_linear",
      "desc": "<p>实际上, 垂直布局和水平布局都属于线性布局. 线性布局有一个orientation的属性, 用于指定布局的方向, 可选的值为<code>vertical</code>和<code>horizontal</code>.</p>\n<p>例如<code>&lt;linear orientation=&quot;vertical&quot;&gt;&lt;/linear&gt;</code>相当于<code>&lt;vertical&gt;&lt;/vertical&gt;</code>.</p>\n<p>线性布局的默认方向是横向的, 因此, 一个没有指定orientation属性的线性布局就是横向布局.</p>\n",
      "type": "module",
      "displayName": "线性布局: linear"
    },
    {
      "textRaw": "帧布局: frame",
      "name": "帧布局:_frame",
      "desc": "<p>帧布局</p>\n",
      "type": "module",
      "displayName": "帧布局: frame"
    },
    {
      "textRaw": "选择框布局: radiogroup",
      "name": "选择框布局: radiogroup",
      "desc": "<p>开关控件用于表示一个选项是否被选中.</p>\n",
      "modules": [
        {
          "textRaw": "checked",
          "name": "checked",
          "desc": "<p>表示开关是否被选中. 可选的值为：</p>\n<ul>\n<li><code>true</code> 打开开关</li>\n<li><code>false</code> 关闭开关</li>\n</ul>\n",
          "type": "module",
          "displayName": "checked"
        },
        {
          "textRaw": "text",
          "name": "text",
          "desc": "<p>对开关进行描述的文字.</p>\n",
          "type": "module",
          "displayName": "text"
        }
      ],
      "type": "module",
      "displayName": "开关控件: Switch"
    },
    {
      "textRaw": "开关控件: Switch",
      "name": "开关控件:_switch",
      "desc": "<p>开关控件用于表示一个选项是否被选中.</p>\n",
      "modules": [
        {
          "textRaw": "checked",
          "name": "checked",
          "desc": "<p>表示开关是否被选中. 可选的值为：</p>\n<ul>\n<li><code>true</code> 打开开关</li>\n<li><code>false</code> 关闭开关</li>\n</ul>\n",
          "type": "module",
          "displayName": "checked"
        },
        {
          "textRaw": "text",
          "name": "text",
          "desc": "<p>对开关进行描述的文字.</p>\n",
          "type": "module",
          "displayName": "text"
        }
      ],
      "type": "module",
      "displayName": "开关控件: Switch"
    },
    {
      "textRaw": "标题栏控件: toolbar",
      "name": "标题栏控件: toolbar",
      "desc": "<p>卡片控件是一个拥有圆角、阴影的控件.</p>\n",
      "modules": [
        {
          "textRaw": "cardBackgroundColor",
          "name": "cardbackgroundcolor",
          "desc": "<p>卡片的背景颜色.</p>\n",
          "type": "module",
          "displayName": "cardBackgroundColor"
        },
        {
          "textRaw": "cardCornerRadius",
          "name": "cardcornerradius",
          "desc": "<p>卡片的圆角半径.</p>\n",
          "type": "module",
          "displayName": "cardCornerRadius"
        },
        {
          "textRaw": "cardElevation",
          "name": "cardelevation",
          "desc": "<p>设置卡片在z轴上的高度, 来控制阴影的大小.</p>\n",
          "type": "module",
          "displayName": "cardElevation"
        },
        {
          "textRaw": "contentPadding",
          "name": "contentpadding",
          "desc": "<p>设置卡片的内边距. 该属性包括四个值：</p>\n<ul>\n<li><code>contentPaddingLeft</code> 左内边距</li>\n<li><code>contentPaddingRight</code> 右内边距</li>\n<li><code>contentPaddingTop</code> 上内边距</li>\n<li><code>contentPaddingBottom</code> 下内边距</li>\n</ul>\n",
          "type": "module",
          "displayName": "contentPadding"
        },
        {
          "textRaw": "foreground",
          "name": "foreground",
          "desc": "<p>使用<code>foreground=&quot;?selectableItemBackground&quot;</code>属性可以为卡片添加点击效果.</p>\n",
          "type": "module",
          "displayName": "foreground"
        }
      ],
      "type": "module",
      "displayName": "卡片: card"
    },
    {
      "textRaw": "卡片: card",
      "name": "卡片:_card",
      "desc": "<p>卡片控件是一个拥有圆角、阴影的控件.</p>\n",
      "modules": [
        {
          "textRaw": "cardBackgroundColor",
          "name": "cardbackgroundcolor",
          "desc": "<p>卡片的背景颜色.</p>\n",
          "type": "module",
          "displayName": "cardBackgroundColor"
        },
        {
          "textRaw": "cardCornerRadius",
          "name": "cardcornerradius",
          "desc": "<p>卡片的圆角半径.</p>\n",
          "type": "module",
          "displayName": "cardCornerRadius"
        },
        {
          "textRaw": "cardElevation",
          "name": "cardelevation",
          "desc": "<p>设置卡片在z轴上的高度, 来控制阴影的大小.</p>\n",
          "type": "module",
          "displayName": "cardElevation"
        },
        {
          "textRaw": "contentPadding",
          "name": "contentpadding",
          "desc": "<p>设置卡片的内边距. 该属性包括四个值：</p>\n<ul>\n<li><code>contentPaddingLeft</code> 左内边距</li>\n<li><code>contentPaddingRight</code> 右内边距</li>\n<li><code>contentPaddingTop</code> 上内边距</li>\n<li><code>contentPaddingBottom</code> 下内边距</li>\n</ul>\n",
          "type": "module",
          "displayName": "contentPadding"
        },
        {
          "textRaw": "foreground",
          "name": "foreground",
          "desc": "<p>使用<code>foreground=&quot;?selectableItemBackground&quot;</code>属性可以为卡片添加点击效果.</p>\n",
          "type": "module",
          "displayName": "foreground"
        }
      ],
      "type": "module",
      "displayName": "卡片: card"
    },
    {
      "textRaw": "Tab: tab",
      "name": "Tab: tab",
      "methods": [
        {
          "textRaw": "ui.layout(xml)",
          "type": "method",
          "name": "layout",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`xml` {XML} | {string} 布局XML或者XML字符串 ",
                  "name": "xml",
                  "type": "XML",
                  "desc": "| {string} 布局XML或者XML字符串"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "xml"
                }
              ]
            }
          ],
          "desc": "<p>将布局XML渲染为视图（View）对象,  并设置为当前视图.</p>\n"
        },
        {
          "textRaw": "ui.layoutFile(xmlFile)",
          "type": "method",
          "name": "layoutFile",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`xml` {string} 布局XML文件的路径 ",
                  "name": "xml",
                  "type": "string",
                  "desc": "布局XML文件的路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "xmlFile"
                }
              ]
            }
          ],
          "desc": "<p>此函数和<code>ui.layout</code>相似, 只不过允许传入一个xml文件路径来渲染布局.</p>\n"
        },
        {
          "textRaw": "ui.inflate(xml[, parent = null, attachToParent = false])",
          "type": "method",
          "name": "inflate",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`xml` {string} | {XML} 布局XML或者XML字符串 ",
                  "name": "xml",
                  "type": "string",
                  "desc": "| {XML} 布局XML或者XML字符串"
                },
                {
                  "textRaw": "`parent` {View} 父视图 ",
                  "name": "parent",
                  "type": "View",
                  "desc": "父视图",
                  "optional": true,
                  "default": " null"
                },
                {
                  "textRaw": "`attachToParent` {boolean} 是否渲染的View加到父视图中, 默认为false ",
                  "name": "attachToParent",
                  "type": "boolean",
                  "desc": "是否渲染的View加到父视图中, 默认为false",
                  "optional": true,
                  "default": " false"
                },
                {
                  "textRaw": "返回 {View} ",
                  "name": "返回",
                  "type": "View"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "xml"
                },
                {
                  "name": "parent ",
                  "optional": true,
                  "default": " null"
                },
                {
                  "name": "attachToParent ",
                  "optional": true,
                  "default": " false"
                }
              ]
            }
          ],
          "desc": "<p>将布局XML渲染为视图（View）对象. 如果该View将作为某个View的子View, 我们建议传入<code>parent</code>参数, 这样在渲染时依赖于父视图的一些布局属性能够正确应用.</p>\n<p>此函数用于动态创建、显示View.</p>\n<pre><code class=\"lang-javascript\">&quot;ui&quot;;\n\n$ui.layout(\n    &lt;linear id=&quot;container&quot;&gt;\n    &lt;/linear&gt;\n);\n\n// 动态创建3个文本控件, 并加到container容器中\n// 这里仅为实例, 实际上并不推荐这种做法, 如果要展示列表, \n// 使用list组件；动态创建十几个、几十个View会让界面卡顿\nfor (let i = 0; i &lt; 3; i++) {\n    let textView = $ui.inflate(\n        &lt;text textColor=&quot;#000000&quot; textSize=&quot;14sp&quot;/&gt;\n    , $ui.container);\n    textView.attr(&quot;text&quot;, &quot;文本控件&quot; + i);\n    $ui.container.addView(textView);\n}\n</code></pre>\n"
        }
      ],
      "type": "module",
      "displayName": "ui"
    },
    {
      "textRaw": "ui",
      "name": "ui",
      "methods": [
        {
          "textRaw": "ui.layout(xml)",
          "type": "method",
          "name": "layout",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`xml` {XML} | {string} 布局XML或者XML字符串 ",
                  "name": "xml",
                  "type": "XML",
                  "desc": "| {string} 布局XML或者XML字符串"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "xml"
                }
              ]
            }
          ],
          "desc": "<p>将布局XML渲染为视图（View）对象,  并设置为当前视图.</p>\n"
        },
        {
          "textRaw": "ui.layoutFile(xmlFile)",
          "type": "method",
          "name": "layoutFile",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`xml` {string} 布局XML文件的路径 ",
                  "name": "xml",
                  "type": "string",
                  "desc": "布局XML文件的路径"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "xmlFile"
                }
              ]
            }
          ],
          "desc": "<p>此函数和<code>ui.layout</code>相似, 只不过允许传入一个xml文件路径来渲染布局.</p>\n"
        },
        {
          "textRaw": "ui.inflate(xml[, parent = null, attachToParent = false])",
          "type": "method",
          "name": "inflate",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`xml` {string} | {XML} 布局XML或者XML字符串 ",
                  "name": "xml",
                  "type": "string",
                  "desc": "| {XML} 布局XML或者XML字符串"
                },
                {
                  "textRaw": "`parent` {View} 父视图 ",
                  "name": "parent",
                  "type": "View",
                  "desc": "父视图",
                  "optional": true,
                  "default": " null"
                },
                {
                  "textRaw": "`attachToParent` {boolean} 是否渲染的View加到父视图中, 默认为false ",
                  "name": "attachToParent",
                  "type": "boolean",
                  "desc": "是否渲染的View加到父视图中, 默认为false",
                  "optional": true,
                  "default": " false"
                },
                {
                  "textRaw": "返回 {View} ",
                  "name": "返回",
                  "type": "View"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "xml"
                },
                {
                  "name": "parent ",
                  "optional": true,
                  "default": " null"
                },
                {
                  "name": "attachToParent ",
                  "optional": true,
                  "default": " false"
                }
              ]
            }
          ],
          "desc": "<p>将布局XML渲染为视图（View）对象. 如果该View将作为某个View的子View, 我们建议传入<code>parent</code>参数, 这样在渲染时依赖于父视图的一些布局属性能够正确应用.</p>\n<p>此函数用于动态创建、显示View.</p>\n<pre><code class=\"lang-javascript\">&quot;ui&quot;;\n\n$ui.layout(\n    &lt;linear id=&quot;container&quot;&gt;\n    &lt;/linear&gt;\n);\n\n// 动态创建3个文本控件, 并加到container容器中\n// 这里仅为实例, 实际上并不推荐这种做法, 如果要展示列表, \n// 使用list组件；动态创建十几个、几十个View会让界面卡顿\nfor (let i = 0; i &lt; 3; i++) {\n    let textView = $ui.inflate(\n        &lt;text textColor=&quot;#000000&quot; textSize=&quot;14sp&quot;/&gt;\n    , $ui.container);\n    textView.attr(&quot;text&quot;, &quot;文本控件&quot; + i);\n    $ui.container.addView(textView);\n}\n</code></pre>\n"
        }
      ],
      "type": "module",
      "displayName": "ui"
    },
    {
      "textRaw": "Drawables",
      "name": "Drawables",
      "desc": "<p><strong>(完善中...)</strong></p>\n<!-- [end-include:ui.md] -->\n<!-- [start-include:web.md] -->\n",
      "type": "module",
      "displayName": "颜色"
    },
    {
      "textRaw": "颜色",
      "name": "颜色",
      "desc": "<p><strong>(完善中...)</strong></p>\n<!-- [end-include:ui.md] -->\n<!-- [start-include:web.md] -->\n",
      "type": "module",
      "displayName": "颜色"
    },
    {
      "textRaw": "万维网 (Web)",
      "name": "万维网_(web)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<!-- [end-include:web.md] -->\n<!-- [start-include:http.md] -->\n",
      "type": "module",
      "displayName": "万维网 (Web)"
    },
    {
      "textRaw": "HTTP",
      "name": "http",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p>http模块提供一些进行http请求的函数.</p>\n",
      "methods": [
        {
          "textRaw": "http.get(url[, options, callback])",
          "type": "method",
          "name": "get",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`url` {string} 请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\". ",
                  "name": "url",
                  "type": "string",
                  "desc": "请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\"."
                },
                {
                  "textRaw": "`options` {Object} 请求选项. 参见[http.request()][]. ",
                  "name": "options",
                  "type": "Object",
                  "desc": "请求选项. 参见[http.request()][].",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调函数, 可选, 其参数是一个[Response][]对象. 如果不加回调函数, 则该请求将阻塞、同步地执行. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数, 可选, 其参数是一个[Response][]对象. 如果不加回调函数, 则该请求将阻塞、同步地执行.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "url"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>对地址url进行一次HTTP GET 请求. 如果没有回调函数, 则在请求完成或失败时返回此次请求的响应(参见[Response][]).</p>\n<p>最简单GET请求如下:</p>\n<pre><code>console.show();\nvar r = http.get(&quot;www.baidu.com&quot;);\nlog(&quot;code = &quot; + r.statusCode);\nlog(&quot;html = &quot; + r.body.string());\n</code></pre><p>采用回调形式的GET请求如下：</p>\n<pre><code>console.show();\nhttp.get(&quot;www.baidu.com&quot;, {}, function(res, err){\n    if(err){\n        console.error(err);\n        return;\n    }\n    log(&quot;code = &quot; + res.statusCode);\n    log(&quot;html = &quot; + res.body.string());\n});\n</code></pre><p>如果要增加HTTP头部信息, 则在options参数中添加, 例如：</p>\n<pre><code>console.show();\nvar r = http.get(&quot;www.baidu.com&quot;, {\n    headers: {\n        &#39;Accept-Language&#39;: &#39;zh-cn,zh;q=0.5&#39;,\n        &#39;User-Agent&#39;: &#39;Mozilla/5.0(Macintosh;IntelMacOSX10_7_0)AppleWebKit/535.11(KHTML,likeGecko)Chrome/17.0.963.56Safari/535.11&#39;\n    }\n});\nlog(&quot;code = &quot; + r.statusCode);\nlog(&quot;html = &quot; + r.body.string());\n</code></pre><p>一个请求天气并解析返回的天气JSON结果的例子如下：</p>\n<pre><code>var city = &quot;广州&quot;;\nvar res = http.get(&quot;http://www.sojson.com/open/api/weather/json.shtml?city=&quot; + city);\nif(res.statusCode != 200){\n    toast(&quot;请求失败: &quot; + res.statusCode + &quot; &quot; + res.statusMessage);\n}else{\n    var weather = res.body.json();\n    log(weather);\n    toast(util.format(&quot;温度: %s 湿度: %s 空气质量: %s&quot;, weather.data.wendu,\n        weather.data.shidu, weather.quality));\n}\n</code></pre>"
        },
        {
          "textRaw": "http.post(url, data[, options, callback])",
          "type": "method",
          "name": "post",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`url` {string} 请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\". ",
                  "name": "url",
                  "type": "string",
                  "desc": "请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\"."
                },
                {
                  "textRaw": "`data` {string} | {Object} POST数据. ",
                  "name": "data",
                  "type": "string",
                  "desc": "| {Object} POST数据."
                },
                {
                  "textRaw": "`options` {Object} 请求选项. ",
                  "name": "options",
                  "type": "Object",
                  "desc": "请求选项.",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调, 其参数是一个[Response][]对象. 如果不加回调参数, 则该请求将阻塞、同步地执行. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调, 其参数是一个[Response][]对象. 如果不加回调参数, 则该请求将阻塞、同步地执行.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "url"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>对地址url进行一次HTTP POST 请求. 如果没有回调函数, 则在请求完成或失败时返回此次请求的响应(参见[Response][]).</p>\n<p>其中POST数据可以是字符串或键值对. 具体含义取决于options.contentType的值. 默认为&quot;application/x-www-form-urlencoded&quot;(表单提交), 这种方式是JQuery的ajax函数的默认方式.</p>\n<p>一个模拟表单提交登录淘宝的例子如下:</p>\n<pre><code>var url = &quot;https://login.taobao.com/member/login.jhtml&quot;;\nvar username = &quot;你的用户名&quot;;\nvar password = &quot;你的密码&quot;;\nvar res = http.post(url, {\n    &quot;TPL_username&quot;: username,\n    &quot;TPL_password&quot;: password\n});\nvar html = res.body.string();\nif(html.contains(&quot;页面跳转中&quot;)){\n    toast(&quot;登录成功&quot;);\n}else{\n    toast(&quot;登录失败&quot;);\n}\n</code></pre>"
        },
        {
          "textRaw": "http.postJson(url[, data, options, callback])",
          "type": "method",
          "name": "postJson",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`url` {string} 请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\". ",
                  "name": "url",
                  "type": "string",
                  "desc": "请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\"."
                },
                {
                  "textRaw": "`data` {Object} POST数据. ",
                  "name": "data",
                  "type": "Object",
                  "desc": "POST数据.",
                  "optional": true
                },
                {
                  "textRaw": "`options` {Object} 请求选项. ",
                  "name": "options",
                  "type": "Object",
                  "desc": "请求选项.",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调, 其参数是一个[Response][]对象. 如果不加回调参数, 则该请求将阻塞、同步地执行. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调, 其参数是一个[Response][]对象. 如果不加回调参数, 则该请求将阻塞、同步地执行.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "url"
                },
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>以JSON格式向目标Url发起POST请求. 如果没有回调函数, 则在请求完成或失败时返回此次请求的响应(参见[Response][]).</p>\n<p>JSON格式指的是, 将会调用<code>JSON.stringify()</code>把data对象转换为JSON字符串, 并在HTTP头部信息中把&quot;Content-Type&quot;属性置为&quot;application/json&quot;. 这种方式是AngularJS的ajax函数的默认方式.</p>\n<p>一个调用图灵机器人接口的例子如下：</p>\n<pre><code>var url = &quot;http://www.tuling123.com/openapi/api&quot;;\nr = http.postJson(url, {\n    key: &quot;65458a5df537443b89b31f1c03202a80&quot;,\n    info: &quot;你好啊&quot;,\n    userid: &quot;1&quot;,\n});\ntoastLog(r.body.string());\n</code></pre>"
        },
        {
          "textRaw": "http.postMultipart(url, files[, options, callback])",
          "type": "method",
          "name": "postMultipart",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`url` {string} 请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\". ",
                  "name": "url",
                  "type": "string",
                  "desc": "请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\"."
                },
                {
                  "textRaw": "`files` {Object} POST数据. ",
                  "name": "files",
                  "type": "Object",
                  "desc": "POST数据."
                },
                {
                  "textRaw": "`options` {Object} 请求选项. ",
                  "name": "options",
                  "type": "Object",
                  "desc": "请求选项.",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调, 其参数是一个`Response`对象. 如果不加回调参数, 则该请求将阻塞、同步地执行. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调, 其参数是一个`Response`对象. 如果不加回调参数, 则该请求将阻塞、同步地执行.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "url"
                },
                {
                  "name": "files"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>向目标地址发起类型为multipart/form-data的请求（通常用于文件上传等), 其中files参数是{name1: value1, name2: value2, ...}的键值对, value的格式可以是以下几种情况：</p>\n<ol>\n<li><code>string</code></li>\n<li>文件类型, 即open()返回的类型</li>\n<li>[fileName, filePath]</li>\n<li>[fileName, mimeType, filePath]</li>\n</ol>\n<p>其中1属于非文件参数, 2、3、4为文件参数. 举个例子, 最简单的文件上传的请求为：</p>\n<pre><code>var res = http.postMultipart(url, {\n    file: open(&quot;/sdcard/1.txt&quot;)\n});\nlog(res.body.string());\n</code></pre><p>如果使用格式2, 则代码为</p>\n<pre><code>var res = http.postMultipart(url, {\n    file: [&quot;1.txt&quot;, &quot;/sdcard/1.txt&quot;]\n});\nlog(res.body.string());\n</code></pre><p>如果使用格式3, 则代码为</p>\n<pre><code>var res = http.postMultipart(url, {\n    file: [&quot;1.txt&quot;, &quot;text/plain&quot;, &quot;/sdcard/1.txt&quot;]\n});\nlog(res.body.string());\n</code></pre><p>如果使用格式2的同时要附带非文件参数&quot;appId=abcdefghijk&quot;, 则为:</p>\n<pre><code>var res = http.postMultipart(url, {\n    appId: &quot;adcdefghijk&quot;,\n    file: open(&quot;/sdcard/1.txt&quot;)\n});\nlog(res.body.string());\n</code></pre>"
        },
        {
          "textRaw": "http.request(url[, options, callback])",
          "type": "method",
          "name": "request",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`url` {string} 请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\". ",
                  "name": "url",
                  "type": "string",
                  "desc": "请求的URL地址, 需要以\"http://\"或\"https://\"开头. 如果url没有以\"http://\"开头, 则默认为\"http://\"."
                },
                {
                  "textRaw": "`options` {Object} 请求选项. 参见[http.buildRequest()][]. ",
                  "name": "options",
                  "type": "Object",
                  "desc": "请求选项. 参见[http.buildRequest()][].",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} 回调, 其参数是一个[Response][]对象. 如果不加回调参数, 则该请求将阻塞、同步地执行. ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调, 其参数是一个[Response][]对象. 如果不加回调参数, 则该请求将阻塞、同步地执行.",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "url"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>对目标地址url发起一次HTTP请求. 如果没有回调函数, 则在请求完成或失败时返回此次请求的响应(参见[Response][]).</p>\n<p>选项options可以包含以下属性：</p>\n<ul>\n<li><code>headers</code> {Object} 键值对形式的HTTP头部信息. 有关HTTP头部信息, 参见<a href=\"http://www.runoob.com/http/http-header-fields.html\">菜鸟教程：HTTP响应头信息</a>.</li>\n<li><code>method</code> {string} HTTP请求方法. 包括&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELET&quot;, &quot;PATCH&quot;.</li>\n<li><code>contentType</code> {string} HTTP头部信息中的&quot;Content-Type&quot;, 表示HTTP请求的内容类型. 例如&quot;text/plain&quot;, &quot;application/json&quot;. 更多信息参见<a href=\"http://www.runoob.com/http/http-content-type.html\">菜鸟教程：HTTP contentType</a>.</li>\n<li><code>body</code> {string} | {Array} | {Function} HTTP请求的内容. 可以是一个字符串, 也可以是一个字节数组；或者是一个以<a href=\"https://github.com/square/okio/blob/master/okio/src/main/java/okio/BufferedSink.java/\">BufferedSink</a>为参数的函数.</li>\n</ul>\n<p>该函数是get, post, postJson等函数的基础函数. 因此除非是PUT, DELET等请求, 或者需要更高定制的HTTP请求, 否则直接使用get, post, postJson等函数会更加方便.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "HTTP"
    },
    {
      "textRaw": "Response",
      "name": "response",
      "desc": "<p>HTTP请求的响应.</p>\n",
      "properties": [
        {
          "textRaw": "`statusCode` {number} ",
          "type": "number",
          "name": "statusCode",
          "desc": "<p>当前响应的HTTP状态码. 例如200(OK), 404(Not Found)等.</p>\n<p>有关HTTP状态码的信息, 参见<a href=\"http://www.runoob.com/http/http-status-codes.html\">菜鸟教程：HTTP状态码</a>.</p>\n"
        },
        {
          "textRaw": "`statusMessage` {string} ",
          "type": "string",
          "name": "statusMessage",
          "desc": "<p>当前响应的HTTP状态信息. 例如&quot;OK&quot;, &quot;Bad Request&quot;, &quot;Forbidden&quot;.</p>\n<p>有关HTTP状态码的信息, 参见<a href=\"http://www.runoob.com/http/http-status-codes.html\">菜鸟教程：HTTP状态码</a>.</p>\n<p>例子：</p>\n<pre><code>var res = http.get(&quot;www.baidu.com&quot;);\nif(res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300){\n    toast(&quot;页面获取成功!&quot;);\n}else if(res.statusCode == 404){\n    toast(&quot;页面没找到哦...&quot;);\n}else{\n    toast(&quot;错误: &quot; + res.statusCode + &quot; &quot; + res.statusMessage);\n}\n</code></pre>"
        },
        {
          "textRaw": "`headers` {Object} ",
          "type": "Object",
          "name": "headers",
          "desc": "<p>当前响应的HTTP头部信息. 该对象的键是响应头名称, 值是各自的响应头值.  所有响应头名称都是小写的(吗).</p>\n<p>有关HTTP头部信息, 参见<a href=\"http://www.runoob.com/http/http-header-fields.html\">菜鸟教程：HTTP响应头信息</a>.</p>\n<p>例子:</p>\n<pre><code>console.show();\nvar res = http.get(&quot;www.qq.com&quot;);\nconsole.log(&quot;HTTP Headers:&quot;)\nfor(var headerName in res.headers){\n    console.log(&quot;%s: %s&quot;, headerName, res.headers[headerName]);\n}\n</code></pre>"
        },
        {
          "textRaw": "`body` {Object} ",
          "type": "Object",
          "name": "body",
          "desc": "<p>当前响应的内容. 他有以下属性和函数：</p>\n<ul>\n<li>bytes() {Array} 以字节数组形式返回响应内容</li>\n<li>string() {string} 以字符串形式返回响应内容</li>\n<li>json() {Object} 把响应内容作为JSON格式的数据并调用JSON.parse, 返回解析后的对象</li>\n<li>contentType {string} 当前响应的内容类型</li>\n</ul>\n"
        },
        {
          "textRaw": "`url` {number} 当前响应所对应的请求URL. ",
          "type": "number",
          "name": "url",
          "desc": "当前响应所对应的请求URL.",
          "shortDesc": "当前响应所对应的HTTP请求的方法. 例如\"GET\", \"POST\", \"PUT\"等."
        },
        {
          "textRaw": "`method` {string} 当前响应所对应的HTTP请求的方法. 例如\"GET\", \"POST\", \"PUT\"等. ",
          "type": "string",
          "name": "method",
          "desc": "<!-- [end-include:http.md] -->\n<!-- [start-include:base64.md] -->\n",
          "shortDesc": "当前响应所对应的HTTP请求的方法. 例如\"GET\", \"POST\", \"PUT\"等."
        }
      ],
      "type": "module",
      "displayName": "Response"
    },
    {
      "textRaw": "Base64",
      "name": "base64",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<!-- [end-include:base64.md] -->\n<!-- [start-include:crypto.md] -->\n",
      "type": "module",
      "displayName": "Base64"
    },
    {
      "textRaw": "密文 (Crypto)",
      "name": "密文_(crypto)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<p><strong> [<a href=\"https://pro.autojs.org/\">Pro 8.0.0新增</a>] </strong></p>\n<p>$crypto模块提供了对称加密(例如AES)、非对称加密(例如RSA)、消息摘要(例如MD5, SHA)等支持.</p>\n",
      "methods": [
        {
          "textRaw": "$crypto.digest(message, algorithm[, options])",
          "type": "method",
          "name": "digest",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`message` {any} ",
                  "name": "message",
                  "type": "any"
                },
                {
                  "textRaw": "`algorithm` {string} 消息摘要算法, 包括： ",
                  "options": [
                    {
                      "textRaw": "MD5 ",
                      "name": "MD5"
                    },
                    {
                      "textRaw": "SHA-1 ",
                      "name": "SHA-1"
                    },
                    {
                      "textRaw": "SHA-256 ",
                      "name": "SHA-256"
                    },
                    {
                      "textRaw": "SHA-384 ",
                      "name": "SHA-384"
                    },
                    {
                      "textRaw": "SHA-512 ",
                      "name": "SHA-512"
                    }
                  ],
                  "name": "algorithm",
                  "type": "string",
                  "desc": "消息摘要算法, 包括："
                },
                {
                  "textRaw": "`options` {any} ",
                  "name": "options",
                  "type": "any",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "message"
                },
                {
                  "name": "algorithm"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>对信息message使用消息摘要算法<code>algorithm</code>进行摘要并返回结果, 默认的输出格式为hex.</p>\n<p>参数message的类型默认为字符串, 返回值默认为hex；可以通过options来指定参数message的类型和返回值的类型、格式, 比如文件、base64、字节数组、hex等. 参见《输入和输出的类型和格式》.</p>\n<pre><code class=\"lang-javascript\">// 计算字符串abc的md5\ntoastLog($crypto.digest(&quot;abc&quot;, &quot;MD5&quot;));\n// 计算字符串abc的sha-256\ntoastLog($crypto.digest(&quot;abc&quot;, &quot;SHA-256&quot;));\n// 计算文件/sdcard/1.txt的md5\ntoastLog($crypto.digest(&quot;/sdcard/1.txt&quot;, &quot;MD5&quot;, {\n    input: &quot;file&quot;\n}));\n</code></pre>\n"
        },
        {
          "textRaw": "$crypto.encrypt(data, key, algorithm, options)",
          "type": "method",
          "name": "encrypt",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`data` {any} 明文消息 ",
                  "name": "data",
                  "type": "any",
                  "desc": "明文消息"
                },
                {
                  "textRaw": "`key` {Key} 密钥 ",
                  "name": "key",
                  "type": "Key",
                  "desc": "密钥"
                },
                {
                  "textRaw": "`algorithm` {string} 加密算法, 包括： ",
                  "options": [
                    {
                      "textRaw": "AES ",
                      "name": "AES"
                    },
                    {
                      "textRaw": "AES/ECB/NoPadding ",
                      "name": "AES/ECB/NoPadding"
                    },
                    {
                      "textRaw": "AES/ECB/PKCS5Padding ",
                      "name": "AES/ECB/PKCS5Padding"
                    },
                    {
                      "textRaw": "AES/CBC/NoPadding ",
                      "name": "AES/CBC/NoPadding"
                    },
                    {
                      "textRaw": "AES/CBC/PKCS5Padding ",
                      "name": "AES/CBC/PKCS5Padding"
                    },
                    {
                      "textRaw": "AES/CFB/NoPadding ",
                      "name": "AES/CFB/NoPadding"
                    },
                    {
                      "textRaw": "AES/CFB/PKCS5Padding ",
                      "name": "AES/CFB/PKCS5Padding"
                    },
                    {
                      "textRaw": "AES/CTR/NoPadding ",
                      "name": "AES/CTR/NoPadding"
                    },
                    {
                      "textRaw": "AES/CTR/PKCS5Padding ",
                      "name": "AES/CTR/PKCS5Padding"
                    },
                    {
                      "textRaw": "AES/OFB/PKCS5Padding ",
                      "name": "AES/OFB/PKCS5Padding"
                    },
                    {
                      "textRaw": "AES/OFB/PKCS5Padding ",
                      "name": "AES/OFB/PKCS5Padding"
                    },
                    {
                      "textRaw": "RSA/ECB/PKCS1Padding ",
                      "name": "RSA/ECB/PKCS1Padding"
                    },
                    {
                      "textRaw": "RSA/ECB/NoPadding ",
                      "name": "RSA/ECB/NoPadding"
                    },
                    {
                      "textRaw": "... 具体可参阅 [javax.crypto.Cipher](https://developer.android.com/reference/javax/crypto/Cipher/) ",
                      "name": "...",
                      "desc": "具体可参阅 [javax.crypto.Cipher](https://developer.android.com/reference/javax/crypto/Cipher/)"
                    }
                  ],
                  "name": "algorithm",
                  "type": "string",
                  "desc": "加密算法, 包括："
                },
                {
                  "textRaw": "`options` {Object} 加密选项 ",
                  "name": "options",
                  "type": "Object",
                  "desc": "加密选项"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "data"
                },
                {
                  "name": "key"
                },
                {
                  "name": "algorithm"
                },
                {
                  "name": "options"
                }
              ]
            }
          ],
          "desc": "<!-- [end-include:crypto.md] -->\n<!-- [start-include:i18n.md] -->\n",
          "displayName": "输入和输出的类型和格式"
        }
      ],
      "modules": [
        {
          "textRaw": "输入和输出的类型和格式",
          "name": "输入和输出的类型和格式",
          "desc": "<!-- [end-include:crypto.md] -->\n<!-- [start-include:i18n.md] -->\n",
          "type": "module",
          "displayName": "输入和输出的类型和格式"
        }
      ],
      "type": "module",
      "displayName": "密文 (Crypto)"
    },
    {
      "textRaw": "国际化 (Internationalization)",
      "name": "国际化_(internationalization)",
      "desc": "<hr>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">此章节待补充或完善...</p>\n<p style=\"font: italic 1em sans-serif; color: #78909C\">Marked by SuperMonster003 on Oct 22, 2022.</p>\n\n<hr>\n<!-- [end-include:i18n.md] -->\n<!-- [start-include:e4x.md] -->\n",
      "type": "module",
      "displayName": "国际化 (Internationalization)"
    },
    {
      "textRaw": "E4X",
      "name": "e4x",
      "desc": "<p>注: E4X <strong>已弃用</strong>.</p>\n<p>尽管少数浏览器依然支持, 但随着件更新正逐步被废除, 应尽量避免使用.<br>AutoJs6 使用 Rhino 引擎, 因此依然保持对 E4X 的支持.</p>\n<p>本章节仅用于技术概念的归档及溯源, 不建议用于脚本编写.</p>\n<p>ECMAScript for XML (E4X) 是对 ECMAScript 的扩展, 增加对 XML 的内在支持.<br>其目标是在访问 XML 文档时, 提供一种更直观且语法更简洁的的 DOM 接口, 成为处理 XML 文档的新方式.</p>\n<pre><code class=\"lang-e4x\">var sales = &lt;sales vendor=&quot;John&quot;&gt;\n    &lt;item type=&quot;peas&quot; price=&quot;4&quot; quantity=&quot;6&quot;/&gt;\n    &lt;item type=&quot;carrot&quot; price=&quot;3&quot; quantity=&quot;10&quot;/&gt;\n    &lt;item type=&quot;chips&quot; price=&quot;5&quot; quantity=&quot;3&quot;/&gt;\n  &lt;/sales&gt;;\n\nalert( sales.item.(@type == &quot;carrot&quot;).@quantity );\nalert( sales.@vendor );\nfor each( var price in sales..@price ) {\n  alert( price );\n}\ndelete sales.item[0];\nsales.item += &lt;item type=&quot;oranges&quot; price=&quot;4&quot;/&gt;;\nsales.item.(@type == &quot;oranges&quot;).@quantity = 4;\n</code></pre>\n<blockquote>\n<p>参阅: <a href=\"https://en.wikipedia.org/wiki/ECMAScript_for_XML\">Wikipedia (英)</a> / <a href=\"https://zh.wikipedia.org/wiki/E4X\">Wikipedia (中)</a><br>替代: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DOMParser\">DOMParser</a> / <a href=\"https://www.npmjs.com/package/dom-serializer\">DOMSerializer</a>\n<!-- [end-include:e4x.md] --></p>\n</blockquote>\n",
      "type": "module",
      "displayName": "E4X"
    }
  ],
  "miscs": [
    {
      "textRaw": "关于文档 (About)",
      "name": "关于文档 (About)",
      "type": "misc",
      "desc": "<p>AutoJs6 文档, 包含模块 API 使用方法及用例.<br>项目复刻 (Fork) 自 <a href=\"https://github.com/hyb1996/AutoJs-Docs/\">hyb1996/AutoJs-Docs</a> (GitHub).<br>项目地址: <a href=\"https://github.com/SuperMonster003/AutoJs6-Documentation/\">SuperMonster003/AutoJs6-Documentation</a> (GitHub).</p>\n<hr>\n",
      "miscs": [
        {
          "textRaw": "文档阅读示例",
          "name": "文档阅读示例",
          "modules": [
            {
              "textRaw": "基础",
              "name": "基础",
              "properties": [
                {
                  "textRaw": "device.height",
                  "name": "height",
                  "desc": "<p>device 表示全局对象 (这里同时也是一个模块).<br>&quot;.height&quot; 表示访问 device 对象的 height 成员变量.<br>如 console.log(device.height) 表示在控制台打印当前设备的高度数值.</p>\n"
                }
              ],
              "methods": [
                {
                  "textRaw": "colors.rgb(red, green, blue)",
                  "type": "method",
                  "name": "rgb",
                  "desc": "<p>colors 与 device 类似, 表示全局对象.<br>&quot;rgb&quot; 表示方法名称, &quot;.rgb()&quot; 表示调用 colors 的 rgb 方法, 括号内的 red 等表示方法参数.<br>如 console.log(colors.rgb(255, 128, 64)) 表示在控制台打印一个 RGB 分别为 255, 128 和 64 的颜色数值.</p>\n<blockquote>\n<p>注: 绝大多数情况, 文档不对 &quot;<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Function/\">函数</a>&quot; 与 &quot;<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Method/\">方法</a>&quot; 做明确区分.</p>\n</blockquote>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "red"
                        },
                        {
                          "name": "green"
                        },
                        {
                          "name": "blue"
                        }
                      ]
                    }
                  ]
                }
              ],
              "type": "module",
              "displayName": "基础"
            },
            {
              "textRaw": "临时作用域对象",
              "name": "临时作用域对象",
              "desc": "<p>通常每个章节都以某个对象作为主题.</p>\n<p>例如上述 <code>colors.rgb(red, green, blue)</code> 位于 <a href=\"color\">Color - 颜色</a> 这个章节.<br>其中 colors 称为此章节的 &quot;临时作用域对象&quot;,<br>它可能是一个对象, 函数, 甚至 &quot;类&quot;, 在文档中使用 <strong><code>橙色粗体</code></strong> 表示.</p>\n<p>列举其后续的相关方法及属性时, 将不再重复书写对象本身:</p>\n<p style=\"font: bold 1em sans-serif; color: #FF7043\">colors</p>\n\n<p>[m] rgb</p>\n<p>rgb(red, green, blue)</p>\n<p>... ...</p>\n<p>上述 <code>rgb</code> 表示 <code>colors.rgb</code>.</p>\n",
              "type": "module",
              "displayName": "临时作用域对象"
            },
            {
              "textRaw": "参数类型",
              "name": "参数类型",
              "methods": [
                {
                  "textRaw": "colors.rgb(red, green, blue)",
                  "type": "method",
                  "name": "rgb",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "**red** { [number](dataTypes#number) } ",
                          "name": "**red**",
                          "type": " [number](dataTypes#number) "
                        },
                        {
                          "textRaw": "**green** { [number](dataTypes#number) } ",
                          "name": "**green**",
                          "type": " [number](dataTypes#number) "
                        },
                        {
                          "textRaw": "**blue** { [number](dataTypes#number) } ",
                          "name": "**blue**",
                          "type": " [number](dataTypes#number) "
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "red"
                        },
                        {
                          "name": "green"
                        },
                        {
                          "name": "blue"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>参数后的 &quot;{}&quot; 内包含其类型.<br>上述示例表示需要传入三个 <a href=\"dataTypes#number\">number</a> 类型的参数.<br>如 colors.rgb(255, 128, 64) 合法, 而 colors.rgb(&quot;abc&quot;, 128, 64) 将可能导致非预期结果或出现异常.</p>\n<blockquote>\n<p>注: 点击类型对应的超链接 (如有) 可跳转至类型详情页面.</p>\n</blockquote>\n"
                }
              ],
              "type": "module",
              "displayName": "参数类型"
            },
            {
              "textRaw": "返回值类型",
              "name": "返回值类型",
              "methods": [
                {
                  "textRaw": "colors.rgb(red, green, blue)",
                  "type": "method",
                  "name": "rgb",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "**red** { [number](dataTypes#number) } ",
                          "name": "**red**",
                          "type": " [number](dataTypes#number) "
                        },
                        {
                          "textRaw": "**green** { [number](dataTypes#number) } ",
                          "name": "**green**",
                          "type": " [number](dataTypes#number) "
                        },
                        {
                          "textRaw": "**blue** { [number](dataTypes#number) } ",
                          "name": "**blue**",
                          "type": " [number](dataTypes#number) "
                        },
                        {
                          "textRaw": "<ins>**returns**</ins> { [number](dataTypes#number) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [number](dataTypes#number) "
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "red"
                        },
                        {
                          "name": "green"
                        },
                        {
                          "name": "blue"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>returns 后的 &quot;{}&quot; 内包含返回值类型.<br>上述示例表示 colors.rgb 方法调用后将返回 <a href=\"dataTypes#number\">number</a> 类型数据.</p>\n"
                }
              ],
              "type": "module",
              "displayName": "返回值类型"
            },
            {
              "textRaw": "属性类型",
              "name": "属性类型",
              "properties": [
                {
                  "textRaw": "`RED` { [number](dataTypes#number) } ",
                  "type": " [number](dataTypes#number) ",
                  "name": "RED",
                  "desc": "<p>属性类型包裹在一对花括号中.<br>上述示例表示 colors 的 RED 属性是 <a href=\"dataTypes#number\">number</a> 类型数据.</p>\n<p>对象字面量形式的类型则用一对双花括号表示:</p>\n<ul>\n<li>{{ name: <a href=\"dataTypes#string\">string</a>; age: <a href=\"dataTypes#number\">number</a> }}</li>\n</ul>\n<p>多行形式:</p>\n<ul>\n<li>{{</li>\n<li>-- name: <a href=\"dataTypes#string\">string</a>;</li>\n<li>-- age: <a href=\"dataTypes#number\">number</a>;</li>\n<li>}}</li>\n</ul>\n<p>一个符合上述示例期望的变量:</p>\n<pre><code class=\"lang-js\">let o = { name: &quot;David&quot;, age: 13 };\n</code></pre>\n<p>可存取的属性在读取时如果有非 undefined 默认值, 则以一对方括号表示:</p>\n<ul>\n<li>[ 1200 ] { <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>上述示例表示一个默认值为 1200 的可存取属性.</p>\n<p>以一对双方括号表示常量:</p>\n<ul>\n<li>[[ 0.5 ]] { <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>上述示例表示一个值为 0.5 的常量属性.</p>\n"
                }
              ],
              "type": "module",
              "displayName": "属性类型"
            },
            {
              "textRaw": "方法签名",
              "name": "方法签名",
              "desc": "<p>形如上述 <a href=\"#返回值类型\">返回值类型</a> 小节的示例,<br>包含 [ 方法名称 + 参数类型 + 返回值类型 ] 的标志符, 称为 &quot;方法签名&quot;.</p>\n<blockquote>\n<p>注: 上述 &quot;方法签名&quot; 定义只用于辅助读者对文档的理解, 并不保证名词解释的合理性.</p>\n</blockquote>\n",
              "type": "module",
              "displayName": "方法签名"
            },
            {
              "textRaw": "方法描述",
              "name": "方法描述",
              "methods": [
                {
                  "textRaw": "colors.rgb(red, green, blue)",
                  "type": "method",
                  "name": "rgb",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "__red__ - R (红色) 通道数值  [ A ] ",
                          "name": "__red__",
                          "desc": "R (红色) 通道数值  [ A ]"
                        },
                        {
                          "textRaw": "__green__ - G (绿色) 通道数值  [ A ] ",
                          "name": "__green__",
                          "desc": "G (绿色) 通道数值  [ A ]"
                        },
                        {
                          "textRaw": "__blue__ - B (蓝色) 通道数值  [ A ] ",
                          "name": "__blue__",
                          "desc": "B (蓝色) 通道数值  [ A ]"
                        },
                        {
                          "textRaw": "__@return__ - 颜色数值  [ B ] ",
                          "name": "__@return__",
                          "desc": "颜色数值  [ B ]"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "red"
                        },
                        {
                          "name": "green"
                        },
                        {
                          "name": "blue"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>获取 R/G/B 通道组合后的颜色数值. [ C ]</p>\n<pre><code class=\"lang-js\">[ D ]\ncolors.rgb(255, 128, 64); // -32704\ncolors.rgb(255, 128, 64) === 0xFFFF8040 - Math.pow(2, 32); // true\ncolors.rgb(255, 128, 64) === colors.toInt(&quot;#FFFF8040&quot;); // true\ncolors.rgb(255, 128, 64) === colors.toInt(&quot;#FF8040&quot;); // true\n</code></pre>\n<p>上述示例包含的字母标注含义:</p>\n<ul>\n<li>[ A ] - 参数描述</li>\n<li>[ B ] - 方法返回值描述</li>\n<li>[ C ] - 方法描述</li>\n<li>[ D ] - 方法使用示例</li>\n</ul>\n"
                }
              ],
              "type": "module",
              "displayName": "方法描述"
            },
            {
              "textRaw": "可变参数",
              "name": "可变参数",
              "methods": [
                {
                  "textRaw": "files.join(parent, ...child)",
                  "type": "method",
                  "name": "join",
                  "desc": "<p>上述示例的 child 参数是 &quot;可变参数&quot;, 也称为 &quot;可变长参数&quot; 或 &quot;变长参数&quot;.<br>可变参数可传入任意个 (包括 0 个) 参数:</p>\n<pre><code class=\"lang-js\">let p = files.getSdcardPath();\nfiles.join(p); /* 0 个可变参数 */\nfiles.join(p, &#39;a&#39;); /* 1 个可变参数 */\nfiles.join(p, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); /* 4 个可变参数 */\n</code></pre>\n<p>文档采用 JSDoc 标准标注可变参数, 需额外注意 JSDoc 的尾数组标识代表容器, 用于容纳展开后的参数:</p>\n<pre><code class=\"lang-js\">/**\n * @param {number} x\n * @param {number} y\n * @param {...number[]} others\n */\nfunction sum(x, y, others) {\n    /* ... */\n}\n</code></pre>\n<p>上述示例 others 参数为可变参数, 其中 &quot;...number[]&quot; 代表 others 期望的参数类型为 number, 而非 number[], 最后的 &quot;[]&quot; 代表 &quot;...&quot; 的容器, &quot;...&quot; 与 &quot;[]&quot; 是配对出现的.</p>\n<pre><code class=\"lang-js\">/**\n * @param {number} x\n * @param {number} y\n * @param {...number[][]} others\n */\nfunction sum(x, y, others) {\n    /* ... */\n}\n</code></pre>\n<p>上述示例 others 期望的参数类型为 number[], 而非 number[][], 同样最后的 &quot;[]&quot; 代表 &quot;...&quot; 的容器.</p>\n<pre><code class=\"lang-js\">/**\n * @param {number} x\n * @param {number} y\n * @param {...number} others\n */\nfunction sum(x, y, others) {\n    /* ... */\n}\n</code></pre>\n<p>上述示例 others 的参数类型标识方法 &quot;...number&quot; 也是合法的, 它其实是 &quot;...number[]&quot; 的省略形式.<br>文档为了避免歧义, 将全部采用完整写法.</p>\n<p>作为强调, &quot;...(SomeType)[]&quot; 这样的可变参数表示方法, 需要把 &quot;...&quot; 和 &quot;[]&quot; 视为一个整体, 中间部分才是期望的参数类型.</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "parent"
                        },
                        {
                          "name": "...child"
                        }
                      ]
                    }
                  ]
                }
              ],
              "type": "module",
              "displayName": "可变参数"
            },
            {
              "textRaw": "可选参数",
              "name": "可选参数",
              "methods": [
                {
                  "textRaw": "device.vibrate(text, delay?)",
                  "type": "method",
                  "name": "vibrate",
                  "desc": "<p>上述示例的 delay 参数是可选的 (以 &quot;?&quot; 标注).<br>因此以下调用方式均被支持:</p>\n<pre><code class=\"lang-js\">device.vibrate(&quot;hello&quot;, 2e3); /* 两秒钟延迟. */\ndevice.vibrate(&quot;hello&quot;); /* 无延迟. */\n</code></pre>\n<p>可选参数描述时会以 &quot;[]&quot; 标注:</p>\n<ul>\n<li><strong>[ delay ]</strong> { <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>如果可选参数包含默认值, 则会以 &quot;=&quot; 标注:</p>\n<ul>\n<li><strong>[ delay = 0 ]</strong> { <a href=\"dataTypes#number\">number</a> }</li>\n</ul>\n<p>详见下述 <a href=\"#参数默认值\">参数默认值</a></p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "text"
                        },
                        {
                          "name": "delay?"
                        }
                      ]
                    }
                  ]
                }
              ],
              "type": "module",
              "displayName": "可选参数"
            },
            {
              "textRaw": "参数默认值",
              "name": "参数默认值",
              "methods": [
                {
                  "textRaw": "device.vibrate(text, delay?)",
                  "type": "method",
                  "name": "vibrate",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "**text** { [string](dataTypes#string) } - 需转换为摩斯码的文本 ",
                          "name": "**text**",
                          "type": " [string](dataTypes#string) ",
                          "desc": "需转换为摩斯码的文本"
                        },
                        {
                          "textRaw": "**[ delay = 0 ]** { [number](dataTypes#number) } - 震动延迟 ",
                          "name": "**[",
                          "desc": "delay = 0 ]** { [number](dataTypes#number) } - 震动延迟"
                        },
                        {
                          "textRaw": "<ins>**returns**</ins> { [void](dataTypes#void) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [void](dataTypes#void) "
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "text"
                        },
                        {
                          "name": "delay?"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>上述示例的 delay 参数是可选的 (以 &quot;?&quot; 标注) 且包含默认值 (以 &quot;=&quot; 标注).<br>因此以下两种调用方式等效:</p>\n<pre><code class=\"lang-js\">device.vibrate(&quot;hello&quot;);\ndevice.vibrate(&quot;hello&quot;, 0);\n</code></pre>\n<blockquote>\n<p>注: 上述示例的方法签名 (含默认值标注) 在 TypeScript 中并不合法, 此类签名仅限在文档中使用.</p>\n<p>注: 以 &quot;=&quot; 标注的参数一定是可选的, 此时参数的 &quot;?&quot; 标注可能被省略, 尤其在重载签名拆写的情况下.<br>详情参阅下文的 &quot;方法重载&quot;.</p>\n</blockquote>\n"
                }
              ],
              "type": "module",
              "displayName": "参数默认值"
            },
            {
              "textRaw": "方法重载",
              "name": "方法重载",
              "desc": "<p><strong><code>Overload 1/17</code></strong></p>\n",
              "methods": [
                {
                  "textRaw": "pickup(selector, compass, resultType)",
                  "type": "method",
                  "name": "pickup",
                  "desc": "<p><strong><code>Overload 2/17</code></strong></p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "selector"
                        },
                        {
                          "name": "compass"
                        },
                        {
                          "name": "resultType"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "pickup(selector, compass)",
                  "type": "method",
                  "name": "pickup",
                  "desc": "<p><strong><code>Overload 3/17</code></strong></p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "selector"
                        },
                        {
                          "name": "compass"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "pickup(selector, resultType)",
                  "type": "method",
                  "name": "pickup",
                  "desc": "<p>... ...</p>\n<p><strong><code>Overload 16/17</code></strong></p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "selector"
                        },
                        {
                          "name": "resultType"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "pickup(root, selector)",
                  "type": "method",
                  "name": "pickup",
                  "desc": "<p><strong><code>Overload 17/17</code></strong></p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "root"
                        },
                        {
                          "name": "selector"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "pickup()",
                  "type": "method",
                  "name": "pickup",
                  "desc": "<p>包含 &quot;Overload m/n&quot; 标签的方法, 表示重载方法的序数及总量.<br>如 &quot;Overload 2/3&quot; 表示当前方法签名描述第 2 个重载方法, 总计 3 个,<br>而 &quot;Overload 5-6/17&quot; 表示当前方法签名涵盖第 5 及 第 6 个重载方法, 总计 17 个.</p>\n<p>重载方法可被简化:</p>\n<pre><code class=\"lang-text\">/* 拆写. */\ndevice.vibrate(text)\ndevice.vibrate(text, delay)\n\n/* 合写 (简化). */\ndevice.vibrate(text, delay?)\n\n/* 可选参数通常会标注默认值. */\ndevice.vibrate(text, delay?)\n· [ delay = 0 ] { number }\n\n/* 即使没有 &quot;?&quot; 标注 (针对拆写). */\ndevice.vibrate(text, delay)\n· [ delay = 0 ] { number }\n</code></pre>\n<p>多数情况下, 文档采用拆写的方式描述重载方法.</p>\n",
                  "signatures": [
                    {
                      "params": []
                    }
                  ]
                }
              ],
              "type": "module",
              "displayName": "方法重载"
            },
            {
              "textRaw": "方法全局化",
              "name": "方法全局化",
              "desc": "<p><strong><code>Global</code></strong></p>\n",
              "methods": [
                {
                  "textRaw": "images.requestScreenCapture(landscape)",
                  "type": "method",
                  "name": "requestScreenCapture",
                  "desc": "<p>包含 &quot;Global&quot; 标签的方法, 表示支持全局化使用, 可省略模块对象调用.<br>因此以下两种调用方式等效:</p>\n<pre><code class=\"lang-js\">images.requestScreenCapture(false);\nrequestScreenCapture(false);\n</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "landscape"
                        }
                      ]
                    }
                  ]
                }
              ],
              "type": "module",
              "displayName": "方法全局化"
            },
            {
              "textRaw": "方法标签",
              "name": "方法标签",
              "desc": "<p>用于简便表示方法的特性:</p>\n<ul>\n<li><code>Global</code>: <a href=\"#方法全局化\">方法全局化</a> (可省略模块对象直接调用).</li>\n<li><code>Overload 2/3</code>: <a href=\"#方法重载\">方法重载</a> [ 第 2 个, 共 3 个 ].</li>\n<li><code>Non-UI</code>: 方法不能在 UI 模式下调用.</li>\n<li><code>6.2.0</code>: 方法对 AutoJs6 的版本要求 [ 不低于 6.2.0 ].</li>\n<li><code>[6.2.0]</code>: 与原同名方法相比, 方法的功能, 结果, 签名或使用方式发生变更的起始版本.</li>\n<li><code>API&gt;=29</code>: 方法对 <a href=\"apiLevel\">API 级别</a> 的要求 [ 不低于 29 ], 当不满足时不抛出异常.</li>\n<li><code>API&gt;=29!</code>: 方法对 <a href=\"apiLevel\">API 级别</a> 的要求 [ 不低于 29 ], 当不满足时将抛出异常.</li>\n<li><code>A11Y</code>: 方法依赖无障碍服务.</li>\n<li><code>A11Y?</code>: 方法可能会依赖无障碍服务.</li>\n<li><code>Async</code>: 异步执行的方法.</li>\n<li><code>Async?</code>: 可能异步执行的方法 (通过参数控制).</li>\n<li><code>Enum</code>: 枚举类.</li>\n<li><code>CONSTANT</code>: 常量.</li>\n<li><code>DEPRECATED</code>: 已弃用的属性或方法.</li>\n<li><code>xProto</code>: 针对原型的内置对象扩展.</li>\n<li><code>xObject</code>: 针对对象的内置对象扩展.</li>\n<li><code>xAlias</code>: 内置对象扩展时使用不同的方法或属性名称 (别名).</li>\n</ul>\n",
              "type": "module",
              "displayName": "方法标签"
            },
            {
              "textRaw": "对象标签",
              "name": "对象标签",
              "desc": "<p>用于简便表示对象的属性:</p>\n<ul>\n<li>[m]: 普通对象方法或类静态成员方法.<ul>\n<li>例如在 <code>images</code> 作为 <a href=\"#临时作用域对象\">临时作用域对象</a> 时:</li>\n<li><code>[m] captureScreen</code> 代表 <code>images.captureScreen</code> 方法.</li>\n</ul>\n</li>\n<li>[m+]: 具有扩展属性的对象方法.<ul>\n<li>如 auto 本身是一个方法 (或称函数), waitFor 是 auto 的一个扩展方法.</li>\n<li>以下两种调用方式均可用: <code>auto()</code> 及 <code>auto.waitFor()</code>.</li>\n</ul>\n</li>\n<li>[p]: 属性.<ul>\n<li>例如在 <code>device</code> 作为 <a href=\"#临时作用域对象\">临时作用域对象</a> 时:</li>\n<li><code>[p] height</code> 代表 <code>device.height</code> 属性, 而非方法.</li>\n<li>此标签对 [ Getter / Setter / &quot;类&quot; 属性 / 对象属性 / 方法扩展属性 ] 等不作区分.</li>\n</ul>\n</li>\n<li>[I]: Java 接口.</li>\n<li>[C]: Java 类或 JavaScript 构造函数.</li>\n<li>[c]: Java 类的构造方法.</li>\n<li>[m!]: 抽象方法 (针对接口及抽象类).</li>\n<li>[m=]: 包含默认实现的抽象方法 (针对接口).</li>\n<li>[m#]: 类的实例成员方法.<ul>\n<li>类的静态成员方法用 [m] 标签标记.</li>\n<li>例如对于类 <code>B</code>, 它有一个实例 <code>b</code> (可能通过 <code>new B()</code> 等方式获得),</li>\n<li><code>[m#] foo</code> 和 <code>[m] bar</code> 的调用方式分别为</li>\n<li><code>b.foo()</code> 和 <code>B.bar()</code>.</li>\n</ul>\n</li>\n<li>[p#]: 类的实例成员属性.<ul>\n<li>类的静态成员属性依然用 [p] 标签标记.</li>\n<li>例如对于类 <code>F</code>, 它有一个实例 <code>f</code> (可能通过 <code>new F()</code> 等方式获得),</li>\n<li><code>[p#] foo</code> 和 <code>[p] bar</code> 的调用方式分别为</li>\n<li><code>f.foo</code> 和 <code>F.bar</code>.</li>\n</ul>\n</li>\n<li>[@]: 代表 <a href=\"#临时作用域对象\">临时作用域对象</a> 自身.<ul>\n<li>例如在同一个章节中<ul>\n<li><code>[@] apple</code> [1]</li>\n<li><code>apple(c)</code> [2]</li>\n<li><code>[m] getColor</code> [3]</li>\n<li><code>getColor()</code> [4]</li>\n<li><code>[@] banana</code> [5]</li>\n<li><code>[m] banana</code> [6]</li>\n<li><code>banana(x)</code> [7]</li>\n<li><code>banana(x, y)</code> [8]</li>\n</ul>\n</li>\n<li>这个章节有两个 <a href=\"#临时作用域对象\">临时作用域对象</a>, apple 和 banana, 对应 <code>[1]</code> 和 <code>[5]</code>.</li>\n<li><code>[2]</code> 代表 apple 自身可被调用, 且调用方式为 <code>apple(c)</code>, 其中 &quot;c&quot; 为参数.</li>\n<li><code>[3]</code> 代表 apple 的一个方法, 名称为 &quot;getColor&quot;,</li>\n<li>由 <code>[4]</code> 得知, 其调用方式为 <code>apple.getColor()</code>.</li>\n<li>注意 <code>[6]</code> 与 <code>[2]</code> 不同:</li>\n<li>[<code>6</code>] 代表 banana 的一个方法, 名称为 &quot;banana&quot;,</li>\n<li>由 <code>[7]</code> 和 <code>[8]</code> 得知, 其调用方式有两种,</li>\n<li><code>banana.banana(x)</code> 和 <code>banana.banana(x, y)</code>.</li>\n</ul>\n</li>\n</ul>\n",
              "type": "module",
              "displayName": "对象标签"
            },
            {
              "textRaw": "成员访问",
              "name": "成员访问",
              "desc": "<p>成员访问用 &quot;.&quot; 表示调用关系, 包括 &quot;类&quot; 静态成员访问, 对象成员访问等.<br>而实例成员访问则需要 &quot;类&quot; 的实例才能访问, 用 &quot;#&quot; 表示调用关系.<br>例如 JavaScript 的 Number 本身是一个 &quot;类&quot;, 可用的成员访问方式如下:</p>\n<pre><code class=\"lang-js\">Number(2); /* 作为普通函数使用, 无成员访问. */\nNumber.EPSILON; /* &quot;类&quot; 静态成员访问, 用 &quot;Number.EPSILON&quot; 标识, 标签为 &quot;[p]&quot;. */\nnew Number(2); /* 创建 &quot;类&quot; 实例, 无成员访问. */\nnew Number(2).toFixed(0); /* 实例成员访问, 用 &quot;Number#toFixed(number)&quot; 标识, 标签为 &quot;[m#]&quot;. */\n</code></pre>\n<p>实例成员访问示例:</p>\n<p style=\"font: bold 1em sans-serif; color: #FF7043\">UiObject</p>\n\n<p>[m#] bounds()</p>\n<pre><code class=\"lang-js\">/* 正确访问示例 */\n\nlet w = pickup(/.+/); /* w 是 UiObject 的实例. */\nif (w !== null) {\n    console.log(w.bounds()); /* 访问 UiObject 实例的 bounds 方法. */\n}\n\n/* 错误访问示例 */\n\nimportClass(org.autojs.autojs.core.automator.UiObject);\nconsole.log(UiObject.bounds()); /* 访问的是类 UiObject 的静态方法 bounds. */\n</code></pre>\n",
              "type": "module",
              "displayName": "成员访问"
            },
            {
              "textRaw": "模板参数",
              "name": "模板参数",
              "methods": [
                {
                  "textRaw": "foo.bar(a, b)",
                  "type": "method",
                  "name": "bar",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "**a** { [T](dataTypes#generic) } ",
                          "name": "**a**",
                          "type": " [T](dataTypes#generic) "
                        },
                        {
                          "textRaw": "**b** { [number](dataTypes#number) } ",
                          "name": "**b**",
                          "type": " [number](dataTypes#number) "
                        },
                        {
                          "textRaw": "<ins>**returns**</ins> { [T](dataTypes#generic) } ",
                          "name": "<ins>**returns**</ins>",
                          "type": " [T](dataTypes#generic) "
                        },
                        {
                          "textRaw": "<ins>**template**</ins> { [T](dataTypes#generic) } ",
                          "name": "<ins>**template**</ins>",
                          "type": " [T](dataTypes#generic) "
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "a"
                        },
                        {
                          "name": "b"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>returns 后的 &quot;{}&quot; 内包含返回值类型.<br>上述示例表示 colors.rgb 方法调用后将返回 <a href=\"dataTypes#number\">number</a> 类型数据.</p>\n<blockquote>\n<p>参阅: <a href=\"dataTypes#generic\">泛型</a></p>\n</blockquote>\n"
                }
              ],
              "type": "module",
              "displayName": "模板参数"
            }
          ],
          "type": "misc",
          "displayName": "文档阅读示例"
        },
        {
          "textRaw": "声明",
          "name": "声明",
          "desc": "<p>当前项目 (文档) 及 <a href=\"https://github.com/SuperMonster003/AutoJs6/\">AutoJs6</a> (App) 均为二次开发.<br>相对于 <a href=\"https://github.com/hyb1996/Auto.js/\">原始 App</a>, 二次开发的 App 中会增加或修改部分模块功能.<br>相对于 <a href=\"https://github.com/hyb1996/AutoJs-Docs/\">原始文档</a>, 二次开发的文档将进行部分增删或重新编写.<br>开发者无法保证对 API 的完全理解及文档的无纰漏撰写.<br>如有任何不当之处, 欢迎提交 <a href=\"https://github.com/SuperMonster003/AutoJs6-Documentation/issues/\">Issue</a> 或 <a href=\"https://github.com/SuperMonster003/AutoJs6-Documentation/pulls/\">PR</a>.<br><!-- [end-include:documentation.md] --></p>\n<!-- [start-include:qa.md] -->\n",
          "type": "misc",
          "displayName": "声明"
        }
      ]
    }
  ],
  "properties": [
    {
      "textRaw": "安卓7.0以上的触摸和手势模拟",
      "type": "property",
      "name": "0以上的触摸和手势模拟",
      "desc": "<p><strong>注意以下命令只有Android7.0及以上才有效</strong></p>\n",
      "methods": [
        {
          "textRaw": "click(x, y)",
          "type": "method",
          "name": "click",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 要点击的坐标的x值 ",
                  "name": "x",
                  "type": "number",
                  "desc": "要点击的坐标的x值"
                },
                {
                  "textRaw": "`y` {number} 要点击的坐标的y值 ",
                  "name": "y",
                  "type": "number",
                  "desc": "要点击的坐标的y值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ],
          "desc": "<p>模拟点击坐标(x, y), 并返回是否点击成功. 只有在点击执行完成后脚本才继续执行.</p>\n<p>一般而言, 只有点击过程(大约150毫秒)中被其他事件中断(例如用户自行点击)才会点击失败.</p>\n<p>使用该函数模拟连续点击时可能有点击速度过慢的问题, 这时可以用<code>press()</code>函数代替.</p>\n"
        },
        {
          "textRaw": "longClick(x, y)",
          "type": "method",
          "name": "longClick",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 要长按的坐标的x值 ",
                  "name": "x",
                  "type": "number",
                  "desc": "要长按的坐标的x值"
                },
                {
                  "textRaw": "`y` {number} 要长按的坐标的y值 ",
                  "name": "y",
                  "type": "number",
                  "desc": "要长按的坐标的y值"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ],
          "desc": "<p>模拟长按坐标(x, y), 并返回是否成功. 只有在长按执行完成（大约600毫秒）时脚本才会继续执行.</p>\n<p>一般而言, 只有长按过程中被其他事件中断(例如用户自行点击)才会长按失败.</p>\n"
        },
        {
          "textRaw": "press(x, y, duration)",
          "type": "method",
          "name": "press",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x` {number} 要按住的坐标的x值 ",
                  "name": "x",
                  "type": "number",
                  "desc": "要按住的坐标的x值"
                },
                {
                  "textRaw": "`y` {number} 要按住的坐标的y值 ",
                  "name": "y",
                  "type": "number",
                  "desc": "要按住的坐标的y值"
                },
                {
                  "textRaw": "`duration` {number} 按住时长, 单位毫秒 ",
                  "name": "duration",
                  "type": "number",
                  "desc": "按住时长, 单位毫秒"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x"
                },
                {
                  "name": "y"
                },
                {
                  "name": "duration"
                }
              ]
            }
          ],
          "desc": "<p>模拟按住坐标(x, y), 并返回是否成功. 只有按住操作执行完成时脚本才会继续执行.</p>\n<p>如果按住时间过短, 那么会被系统认为是点击；如果时长超过500毫秒, 则认为是长按.</p>\n<p>一般而言, 只有按住过程中被其他事件中断才会操作失败.</p>\n<p>一个连点器的例子如下：</p>\n<pre><code>//循环100次\nfor(var i = 0; i &lt; 100; i++){\n  //点击位置(500, 1000), 每次用时1毫秒\n  press(500, 1000, 1);\n}\n</code></pre>"
        },
        {
          "textRaw": "swipe(x1, y1, x2, y2, duration)",
          "type": "method",
          "name": "swipe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`x1` {number} 滑动的起始坐标的x值 ",
                  "name": "x1",
                  "type": "number",
                  "desc": "滑动的起始坐标的x值"
                },
                {
                  "textRaw": "`y1` {number} 滑动的起始坐标的y值 ",
                  "name": "y1",
                  "type": "number",
                  "desc": "滑动的起始坐标的y值"
                },
                {
                  "textRaw": "`x2` {number} 滑动的结束坐标的x值 ",
                  "name": "x2",
                  "type": "number",
                  "desc": "滑动的结束坐标的x值"
                },
                {
                  "textRaw": "`y2` {number} 滑动的结束坐标的y值 ",
                  "name": "y2",
                  "type": "number",
                  "desc": "滑动的结束坐标的y值"
                },
                {
                  "textRaw": "`duration` {number} 滑动时长, 单位毫秒 ",
                  "name": "duration",
                  "type": "number",
                  "desc": "滑动时长, 单位毫秒"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "x1"
                },
                {
                  "name": "y1"
                },
                {
                  "name": "x2"
                },
                {
                  "name": "y2"
                },
                {
                  "name": "duration"
                }
              ]
            }
          ],
          "desc": "<p>模拟从坐标(x1, y1)滑动到坐标(x2, y2), 并返回是否成功. 只有滑动操作执行完成时脚本才会继续执行.</p>\n<p>一般而言, 只有滑动过程中被其他事件中断才会滑动失败.</p>\n"
        },
        {
          "textRaw": "gesture(duration, [x1, y1], [x2, y2], ...)",
          "type": "method",
          "name": "gesture",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`duration` {number} 手势的时长 ",
                  "name": "duration",
                  "type": "number",
                  "desc": "手势的时长"
                },
                {
                  "textRaw": "[x, y] ... 手势滑动路径的一系列坐标 ",
                  "name": "[x,",
                  "desc": "y] ... 手势滑动路径的一系列坐标",
                  "optional": true
                },
                {
                  "name": "y1",
                  "optional": true
                },
                {
                  "name": "x2",
                  "optional": true
                },
                {
                  "name": "y2",
                  "optional": true
                },
                {
                  "name": "..."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "duration"
                },
                {
                  "name": "x1",
                  "optional": true
                },
                {
                  "name": "y1",
                  "optional": true
                },
                {
                  "name": "x2",
                  "optional": true
                },
                {
                  "name": "y2",
                  "optional": true
                },
                {
                  "name": "..."
                }
              ]
            }
          ],
          "desc": "<p>模拟手势操作. 例如<code>gesture(1000, [0, 0], [500, 500], [500, 1000])</code>为模拟一个从(0, 0)到(500, 500)到(500, 100)的手势操作, 时长为2秒.</p>\n"
        },
        {
          "textRaw": "gestures([delay1, duration1, [x1, y1], [x2, y2], ...], [delay2, duration2, [x3, y3], [x4, y4], ...], ...)",
          "type": "method",
          "name": "gestures",
          "desc": "<p>同时模拟多个手势. 每个手势的参数为[delay, duration, 坐标], delay为延迟多久(毫秒)才执行该手势；duration为手势执行时长；坐标为手势经过的点的坐标. 其中delay参数可以省略, 默认为0.</p>\n<p>例如手指捏合：</p>\n<pre><code>gestures([0, 500, [800, 300], [500, 1000]],\n         [0, 500, [300, 1500], [500, 1000]]);\n</code></pre>",
          "signatures": [
            {
              "params": [
                {
                  "name": "delay1",
                  "optional": true
                },
                {
                  "name": "duration1",
                  "optional": true
                },
                {
                  "name": "x1",
                  "optional": true
                },
                {
                  "name": "y1",
                  "optional": true
                },
                {
                  "name": "x2",
                  "optional": true
                },
                {
                  "name": "y2",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                },
                {
                  "name": "delay2",
                  "optional": true
                },
                {
                  "name": "duration2",
                  "optional": true
                },
                {
                  "name": "x3",
                  "optional": true
                },
                {
                  "name": "y3",
                  "optional": true
                },
                {
                  "name": "x4",
                  "optional": true
                },
                {
                  "name": "y4",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                },
                {
                  "name": "..."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "textRaw": "colors.BLACK",
      "type": "property",
      "name": "BLACK",
      "desc": "<p>黑色, 颜色值 #FF000000</p>\n"
    },
    {
      "textRaw": "colors.DKGRAY",
      "type": "property",
      "name": "DKGRAY",
      "desc": "<p>深灰色, 颜色值 #FF444444</p>\n"
    },
    {
      "textRaw": "colors.GRAY",
      "type": "property",
      "name": "GRAY",
      "desc": "<p>灰色, 颜色值 #FF888888</p>\n"
    },
    {
      "textRaw": "colors.LTGRAY",
      "type": "property",
      "name": "LTGRAY",
      "desc": "<p>亮灰色, 颜色值 #FFCCCCCC</p>\n"
    },
    {
      "textRaw": "colors.WHITE",
      "type": "property",
      "name": "WHITE",
      "desc": "<p>白色, 颜色值 #FFFFFFFF</p>\n"
    },
    {
      "textRaw": "colors.RED",
      "type": "property",
      "name": "RED",
      "desc": "<p>红色, 颜色值 #FFFF0000</p>\n"
    },
    {
      "textRaw": "colors.GREEN",
      "type": "property",
      "name": "GREEN",
      "desc": "<p>绿色, 颜色值 #FF00FF00</p>\n"
    },
    {
      "textRaw": "colors.BLUE",
      "type": "property",
      "name": "BLUE",
      "desc": "<p>蓝色, 颜色值 #FF0000FF</p>\n"
    },
    {
      "textRaw": "colors.YELLOW",
      "type": "property",
      "name": "YELLOW",
      "desc": "<p>黄色, 颜色值 #FFFFFF00</p>\n"
    },
    {
      "textRaw": "colors.CYAN",
      "type": "property",
      "name": "CYAN",
      "desc": "<p>青色, 颜色值 #FF00FFFF</p>\n"
    },
    {
      "textRaw": "colors.MAGENTA",
      "type": "property",
      "name": "MAGENTA",
      "desc": "<p>品红色, 颜色值 #FFFF00FF</p>\n"
    },
    {
      "textRaw": "colors.TRANSPARENT",
      "type": "property",
      "name": "TRANSPARENT",
      "desc": "<p>透明, 颜色值 #00000000\n<!-- [end-include:color.md] --></p>\n<!-- [start-include:image.md] -->\n"
    }
  ],
  "methods": [
    {
      "textRaw": "ui.registerWidget(name, widget)",
      "type": "method",
      "name": "registerWidget",
      "signatures": [
        {
          "params": [
            {
              "textRaw": "`name` {string} 组件名称 ",
              "name": "name",
              "type": "string",
              "desc": "组件名称"
            },
            {
              "textRaw": "`widget` {Function} 组件 ",
              "name": "widget",
              "type": "Function",
              "desc": "组件"
            }
          ]
        },
        {
          "params": [
            {
              "name": "name"
            },
            {
              "name": "widget"
            }
          ]
        }
      ],
      "desc": "<p>注册一个自定义组件. 参考示例-&gt;界面控件-&gt;自定义控件.</p>\n"
    },
    {
      "textRaw": "ui.isUiThread()",
      "type": "method",
      "name": "isUiThread",
      "signatures": [
        {
          "params": [
            {
              "textRaw": "返回 {boolean} ",
              "name": "返回",
              "type": "boolean"
            }
          ]
        },
        {
          "params": []
        }
      ],
      "desc": "<p>返回当前线程是否是UI线程.</p>\n<pre><code class=\"lang-javascript\">&quot;ui&quot;;\n\nlog($ui.isUiThread()); // =&gt; true\n\n$threads.start(function () {\n    log($ui.isUiThread()); // =&gt; false\n});\n\n</code></pre>\n",
      "methods": [
        {
          "textRaw": "ui.findView(id)",
          "type": "method",
          "name": "findView",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`id` {string} View的ID ",
                  "name": "id",
                  "type": "string",
                  "desc": "View的ID"
                },
                {
                  "textRaw": "返回 {View} ",
                  "name": "返回",
                  "type": "View"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ],
          "desc": "<p>在当前视图中根据ID查找相应的视图对象并返回. 如果当前未设置视图或找不到此ID的视图时返回<code>null</code>.</p>\n<p>一般我们都是通过<code>ui.xxx</code>来获取id为xxx的控件, 如果xxx是一个ui已经有的属性, 就可以通过<code>$ui.findView()</code>来获取这个控件.</p>\n"
        },
        {
          "textRaw": "ui.finish()",
          "type": "method",
          "name": "finish",
          "desc": "<p>结束当前活动并销毁界面.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "ui.setContentView(view)",
          "type": "method",
          "name": "setContentView",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`view` {View} ",
                  "name": "view",
                  "type": "View"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "view"
                }
              ]
            }
          ],
          "desc": "<p>将视图对象设置为当前视图.</p>\n"
        },
        {
          "textRaw": "ui.post(callback[, delay = 0])",
          "type": "method",
          "name": "post",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`callback` {Function} 回调函数 ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数"
                },
                {
                  "textRaw": "`delay` {number} 延迟, 单位毫秒 ",
                  "name": "delay",
                  "type": "number",
                  "desc": "延迟, 单位毫秒",
                  "optional": true,
                  "default": " 0"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay ",
                  "optional": true,
                  "default": " 0"
                }
              ]
            }
          ],
          "desc": "<p>将<code>callback</code>加到UI线程的消息循环中, 并延迟delay毫秒后执行（不能准确保证一定在delay毫秒后执行）.</p>\n<p>此函数可以用于UI线程中延时执行动作（sleep不能在UI线程中使用）, 也可以用于子线程中更新UI.</p>\n<pre><code class=\"lang-javascript\">&quot;ui&quot;;\n\nui.layout(\n    &lt;frame&gt;\n        &lt;text id=&quot;result&quot;/&gt;\n    &lt;/frame&gt;\n);\n\nui.result.attr(&quot;text&quot;, &quot;计算中&quot;);\n// 在子线程中计算1+ ... + 10000000\nthreads.start({\n    let sum = 0;\n    for (let i = 0; i &lt; 1000000; i++) {\n        sum += i;\n    }\n    // 由于不能在子线程操作UI, 所以要抛到UI线程执行\n    ui.post(() =&gt; {\n        ui.result.attr(&quot;text&quot;, String(sum));\n    });\n});\n</code></pre>\n"
        },
        {
          "textRaw": "ui.run(callback)",
          "type": "method",
          "name": "run",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`callback` {Function} 回调函数 ",
                  "name": "callback",
                  "type": "Function",
                  "desc": "回调函数"
                },
                {
                  "textRaw": "返回 callback的执行结果 ",
                  "name": "返回",
                  "desc": "callback的执行结果"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>将<code>callback</code>在UI线程中执行. 如果当前已经在UI线程中, 则直接执行<code>callback</code>\b\b；否则将<code>callback</code>抛到UI线程中执行（加到UI线程的消息循环的末尾）, <strong>并等待callback执行结束(阻塞当前线程)</strong>.</p>\n"
        },
        {
          "textRaw": "ui.statusBarColor(color)",
          "type": "method",
          "name": "statusBarColor",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "color {string} | {number} 颜色 ",
                  "name": "color",
                  "type": "string",
                  "desc": "| {number} 颜色"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "color"
                }
              ]
            }
          ],
          "desc": "<p>设置当前界面的状态栏颜色.</p>\n<pre><code class=\"lang-javascript\">&quot;ui&quot;;\nui.statusBarColor(&quot;#000000&quot;);\n</code></pre>\n"
        },
        {
          "textRaw": "ui.useAndroidResources()",
          "type": "method",
          "name": "useAndroidResources",
          "desc": "<p>启用使用Android的布局(layout)、绘图(drawable)、动画(anim)、样式(style)等资源的特性. 启用该特性后, 在project.json中进行以下配置, 就可以像写Android原生一样写界面：</p>\n<pre><code class=\"lang-json\">{\n    // ...\n    androidResources: {\n        &quot;resDir&quot;: &quot;res&quot;,  // 资源文件夹\n        &quot;manifest&quot;: &quot;AndroidManifest.xml&quot; // AndroidManifest文件路径\n    }\n}\n</code></pre>\n<p>res文件夹通常为以下结构：</p>\n<pre><code>- res\n    - layout  // 布局资源\n    - drawable // 图片、形状等资源\n    - menu // 菜单资源\n    - values // 样式、字符串等资源\n    // ...\n</code></pre><p>可参考示例-&gt;复杂界面-&gt;Android原生界面.</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ]
    }
  ]
}